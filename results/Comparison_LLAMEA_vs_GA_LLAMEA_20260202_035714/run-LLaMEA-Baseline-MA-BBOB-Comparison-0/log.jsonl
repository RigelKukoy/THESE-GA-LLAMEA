{"id": "39b5c582-3d95-4a12-b693-8e19e002afba", "fitness": 0.0, "name": "AdaptiveRankBasedAntColonyOptimization", "description": "An enhanced Rank-Based Ant Colony Optimization algorithm that incorporates a self-adaptive pheromone evaporation rate and a local search intensification strategy around the best solution found so far.", "code": "import numpy as np\n\nclass AdaptiveRankBasedAntColonyOptimization:\n    def __init__(self, budget=10000, dim=10, n_ants=20, initial_evaporation_rate=0.1, alpha=1.0, beta=2.0, intensification_rate=0.05, pheromone_init=1.0, local_search_radius=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = initial_evaporation_rate  # Initial evaporation rate\n        self.alpha = alpha  # Pheromone influence\n        self.beta = beta  # Heuristic influence (fitness)\n        self.intensification_rate = intensification_rate  # How aggressively to intensify search around best solution\n        self.pheromone = np.full(dim, pheromone_init)  # Pheromone trails for each dimension\n        self.best_x = None\n        self.best_f = np.inf\n        self.eval_count = 0\n        self.pheromone_init = pheromone_init\n        self.local_search_radius = local_search_radius # Radius for local search around the best solution\n\n\n    def __call__(self, func):\n        bounds_lb = func.bounds.lb\n        bounds_ub = func.bounds.ub\n        \n        # Initialize ants randomly\n        ants = np.random.uniform(bounds_lb, bounds_ub, size=(self.n_ants, self.dim))\n        fitness = np.array([func(ant) for ant in ants])\n        self.eval_count += self.n_ants\n\n        # Update best solution\n        best_ant_index = np.argmin(fitness)\n        if fitness[best_ant_index] < self.best_f:\n            self.best_f = fitness[best_ant_index]\n            self.best_x = ants[best_ant_index].copy()\n\n        # Rank-based pheromone update parameters\n        elite_ant_count = max(1, int(0.2 * self.n_ants)) # Select top 20% as elite ants\n        rank_weights = np.arange(elite_ant_count, 0, -1) # Linear rank weights\n\n        while self.eval_count < self.budget:\n            # Adaptive Evaporation Rate: Adjust based on stagnation\n            if np.random.rand() < 0.1: # Adjust evaporation rate probabilistically\n                if np.std(fitness) < 1e-3: #Stagnation detected\n                    self.evaporation_rate *= 0.5 # Reduce evaporation to intensify search\n                else:\n                    self.evaporation_rate = min(self.evaporation_rate * 1.1, 0.2) # Increase evaporation to explore more\n            \n            # Pheromone update\n            self.pheromone *= (1 - self.evaporation_rate)\n            \n            # Rank ants by fitness\n            ranked_indices = np.argsort(fitness)\n            elite_indices = ranked_indices[:elite_ant_count]\n\n            # Deposit pheromone based on rank\n            for i, idx in enumerate(elite_indices):\n                delta_pheromone = rank_weights[i] * (self.best_f - fitness[idx]) if fitness[idx] < self.best_f else 0\n                self.pheromone += delta_pheromone * np.abs(ants[idx] - self.best_x)  # Pheromone based on distance to best\n\n            # Normalize pheromone values to prevent domination and avoid zero division\n            self.pheromone = np.clip(self.pheromone, 0.00001, 1000)\n\n            # Ant movement based on pheromone and heuristic\n            for i in range(self.n_ants):\n                for d in range(self.dim):\n                    # Exploration vs. Exploitation using pheromone\n                    exploration_prob = 1.0 / (1.0 + self.pheromone[d]**self.alpha) # High pheromone -> low exploration\n                    \n                    if np.random.rand() < exploration_prob:\n                        # Exploration: Random movement\n                        ants[i, d] = np.random.uniform(bounds_lb[d], bounds_ub[d])\n                    else:\n                        # Exploitation: Move towards best solution with some randomness\n                        step_size = self.intensification_rate * (self.best_x[d] - ants[i, d]) + np.random.normal(0, 0.1)\n                        ants[i, d] += step_size\n                        ants[i, d] = np.clip(ants[i, d], bounds_lb[d], bounds_ub[d])\n\n            # Local Search around the best solution\n            local_search_ants = np.random.normal(self.best_x, self.local_search_radius, size=(5, self.dim)) # 5 ants for local search\n            local_search_ants = np.clip(local_search_ants, bounds_lb, bounds_ub) # Clip to bounds\n            local_search_fitness = np.array([func(ant) for ant in local_search_ants])\n            self.eval_count += 5\n\n            # Update best solution if local search finds a better solution\n            best_local_index = np.argmin(local_search_fitness)\n            if local_search_fitness[best_local_index] < self.best_f:\n                self.best_f = local_search_fitness[best_local_index]\n                self.best_x = local_search_ants[best_local_index].copy()\n                        \n\n            # Evaluate new positions\n            new_fitness = np.array([func(ant) for ant in ants])\n            self.eval_count += self.n_ants\n\n            # Update best solution\n            best_ant_index = np.argmin(new_fitness)\n            if new_fitness[best_ant_index] < self.best_f:\n                self.best_f = new_fitness[best_ant_index]\n                self.best_x = ants[best_ant_index].copy()\n            \n            fitness = new_fitness\n\n        return self.best_f, self.best_x", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveRankBasedAntColonyOptimization scored 0.000 on AOCC (higher is better, 1.0 is the best). The algorithm exhausted the budget. Ensure you stop optimization when budget is 0.", "error": "", "parent_ids": ["b8a08744-f3d8-4adb-94db-7919e7f7f314"], "operator": null, "metadata": {"aucs": [0]}, "task_prompt": "\nYou are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\n\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more.\n"}
