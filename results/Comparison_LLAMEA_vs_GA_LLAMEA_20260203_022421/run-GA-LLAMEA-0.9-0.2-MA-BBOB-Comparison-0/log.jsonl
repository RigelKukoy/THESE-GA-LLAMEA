{"id": "190049d0-8af6-41d5-9184-947e29cc0eb0", "fitness": "-inf", "name": "AdaptiveShrinkingDE", "description": "An adaptive differential evolution strategy with a population size that shrinks based on the remaining budget, combined with a restarting mechanism to escape local optima.", "code": "import numpy as np\n\nclass AdaptiveShrinkingDE:\n    def __init__(self, budget=10000, dim=10, pop_size_factor=10, F=0.5, Cr=0.9, restart_factor=0.1):\n        \"\"\"\n        Adaptive Differential Evolution with shrinking population size.\n\n        Args:\n            budget: Total function evaluations allowed.\n            dim: Dimensionality of the problem.\n            pop_size_factor: Factor determining the initial population size (pop_size = pop_size_factor * dim).\n            F: Mutation factor.\n            Cr: Crossover rate.\n            restart_factor: Fraction of budget after which to restart population\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size_factor = pop_size_factor\n        self.F = F\n        self.Cr = Cr\n        self.restart_factor = restart_factor\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0  # Keep track of function evaluations\n\n    def __call__(self, func):\n        # Initial population size\n        pop_size = int(self.pop_size_factor * self.dim)\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(pop_size, self.dim))\n        fitness = np.array([func(x) for x in self.population])\n        self.evals += pop_size\n\n        # Update optimal solution\n        best_index = np.argmin(fitness)\n        if fitness[best_index] < self.f_opt:\n            self.f_opt = fitness[best_index]\n            self.x_opt = self.population[best_index].copy()\n\n        while self.evals < self.budget:\n            # Shrink population size linearly with remaining budget\n            remaining_budget = self.budget - self.evals\n            pop_size = max(int(self.pop_size_factor * self.dim * (remaining_budget / self.budget)), self.dim + 1) #ensure pop_size is always at least dim + 1 for DE to work\n\n            if self.population.shape[0] > pop_size:\n                #Reduce population by removing worst individuals\n                indices_to_keep = np.argsort(fitness)[:pop_size]\n                self.population = self.population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n\n            for i in range(self.population.shape[0]):\n                # Mutation\n                idxs = [idx for idx in range(self.population.shape[0]) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.Cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                f = func(trial)\n                self.evals += 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    self.population[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial.copy()\n\n            # Restart mechanism\n            if self.evals > self.restart_factor * self.budget:\n                self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(pop_size, self.dim))\n                fitness = np.array([func(x) for x in self.population])\n                self.evals += pop_size\n                \n                # Update optimal solution\n                best_index = np.argmin(fitness)\n                if fitness[best_index] < self.f_opt:\n                    self.f_opt = fitness[best_index]\n                    self.x_opt = self.population[best_index].copy()\n                \n                # Reset restart trigger\n                self.evals = 0 #effectively restarts, if budget exceeds restart_factor*self.budget * multiple times\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "Evaluation timed out after 60 seconds.", "error": "Evaluation timed out after 60 seconds.", "parent_ids": [], "operator": null, "metadata": {"llm_response": "# Description: An adaptive differential evolution strategy with a population size that shrinks based on the remaining budget, combined with a restarting mechanism to escape local optima.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveShrinkingDE:\n    def __init__(self, budget=10000, dim=10, pop_size_factor=10, F=0.5, Cr=0.9, restart_factor=0.1):\n        \"\"\"\n        Adaptive Differential Evolution with shrinking population size.\n\n        Args:\n            budget: Total function evaluations allowed.\n            dim: Dimensionality of the problem.\n            pop_size_factor: Factor determining the initial population size (pop_size = pop_size_factor * dim).\n            F: Mutation factor.\n            Cr: Crossover rate.\n            restart_factor: Fraction of budget after which to restart population\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size_factor = pop_size_factor\n        self.F = F\n        self.Cr = Cr\n        self.restart_factor = restart_factor\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0  # Keep track of function evaluations\n\n    def __call__(self, func):\n        # Initial population size\n        pop_size = int(self.pop_size_factor * self.dim)\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(pop_size, self.dim))\n        fitness = np.array([func(x) for x in self.population])\n        self.evals += pop_size\n\n        # Update optimal solution\n        best_index = np.argmin(fitness)\n        if fitness[best_index] < self.f_opt:\n            self.f_opt = fitness[best_index]\n            self.x_opt = self.population[best_index].copy()\n\n        while self.evals < self.budget:\n            # Shrink population size linearly with remaining budget\n            remaining_budget = self.budget - self.evals\n            pop_size = max(int(self.pop_size_factor * self.dim * (remaining_budget / self.budget)), self.dim + 1) #ensure pop_size is always at least dim + 1 for DE to work\n\n            if self.population.shape[0] > pop_size:\n                #Reduce population by removing worst individuals\n                indices_to_keep = np.argsort(fitness)[:pop_size]\n                self.population = self.population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n\n            for i in range(self.population.shape[0]):\n                # Mutation\n                idxs = [idx for idx in range(self.population.shape[0]) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.Cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                f = func(trial)\n                self.evals += 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    self.population[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial.copy()\n\n            # Restart mechanism\n            if self.evals > self.restart_factor * self.budget:\n                self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(pop_size, self.dim))\n                fitness = np.array([func(x) for x in self.population])\n                self.evals += pop_size\n                \n                # Update optimal solution\n                best_index = np.argmin(fitness)\n                if fitness[best_index] < self.f_opt:\n                    self.f_opt = fitness[best_index]\n                    self.x_opt = self.population[best_index].copy()\n                \n                # Reset restart trigger\n                self.evals = 0 #effectively restarts, if budget exceeds restart_factor*self.budget * multiple times\n\n        return self.f_opt, self.x_opt\n```", "generation": 0, "operator": "init"}, "task_prompt": ""}
