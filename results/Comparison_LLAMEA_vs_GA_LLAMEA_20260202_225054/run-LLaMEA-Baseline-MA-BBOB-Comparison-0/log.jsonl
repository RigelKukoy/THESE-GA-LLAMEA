{"id": "18fc08cc-36bf-45e1-9241-12e8652fe111", "fitness": "-inf", "name": "HybridPSO_DE_LocalSearch", "description": "A population-based algorithm that combines particle swarm optimization (PSO) principles with differential evolution (DE) mutation and crossover strategies, enhanced with a local search operator to improve exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE_LocalSearch:\n    def __init__(self, budget=10000, dim=10, pop_size=50, w=0.7, c1=1.5, c2=1.5, cr=0.7, F=0.8, local_search_prob=0.1, local_search_radius=0.1):\n        \"\"\"\n        Initializes the Hybrid PSO-DE algorithm.\n\n        Args:\n            budget (int): The total number of function evaluations allowed.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The number of particles in the swarm.\n            w (float): Inertia weight for PSO.\n            c1 (float): Cognitive coefficient for PSO.\n            c2 (float): Social coefficient for PSO.\n            cr (float): Crossover rate for DE.\n            F (float): Mutation factor for DE.\n            local_search_prob (float): Probability of applying local search to a particle.\n            local_search_radius (float): Radius for the local search.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.w = w\n        self.c1 = c1\n        self.c2 = c2\n        self.cr = cr\n        self.F = F\n        self.local_search_prob = local_search_prob\n        self.local_search_radius = local_search_radius\n\n        self.X = None  # Particle positions\n        self.V = None  # Particle velocities\n        self.fitness = None  # Fitness of each particle\n        self.personal_best_X = None  # Best position found by each particle\n        self.personal_best_fitness = None  # Fitness of the best position found by each particle\n        self.global_best_X = None  # Best position found by the entire swarm\n        self.global_best_fitness = np.inf  # Fitness of the best position found by the entire swarm\n        self.eval_count = 0\n        self.func = None\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the particle swarm.\"\"\"\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.X = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.V = np.random.uniform(-abs(ub - lb), abs(ub - lb), size=(self.pop_size, self.dim))\n        self.fitness = np.zeros(self.pop_size)\n        self.personal_best_X = np.copy(self.X)\n        self.personal_best_fitness = np.full(self.pop_size, np.inf)\n\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.X[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.personal_best_fitness[i]:\n                self.personal_best_fitness[i] = self.fitness[i]\n                self.personal_best_X[i] = np.copy(self.X[i])\n\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best_fitness = self.fitness[i]\n                self.global_best_X = np.copy(self.X[i])\n\n\n    def local_search(self, x, func):\n        \"\"\"Performs a local search around a given position.\"\"\"\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        new_x = x + np.random.uniform(-self.local_search_radius, self.local_search_radius, size=self.dim)\n        new_x = np.clip(new_x, lb, ub)  # Keep within bounds\n        f_new = func(new_x)\n        self.eval_count += 1\n        return f_new, new_x\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function using the Hybrid PSO-DE algorithm.\"\"\"\n        self.func = func\n        self.eval_count = 0\n        self.global_best_fitness = np.inf\n\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation and Crossover\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.X[idxs[0]], self.X[idxs[1]], self.X[idxs[2]]\n                v_mutation = x_r1 + self.F * (x_r2 - x_r3)\n                lb = func.bounds.lb\n                ub = func.bounds.ub\n                v_mutation = np.clip(v_mutation, lb, ub)\n\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.random.rand(self.dim)\n                mask = (u <= self.cr) | (np.arange(self.dim) == j_rand)\n                u_i = np.where(mask, v_mutation, self.X[i])\n\n                # Evaluate trial vector\n                f_trial = func(u_i)\n                self.eval_count += 1\n\n                if f_trial < self.fitness[i]:\n                    self.fitness[i] = f_trial\n                    self.X[i] = np.copy(u_i)\n\n                    if f_trial < self.personal_best_fitness[i]:\n                        self.personal_best_fitness[i] = f_trial\n                        self.personal_best_X[i] = np.copy(u_i)\n\n                        if f_trial < self.global_best_fitness:\n                            self.global_best_fitness = f_trial\n                            self.global_best_X = np.copy(u_i)\n\n\n                # PSO Velocity Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.V[i] = (self.w * self.V[i] +\n                             self.c1 * r1 * (self.personal_best_X[i] - self.X[i]) +\n                             self.c2 * r2 * (self.global_best_X - self.X[i]))\n\n                # PSO Position Update\n                self.X[i] = self.X[i] + self.V[i]\n                self.X[i] = np.clip(self.X[i], lb, ub)  # Clip to bounds\n\n                # Evaluate updated position\n                self.fitness[i] = func(self.X[i])\n                self.eval_count += 1\n\n                if self.fitness[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = self.fitness[i]\n                    self.personal_best_X[i] = np.copy(self.X[i])\n\n                    if self.fitness[i] < self.global_best_fitness:\n                        self.global_best_fitness = self.fitness[i]\n                        self.global_best_X = np.copy(self.X[i])\n                # Local Search\n                if np.random.rand() < self.local_search_prob:\n                    f_local, x_local = self.local_search(self.X[i], func)\n                    if f_local < self.fitness[i]:\n                        self.fitness[i] = f_local\n                        self.X[i] = np.copy(x_local)\n\n                        if f_local < self.personal_best_fitness[i]:\n                            self.personal_best_fitness[i] = f_local\n                            self.personal_best_X[i] = np.copy(x_local)\n\n                            if f_local < self.global_best_fitness:\n                                self.global_best_fitness = f_local\n                                self.global_best_X = np.copy(x_local)\n\n\n        return self.global_best_fitness, self.global_best_X", "configspace": "", "generation": 0, "feedback": "Evaluation failed without an exception.", "error": "Evaluation failed without an exception.", "parent_ids": [], "operator": null, "metadata": {}, "task_prompt": "\nYou are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\n\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more.\n"}
