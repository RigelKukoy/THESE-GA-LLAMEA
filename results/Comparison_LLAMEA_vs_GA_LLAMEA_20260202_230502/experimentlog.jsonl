{"method_name": "LLaMEA-Baseline", "problem_name": "MA-BBOB-Comparison", "llm_name": "gemini-2.0-flash", "method": {"method_name": "LLaMEA-Baseline", "budget": 20, "kwargs": {"mutation_prompts": ["Refine the strategy of the selected algorithm to improve it."], "n_parents": 4, "n_offspring": 8, "elitism": true}}, "problem": {"name": "MA-BBOB-Comparison", "dims": [5], "training_instances": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "test_instances": [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49], "budget_factor": 1000}, "llm": {"model": "gemini-2.0-flash", "code_pattern": "```(?:python)?\\n(.*?)\\n```", "name_pattern": "class\\s*(\\w*)(?:\\(\\w*\\))?\\:", "desc_pattern": "#\\s*Description\\s*:\\s*(.*)", "cs_pattern": "space\\s*:\\s*\\n*```\\n*(?:python)?\\n(.*?)\\n```"}, "solution": {"id": "2378173c-4166-4c2f-ab1d-18826c4ba953", "fitness": 0.28412035881972864, "name": "AdaptiveDEArchiveCMAESRestart", "description": "Adaptive Differential Evolution with an external archive, covariance matrix adaptation for mutation, and a restart strategy based on fitness stagnation.", "code": "import numpy as np\n\nclass AdaptiveDEArchiveCMAESRestart:\n    def __init__(self, budget=10000, dim=10, pop_size=None, F=0.5, Cr=0.9, archive_size=50, restart_patience=1000, cma_learning_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.F = F  # Mutation factor (initial)\n        self.Cr = Cr  # Crossover rate (initial)\n        self.archive_size = archive_size\n        self.archive = []\n        self.restart_patience = restart_patience\n        self.best_fitness_history = []\n        self.cma_learning_rate = cma_learning_rate # Learning rate for CMA-ES adaptation\n\n        # CMA-ES initialization\n        self.mean = None # initialized later\n        self.covariance = None # initialized later\n        self.step_size = 1.0\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population and CMA-ES parameters\n        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.covariance = np.eye(self.dim)\n        self.population = np.random.multivariate_normal(self.mean, self.covariance, size=self.pop_size)\n        self.population = np.clip(self.population, func.bounds.lb, func.bounds.ub)\n\n        self.fitness = np.array([func(x) for x in self.population])\n        self.nevals = self.pop_size\n\n        self.best_fitness_history.append(np.min(self.fitness))\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.nevals < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.pop_size):\n                # Mutation using CMA-ES-like adaptation\n                z = np.random.randn(self.dim)\n                mutant = self.mean + self.step_size * np.dot(np.linalg.cholesky(self.covariance), z)\n\n                # Archive component\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    x_archive = self.archive[np.random.randint(len(self.archive))]\n                    mutant = 0.5 * (mutant + x_archive) # Blend mutant with archive member\n\n\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(crossover_mask, mutant, self.population[i])\n\n                # Selection\n                f_trial = func(trial_vector)\n                self.nevals += 1\n\n                if f_trial < self.fitness[i]:\n                    new_fitness.append(f_trial)\n                    new_population.append(trial_vector)\n\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(trial_vector.copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = trial_vector.copy()\n\n                    #Update best\n                    if f_trial < self.f_opt:\n                      self.f_opt = f_trial\n                      self.x_opt = trial_vector\n\n                else:\n                  new_fitness.append(self.fitness[i])\n                  new_population.append(self.population[i])\n\n                if self.nevals >= self.budget:\n                  break\n\n            self.population = np.array(new_population)\n            self.fitness = np.array(new_fitness)\n\n            # CMA-ES adaptation\n            best_idx = np.argmin(self.fitness)\n            diff = self.population[best_idx] - self.mean\n            self.mean = (1 - self.cma_learning_rate) * self.mean + self.cma_learning_rate * self.population[best_idx]\n            self.covariance = (1 - self.cma_learning_rate) * self.covariance + self.cma_learning_rate * np.outer(diff, diff)\n            # Ensure covariance is positive definite\n            try:\n                np.linalg.cholesky(self.covariance)\n            except np.linalg.LinAlgError:\n                self.covariance = self.covariance + 1e-6 * np.eye(self.dim)\n\n            self.best_fitness_history.append(np.min(self.fitness))\n\n            # Adaptive F and Cr (simple adaptation)\n            self.F = 0.5 + 0.3 * np.random.randn()\n            self.Cr = 0.9 + 0.1 * np.random.randn()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.Cr = np.clip(self.Cr, 0.1, 1.0)\n\n            # Restart mechanism\n            if len(self.best_fitness_history) > self.restart_patience:\n                if np.std(self.best_fitness_history[-self.restart_patience:]) < 1e-8:  #Stagnation\n                    self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n                    self.covariance = np.eye(self.dim)\n                    self.population = np.random.multivariate_normal(self.mean, self.covariance, size=self.pop_size)\n                    self.population = np.clip(self.population, func.bounds.lb, func.bounds.ub)\n                    self.fitness = np.array([func(x) for x in self.population])\n                    self.nevals += self.pop_size\n                    self.best_fitness_history.append(np.min(self.fitness))\n                    print(\"Restarting population\")\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDEArchiveCMAESRestart scored 0.284 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["025ba8ce-184d-4c12-afa8-0d7ddc8792d0"], "operator": null, "metadata": {"aucs": [0.10535039867507767, 0.1628197230645323, 0.4054397735823442, 0.49507138961150754, 0.30785638242068925, 0.41316580705199835, 0.2618238476470056, 0.34615045161911195, 0.16259937491520904, 0.18092643960981136]}, "task_prompt": "\nYou are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\n\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more.\n"}, "log_dir": "run-LLaMEA-Baseline-MA-BBOB-Comparison-0", "seed": 0}
