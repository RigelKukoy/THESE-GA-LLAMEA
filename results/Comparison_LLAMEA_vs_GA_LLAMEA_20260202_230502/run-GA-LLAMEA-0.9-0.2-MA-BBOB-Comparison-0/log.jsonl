{"id": "5d51812b-7439-4498-88ec-6c0605e9f9c3", "fitness": 0.29200678689260723, "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution strategy with a self-adjusting population size and mutation/crossover parameters based on success history.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_factor=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_factor = pop_factor  # Population size multiplier\n        self.pop_size = int(self.pop_factor * self.dim)\n        self.memory_size = 10 # Size of memory for successful F and CR values\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.lb = func.bounds.lb\n        self.ub = func.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        self.memory_F = np.ones(self.memory_size) * 0.5 # Initialize F memory with 0.5\n        self.memory_CR = np.ones(self.memory_size) * 0.5 # Initialize CR memory with 0.5\n        self.archive = [] # Archive for storing inferior solutions\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation based on memory\n                F = np.random.choice(self.memory_F)\n                CR = np.random.choice(self.memory_CR)\n                \n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                \n                mutant = self.population[i] + F * (x_r2 - x_r3)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n                \n                # Selection\n                f_trial = func(trial)\n                self.budget -= 1\n                \n                if f_trial < self.fitness[i]:\n                    self.archive.append(self.population[i]) # Store old solution\n                    self.population[i] = trial\n                    self.fitness[i] = f_trial\n\n                    # Update successful parameter memory\n                    self.memory_F = np.roll(self.memory_F, 1)\n                    self.memory_F[0] = F\n\n                    self.memory_CR = np.roll(self.memory_CR, 1)\n                    self.memory_CR[0] = CR\n                    \n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n\n                elif np.random.rand() < 0.1:  #Adding a chance to accept worse solutions in the archive for exploration.\n                    self.archive.append(trial)\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.292 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"llm_response": "# Description: An adaptive differential evolution strategy with a self-adjusting population size and mutation/crossover parameters based on success history.\n\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_factor=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_factor = pop_factor  # Population size multiplier\n        self.pop_size = int(self.pop_factor * self.dim)\n        self.memory_size = 10 # Size of memory for successful F and CR values\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.lb = func.bounds.lb\n        self.ub = func.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        self.memory_F = np.ones(self.memory_size) * 0.5 # Initialize F memory with 0.5\n        self.memory_CR = np.ones(self.memory_size) * 0.5 # Initialize CR memory with 0.5\n        self.archive = [] # Archive for storing inferior solutions\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation based on memory\n                F = np.random.choice(self.memory_F)\n                CR = np.random.choice(self.memory_CR)\n                \n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                \n                mutant = self.population[i] + F * (x_r2 - x_r3)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n                \n                # Selection\n                f_trial = func(trial)\n                self.budget -= 1\n                \n                if f_trial < self.fitness[i]:\n                    self.archive.append(self.population[i]) # Store old solution\n                    self.population[i] = trial\n                    self.fitness[i] = f_trial\n\n                    # Update successful parameter memory\n                    self.memory_F = np.roll(self.memory_F, 1)\n                    self.memory_F[0] = F\n\n                    self.memory_CR = np.roll(self.memory_CR, 1)\n                    self.memory_CR[0] = CR\n                    \n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n\n                elif np.random.rand() < 0.1:  #Adding a chance to accept worse solutions in the archive for exploration.\n                    self.archive.append(trial)\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt\n```", "generation": 0, "operator": "init", "aucs": [0.1352282261873906, 0.20434182254452393, 0.3945054344959069, 0.40907243746857225, 0.28081251160223797, 0.40134206707888265, 0.29243773003524354, 0.3235141008251846, 0.29125987068251624, 0.18755366800561324]}, "task_prompt": ""}
{"id": "23ceebde-d2eb-4d16-84fd-c512ae95f57a", "fitness": "-inf", "name": "AdaptiveDE", "description": "An adaptive differential evolution strategy that adjusts mutation and crossover rates based on population diversity and success rate.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, Cr=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the problem.\n            pop_size (int): The population size.\n            F (float): Initial mutation factor.\n            Cr (float): Initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.success_history_F = []\n        self.success_history_Cr = []\n        self.archive = []\n\n\n    def initialize_population(self, func):\n        \"\"\"Initialize the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n    def mutate(self):\n        \"\"\"Perform differential mutation.\"\"\"\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            \n            # Adaptive F based on success history\n            if self.success_history_F:\n                F = np.random.choice(self.success_history_F)\n            else:\n                F = self.F #Fallback to initial F\n\n            mutant = a + F * (b - c)\n            mutant = np.clip(mutant, -5.0, 5.0)  # Clip to bounds\n            \n            yield mutant\n    \n\n    def crossover(self, mutant, i):\n        \"\"\"Perform binomial crossover.\"\"\"\n        trial = np.copy(self.pop[i])\n        \n        #Adaptive Cr based on success history\n        if self.success_history_Cr:\n            Cr = np.random.choice(self.success_history_Cr)\n        else:\n            Cr = self.Cr #Fallback to initial Cr\n        \n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < Cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n\n    def selection(self, func, trial, i):\n        \"\"\"Perform selection and update the best solution.\"\"\"\n        f_trial = func(trial)\n        self.eval_count += 1\n\n        if f_trial < self.fitness[i]:\n            # Update success history for F and Cr adaptation\n            delta = np.abs(self.fitness[i] - f_trial)\n            self.success_history_F.append(self.F)\n            self.success_history_Cr.append(self.Cr) # Track Cr when improvement happens\n            \n            if len(self.success_history_F) > 10:\n                self.success_history_F.pop(0)\n                self.success_history_Cr.pop(0)\n\n            self.pop[i] = trial\n            self.fitness[i] = f_trial\n\n            if f_trial < self.f_opt:\n                self.f_opt = f_trial\n                self.x_opt = trial\n        else:\n            # Archive the failed solution to promote exploration\n            self.archive.append(self.pop[i])\n            if len(self.archive) > self.pop_size: # Keep archive size reasonable\n                self.archive.pop(0)\n\n\n    def __call__(self, func):\n        \"\"\"Optimize the black box function using Adaptive Differential Evolution.\"\"\"\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i, mutant in enumerate(self.mutate()):\n                if self.eval_count >= self.budget:\n                    break\n                trial = self.crossover(mutant, i)\n                self.selection(func, trial, i)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "Evaluation timed out after 600 seconds.", "error": "Evaluation timed out after 600 seconds.", "parent_ids": [], "operator": null, "metadata": {"llm_response": "# Description: An adaptive differential evolution strategy that adjusts mutation and crossover rates based on population diversity and success rate.\n# Code:\n```python\nimport numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, Cr=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the problem.\n            pop_size (int): The population size.\n            F (float): Initial mutation factor.\n            Cr (float): Initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.success_history_F = []\n        self.success_history_Cr = []\n        self.archive = []\n\n\n    def initialize_population(self, func):\n        \"\"\"Initialize the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n    def mutate(self):\n        \"\"\"Perform differential mutation.\"\"\"\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            \n            # Adaptive F based on success history\n            if self.success_history_F:\n                F = np.random.choice(self.success_history_F)\n            else:\n                F = self.F #Fallback to initial F\n\n            mutant = a + F * (b - c)\n            mutant = np.clip(mutant, -5.0, 5.0)  # Clip to bounds\n            \n            yield mutant\n    \n\n    def crossover(self, mutant, i):\n        \"\"\"Perform binomial crossover.\"\"\"\n        trial = np.copy(self.pop[i])\n        \n        #Adaptive Cr based on success history\n        if self.success_history_Cr:\n            Cr = np.random.choice(self.success_history_Cr)\n        else:\n            Cr = self.Cr #Fallback to initial Cr\n        \n        j_rand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < Cr or j == j_rand:\n                trial[j] = mutant[j]\n        return trial\n\n\n    def selection(self, func, trial, i):\n        \"\"\"Perform selection and update the best solution.\"\"\"\n        f_trial = func(trial)\n        self.eval_count += 1\n\n        if f_trial < self.fitness[i]:\n            # Update success history for F and Cr adaptation\n            delta = np.abs(self.fitness[i] - f_trial)\n            self.success_history_F.append(self.F)\n            self.success_history_Cr.append(self.Cr) # Track Cr when improvement happens\n            \n            if len(self.success_history_F) > 10:\n                self.success_history_F.pop(0)\n                self.success_history_Cr.pop(0)\n\n            self.pop[i] = trial\n            self.fitness[i] = f_trial\n\n            if f_trial < self.f_opt:\n                self.f_opt = f_trial\n                self.x_opt = trial\n        else:\n            # Archive the failed solution to promote exploration\n            self.archive.append(self.pop[i])\n            if len(self.archive) > self.pop_size: # Keep archive size reasonable\n                self.archive.pop(0)\n\n\n    def __call__(self, func):\n        \"\"\"Optimize the black box function using Adaptive Differential Evolution.\"\"\"\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i, mutant in enumerate(self.mutate()):\n                if self.eval_count >= self.budget:\n                    break\n                trial = self.crossover(mutant, i)\n                self.selection(func, trial, i)\n\n        return self.f_opt, self.x_opt\n```", "generation": 0, "operator": "init"}, "task_prompt": ""}
{"id": "4a6a4dce-9bde-4e8d-9a10-a726778ccd1b", "fitness": "-inf", "name": "AntColonyOptimization", "description": "A population-based algorithm inspired by the foraging behavior of ants, employing a pheromone-based probabilistic search and local refinement.", "code": "import numpy as np\n\nclass AntColonyOptimization:\n    def __init__(self, budget=10000, dim=10, colony_size=20, evaporation_rate=0.1, alpha=1, beta=2, pheromone_init=1.0):\n        self.budget = budget\n        self.dim = dim\n        self.colony_size = colony_size\n        self.evaporation_rate = evaporation_rate\n        self.alpha = alpha  # Pheromone influence\n        self.beta = beta  # Heuristic influence\n        self.pheromone_init = pheromone_init\n\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pheromone = np.full((self.dim, 2), self.pheromone_init) # Pheromone for each dimension, [0] for moving towards lb, [1] for moving towards ub.\n        self.best_solution = None\n        self.best_fitness = np.inf\n        eval_count = 0\n\n\n        # Initialize colony\n        colony = np.random.uniform(lb, ub, size=(self.colony_size, self.dim))\n        fitness = np.array([func(ant) for ant in colony])\n        eval_count += self.colony_size\n\n        best_ant_index = np.argmin(fitness)\n        if fitness[best_ant_index] < self.best_fitness:\n            self.best_fitness = fitness[best_ant_index]\n            self.best_solution = colony[best_ant_index].copy()\n            \n\n        while eval_count < self.budget:\n            # Construct solutions\n            new_colony = np.zeros_like(colony)\n            for i in range(self.colony_size):\n                for d in range(self.dim):\n                    # Pheromone-based probabilistic search\n                    pheromone_left = self.pheromone[d, 0]\n                    pheromone_right = self.pheromone[d, 1]\n                    \n                    # Heuristic influence: favoring better solutions.  Using a simple heuristic for now.\n                    heuristic_left = abs(colony[i,d] - lb)\n                    heuristic_right = abs(colony[i,d] - ub)\n\n                    prob_left = (pheromone_left**self.alpha) * (heuristic_left**self.beta)\n                    prob_right = (pheromone_right**self.alpha) * (heuristic_right**self.beta)\n                    total_prob = prob_left + prob_right\n\n                    if total_prob == 0:\n                        #In case of zero pheromones (very unlikely, but to prevent division by zero errors).\n                        prob_left = 0.5\n                        prob_right = 0.5\n\n                    prob_left /= total_prob\n                    \n                    if np.random.rand() < prob_left:\n                        #Move towards lower bound\n                        new_colony[i, d] = colony[i, d] - np.random.rand() * abs(colony[i, d] - lb)\n                        new_colony[i, d] = max(new_colony[i, d], lb)\n                    else:\n                        #Move towards upper bound\n                        new_colony[i, d] = colony[i, d] + np.random.rand() * abs(ub - colony[i, d])\n                        new_colony[i, d] = min(new_colony[i, d], ub)\n            \n            # Evaluate new solutions\n            new_fitness = np.array([func(ant) for ant in new_colony])\n            eval_count += self.colony_size\n\n            # Update best solution\n            best_ant_index = np.argmin(new_fitness)\n            if new_fitness[best_ant_index] < self.best_fitness:\n                self.best_fitness = new_fitness[best_ant_index]\n                self.best_solution = new_colony[best_ant_index].copy()\n\n            # Update pheromones (evaporation and deposition)\n            self.pheromone *= (1 - self.evaporation_rate)  # Evaporation\n\n            # Pheromone deposition:  Focus on the best ant for simplicity.\n            delta_pheromone = 1.0 / (1 + self.best_fitness) #Pheromone deposit amount. Adding 1 to avoid division by zero if best_fitness is close to 0\n            \n            for d in range(self.dim):\n                if self.best_solution[d] < colony[best_ant_index,d]:  # best ant moved towards lower bound\n                    self.pheromone[d, 0] += delta_pheromone\n                else:\n                    self.pheromone[d, 1] += delta_pheromone\n\n\n            # Replace old colony with new colony\n            colony = new_colony.copy()\n            fitness = new_fitness.copy()\n\n        return self.best_fitness, self.best_solution", "configspace": "", "generation": 0, "feedback": "In the code, line 51, in __call__, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: if total_prob == 0:", "error": "In the code, line 51, in __call__, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: if total_prob == 0:", "parent_ids": [], "operator": null, "metadata": {"llm_response": "# Description: A population-based algorithm inspired by the foraging behavior of ants, employing a pheromone-based probabilistic search and local refinement.\n# Code: \n```python\nimport numpy as np\n\nclass AntColonyOptimization:\n    def __init__(self, budget=10000, dim=10, colony_size=20, evaporation_rate=0.1, alpha=1, beta=2, pheromone_init=1.0):\n        self.budget = budget\n        self.dim = dim\n        self.colony_size = colony_size\n        self.evaporation_rate = evaporation_rate\n        self.alpha = alpha  # Pheromone influence\n        self.beta = beta  # Heuristic influence\n        self.pheromone_init = pheromone_init\n\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pheromone = np.full((self.dim, 2), self.pheromone_init) # Pheromone for each dimension, [0] for moving towards lb, [1] for moving towards ub.\n        self.best_solution = None\n        self.best_fitness = np.inf\n        eval_count = 0\n\n\n        # Initialize colony\n        colony = np.random.uniform(lb, ub, size=(self.colony_size, self.dim))\n        fitness = np.array([func(ant) for ant in colony])\n        eval_count += self.colony_size\n\n        best_ant_index = np.argmin(fitness)\n        if fitness[best_ant_index] < self.best_fitness:\n            self.best_fitness = fitness[best_ant_index]\n            self.best_solution = colony[best_ant_index].copy()\n            \n\n        while eval_count < self.budget:\n            # Construct solutions\n            new_colony = np.zeros_like(colony)\n            for i in range(self.colony_size):\n                for d in range(self.dim):\n                    # Pheromone-based probabilistic search\n                    pheromone_left = self.pheromone[d, 0]\n                    pheromone_right = self.pheromone[d, 1]\n                    \n                    # Heuristic influence: favoring better solutions.  Using a simple heuristic for now.\n                    heuristic_left = abs(colony[i,d] - lb)\n                    heuristic_right = abs(colony[i,d] - ub)\n\n                    prob_left = (pheromone_left**self.alpha) * (heuristic_left**self.beta)\n                    prob_right = (pheromone_right**self.alpha) * (heuristic_right**self.beta)\n                    total_prob = prob_left + prob_right\n\n                    if total_prob == 0:\n                        #In case of zero pheromones (very unlikely, but to prevent division by zero errors).\n                        prob_left = 0.5\n                        prob_right = 0.5\n\n                    prob_left /= total_prob\n                    \n                    if np.random.rand() < prob_left:\n                        #Move towards lower bound\n                        new_colony[i, d] = colony[i, d] - np.random.rand() * abs(colony[i, d] - lb)\n                        new_colony[i, d] = max(new_colony[i, d], lb)\n                    else:\n                        #Move towards upper bound\n                        new_colony[i, d] = colony[i, d] + np.random.rand() * abs(ub - colony[i, d])\n                        new_colony[i, d] = min(new_colony[i, d], ub)\n            \n            # Evaluate new solutions\n            new_fitness = np.array([func(ant) for ant in new_colony])\n            eval_count += self.colony_size\n\n            # Update best solution\n            best_ant_index = np.argmin(new_fitness)\n            if new_fitness[best_ant_index] < self.best_fitness:\n                self.best_fitness = new_fitness[best_ant_index]\n                self.best_solution = new_colony[best_ant_index].copy()\n\n            # Update pheromones (evaporation and deposition)\n            self.pheromone *= (1 - self.evaporation_rate)  # Evaporation\n\n            # Pheromone deposition:  Focus on the best ant for simplicity.\n            delta_pheromone = 1.0 / (1 + self.best_fitness) #Pheromone deposit amount. Adding 1 to avoid division by zero if best_fitness is close to 0\n            \n            for d in range(self.dim):\n                if self.best_solution[d] < colony[best_ant_index,d]:  # best ant moved towards lower bound\n                    self.pheromone[d, 0] += delta_pheromone\n                else:\n                    self.pheromone[d, 1] += delta_pheromone\n\n\n            # Replace old colony with new colony\n            colony = new_colony.copy()\n            fitness = new_fitness.copy()\n\n        return self.best_fitness, self.best_solution\n```", "generation": 0, "operator": "init"}, "task_prompt": ""}
{"id": "5b7e715e-7f4c-4081-aeec-4a8288b4d303", "fitness": "-inf", "name": "CooperativeSwarm", "description": "Cooperative Swarm with Adaptive Mutation and Neighborhood Search: Employs a swarm of particles that cooperate and explore the search space, adaptively adjusting their mutation rate and exploring their neighborhood to balance exploration and exploitation.", "code": "import numpy as np\n\nclass CooperativeSwarm:\n    def __init__(self, budget=10000, dim=10, swarm_size=20, c1=1.5, c2=1.5, w_start=0.9, w_end=0.4, mutation_rate_start=0.1, mutation_rate_end=0.01, neighborhood_size=3):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.c1 = c1\n        self.c2 = c2\n        self.w_start = w_start\n        self.w_end = w_end\n        self.mutation_rate_start = mutation_rate_start\n        self.mutation_rate_end = mutation_rate_end\n        self.neighborhood_size = neighborhood_size # Number of neighbors to consider\n\n        self.x = np.random.uniform(-5, 5, size=(swarm_size, dim))\n        self.v = np.random.uniform(-1, 1, size=(swarm_size, dim))  # Initialize velocities\n        self.pbest_x = self.x.copy()\n        self.pbest_f = np.full(swarm_size, np.inf)\n        self.gbest_x = None\n        self.gbest_f = np.inf\n\n        self.eval_count = 0\n\n    def __call__(self, func):\n        while self.eval_count < self.budget:\n            # Adaptive inertia weight\n            w = self.w_start - (self.w_start - self.w_end) * (self.eval_count / self.budget)\n            \n            # Adaptive mutation rate\n            mutation_rate = self.mutation_rate_start - (self.mutation_rate_start - self.mutation_rate_end) * (self.eval_count / self.budget)\n            \n            for i in range(self.swarm_size):\n                # Evaluate current position\n                f = func(self.x[i])\n                self.eval_count += 1\n                if self.eval_count >= self.budget:\n                    break\n\n                if f < self.pbest_f[i]:\n                    self.pbest_f[i] = f\n                    self.pbest_x[i] = self.x[i].copy()\n\n                    if f < self.gbest_f:\n                        self.gbest_f = f\n                        self.gbest_x = self.x[i].copy()\n\n                # Update velocity and position using PSO formula\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.v[i] = w * self.v[i] + self.c1 * r1 * (self.pbest_x[i] - self.x[i]) + self.c2 * r2 * (self.gbest_x - self.x[i])\n                self.x[i] = self.x[i] + self.v[i]\n\n                # Boundary Handling\n                self.x[i] = np.clip(self.x[i], -5, 5)\n\n\n                # Mutation\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_rate:\n                        self.x[i, j] += np.random.normal(0, 1) * (5 - (-5)) * 0.1 # Add some noise\n                        self.x[i, j] = np.clip(self.x[i, j], -5, 5)\n\n                # Neighborhood Search\n                # Select k nearest neighbors based on Euclidean distance\n                distances = np.linalg.norm(self.x - self.x[i], axis=1)\n                neighbors_idx = np.argsort(distances)[1:self.neighborhood_size+1] # Exclude itself\n\n                # Explore the neighborhood by averaging the positions of the neighbors\n                neighbor_positions = self.x[neighbors_idx]\n                neighborhood_center = np.mean(neighbor_positions, axis=0)\n\n                # Move towards the neighborhood center with a small step\n                step_size = 0.1  # Adjust the step size as needed\n                self.x[i] = self.x[i] + step_size * (neighborhood_center - self.x[i])\n                self.x[i] = np.clip(self.x[i], -5, 5)\n\n            if self.eval_count >= self.budget:\n                break\n\n        return self.gbest_f, self.gbest_x", "configspace": "", "generation": 0, "feedback": "Evaluation timed out after 600 seconds.", "error": "Evaluation timed out after 600 seconds.", "parent_ids": [], "operator": null, "metadata": {"llm_response": "# Description: Cooperative Swarm with Adaptive Mutation and Neighborhood Search: Employs a swarm of particles that cooperate and explore the search space, adaptively adjusting their mutation rate and exploring their neighborhood to balance exploration and exploitation.\n# Code:\n```python\nimport numpy as np\n\nclass CooperativeSwarm:\n    def __init__(self, budget=10000, dim=10, swarm_size=20, c1=1.5, c2=1.5, w_start=0.9, w_end=0.4, mutation_rate_start=0.1, mutation_rate_end=0.01, neighborhood_size=3):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.c1 = c1\n        self.c2 = c2\n        self.w_start = w_start\n        self.w_end = w_end\n        self.mutation_rate_start = mutation_rate_start\n        self.mutation_rate_end = mutation_rate_end\n        self.neighborhood_size = neighborhood_size # Number of neighbors to consider\n\n        self.x = np.random.uniform(-5, 5, size=(swarm_size, dim))\n        self.v = np.random.uniform(-1, 1, size=(swarm_size, dim))  # Initialize velocities\n        self.pbest_x = self.x.copy()\n        self.pbest_f = np.full(swarm_size, np.inf)\n        self.gbest_x = None\n        self.gbest_f = np.inf\n\n        self.eval_count = 0\n\n    def __call__(self, func):\n        while self.eval_count < self.budget:\n            # Adaptive inertia weight\n            w = self.w_start - (self.w_start - self.w_end) * (self.eval_count / self.budget)\n            \n            # Adaptive mutation rate\n            mutation_rate = self.mutation_rate_start - (self.mutation_rate_start - self.mutation_rate_end) * (self.eval_count / self.budget)\n            \n            for i in range(self.swarm_size):\n                # Evaluate current position\n                f = func(self.x[i])\n                self.eval_count += 1\n                if self.eval_count >= self.budget:\n                    break\n\n                if f < self.pbest_f[i]:\n                    self.pbest_f[i] = f\n                    self.pbest_x[i] = self.x[i].copy()\n\n                    if f < self.gbest_f:\n                        self.gbest_f = f\n                        self.gbest_x = self.x[i].copy()\n\n                # Update velocity and position using PSO formula\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.v[i] = w * self.v[i] + self.c1 * r1 * (self.pbest_x[i] - self.x[i]) + self.c2 * r2 * (self.gbest_x - self.x[i])\n                self.x[i] = self.x[i] + self.v[i]\n\n                # Boundary Handling\n                self.x[i] = np.clip(self.x[i], -5, 5)\n\n\n                # Mutation\n                for j in range(self.dim):\n                    if np.random.rand() < mutation_rate:\n                        self.x[i, j] += np.random.normal(0, 1) * (5 - (-5)) * 0.1 # Add some noise\n                        self.x[i, j] = np.clip(self.x[i, j], -5, 5)\n\n                # Neighborhood Search\n                # Select k nearest neighbors based on Euclidean distance\n                distances = np.linalg.norm(self.x - self.x[i], axis=1)\n                neighbors_idx = np.argsort(distances)[1:self.neighborhood_size+1] # Exclude itself\n\n                # Explore the neighborhood by averaging the positions of the neighbors\n                neighbor_positions = self.x[neighbors_idx]\n                neighborhood_center = np.mean(neighbor_positions, axis=0)\n\n                # Move towards the neighborhood center with a small step\n                step_size = 0.1  # Adjust the step size as needed\n                self.x[i] = self.x[i] + step_size * (neighborhood_center - self.x[i])\n                self.x[i] = np.clip(self.x[i], -5, 5)\n\n            if self.eval_count >= self.budget:\n                break\n\n        return self.gbest_f, self.gbest_x\n```", "generation": 0, "operator": "init"}, "task_prompt": ""}
{"id": "00759f67-9cb2-4755-a7d3-d862e39e3afe", "fitness": "-inf", "name": "AdaptiveDEwithArchiveAndLevy", "description": "Adaptive Differential Evolution with Archive and Lévy Flight Mutation, incorporating memory of successful parameters and archive-based exploration with occasional Lévy flights for enhanced diversity.", "code": "import numpy as np\n\nclass AdaptiveDEwithArchiveAndLevy:\n    def __init__(self, budget=10000, dim=10, pop_factor=5, archive_size=100, levy_exponent=1.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_factor = pop_factor\n        self.pop_size = int(self.pop_factor * self.dim)\n        self.memory_size = 10\n        self.archive_size = archive_size\n        self.levy_exponent = levy_exponent\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.lb = func.bounds.lb\n        self.ub = func.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        self.memory_F = np.ones(self.memory_size) * 0.5\n        self.memory_CR = np.ones(self.memory_size) * 0.5\n        self.archive = []\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation based on memory\n                F = np.random.choice(self.memory_F)\n                CR = np.random.choice(self.memory_CR)\n\n                # Mutation (DE)\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                mutant = self.population[i] + F * (x_r2 - x_r3)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Add Levy flight mutation occasionally\n                if np.random.rand() < 0.1:\n                    levy_step = self.levy_flight(self.levy_exponent, self.dim)\n                    mutant = self.population[i] + 0.01 * levy_step * (self.ub - self.lb) # Scale levy step\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                f_trial = func(trial)\n                self.budget -= 1\n\n                if f_trial < self.fitness[i]:\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f_trial\n\n                    # Update successful parameter memory\n                    self.memory_F = np.roll(self.memory_F, 1)\n                    self.memory_F[0] = F\n\n                    self.memory_CR = np.roll(self.memory_CR, 1)\n                    self.memory_CR[0] = CR\n\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                else:\n                    # Exploration from archive\n                    if len(self.archive) > 0 and np.random.rand() < 0.05:\n                        arch_idx = np.random.randint(len(self.archive))\n                        archived_solution = self.archive[arch_idx]\n                        trial = archived_solution + 0.01 * np.random.normal(0, 1, self.dim) * (self.ub - self.lb) # Perturb archived solution\n                        trial = np.clip(trial, self.lb, self.ub)\n                        f_trial = func(trial)\n                        self.budget -= 1\n\n                        if f_trial < self.fitness[i]:\n                            self.population[i] = trial\n                            self.fitness[i] = f_trial\n                            if f_trial < self.f_opt:\n                                self.f_opt = f_trial\n                                self.x_opt = trial\n\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt\n\n    def levy_flight(self, beta, dim):\n        \"\"\"\n        Generate a Levy flight step.\n        \"\"\"\n        num = np.random.normal(0, 1, size=dim) * np.sqrt(\n            np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * (2 ** ((beta - 1) / 2))))\n        den = np.abs(np.random.normal(0, 1, size=dim)) ** (1 / beta)\n        step = num / den\n        return step", "configspace": "", "generation": 0, "feedback": "In the code, line 805, in __getattr__, the following error occurred:\nAttributeError: module 'numpy' has no attribute 'math'. Did you mean: 'emath'?", "error": "In the code, line 805, in __getattr__, the following error occurred:\nAttributeError: module 'numpy' has no attribute 'math'. Did you mean: 'emath'?", "parent_ids": [], "operator": null, "metadata": {"llm_response": "# Description: Adaptive Differential Evolution with Archive and Lévy Flight Mutation, incorporating memory of successful parameters and archive-based exploration with occasional Lévy flights for enhanced diversity.\n# Code: \n```python\nimport numpy as np\n\nclass AdaptiveDEwithArchiveAndLevy:\n    def __init__(self, budget=10000, dim=10, pop_factor=5, archive_size=100, levy_exponent=1.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_factor = pop_factor\n        self.pop_size = int(self.pop_factor * self.dim)\n        self.memory_size = 10\n        self.archive_size = archive_size\n        self.levy_exponent = levy_exponent\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.lb = func.bounds.lb\n        self.ub = func.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        self.memory_F = np.ones(self.memory_size) * 0.5\n        self.memory_CR = np.ones(self.memory_size) * 0.5\n        self.archive = []\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation based on memory\n                F = np.random.choice(self.memory_F)\n                CR = np.random.choice(self.memory_CR)\n\n                # Mutation (DE)\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                mutant = self.population[i] + F * (x_r2 - x_r3)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Add Levy flight mutation occasionally\n                if np.random.rand() < 0.1:\n                    levy_step = self.levy_flight(self.levy_exponent, self.dim)\n                    mutant = self.population[i] + 0.01 * levy_step * (self.ub - self.lb) # Scale levy step\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Selection\n                f_trial = func(trial)\n                self.budget -= 1\n\n                if f_trial < self.fitness[i]:\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f_trial\n\n                    # Update successful parameter memory\n                    self.memory_F = np.roll(self.memory_F, 1)\n                    self.memory_F[0] = F\n\n                    self.memory_CR = np.roll(self.memory_CR, 1)\n                    self.memory_CR[0] = CR\n\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                else:\n                    # Exploration from archive\n                    if len(self.archive) > 0 and np.random.rand() < 0.05:\n                        arch_idx = np.random.randint(len(self.archive))\n                        archived_solution = self.archive[arch_idx]\n                        trial = archived_solution + 0.01 * np.random.normal(0, 1, self.dim) * (self.ub - self.lb) # Perturb archived solution\n                        trial = np.clip(trial, self.lb, self.ub)\n                        f_trial = func(trial)\n                        self.budget -= 1\n\n                        if f_trial < self.fitness[i]:\n                            self.population[i] = trial\n                            self.fitness[i] = f_trial\n                            if f_trial < self.f_opt:\n                                self.f_opt = f_trial\n                                self.x_opt = trial\n\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt\n\n    def levy_flight(self, beta, dim):\n        \"\"\"\n        Generate a Levy flight step.\n        \"\"\"\n        num = np.random.normal(0, 1, size=dim) * np.sqrt(\n            np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * (2 ** ((beta - 1) / 2))))\n        den = np.abs(np.random.normal(0, 1, size=dim)) ** (1 / beta)\n        step = num / den\n        return step\n```", "operator": "crossover", "theta_sampled": -0.11373821824283364, "generation": 1}, "task_prompt": ""}
