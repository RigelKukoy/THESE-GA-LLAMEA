{"id": "bea03d72-66ef-4522-a989-4a93ecb54439", "fitness": -Infinity, "name": "CMAES", "description": "Covariance Matrix Adaptation Evolution Strategy with orthogonal sampling and budget-aware adaptation.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, ccov1=None, ccovmu=None, mueff=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) if mueff is None else mueff\n        self.cs = cs\n        self.damps = 1 + 2 * max(0, np.sqrt((self.mueff-1)/(self.dim+1)) - 1) + self.cs if damps is None else damps\n        self.ccov1 = 2 / ((self.dim + 1.3)**2 + self.mueff) if ccov1 is None else ccov1\n        self.ccovmu = 2 * (self.mueff - 2 + 1/self.mueff) / ((self.dim + 2)**2 + self.mueff) if ccovmu is None else ccovmu\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n        self.mean = None\n        self.sigma = 0.5\n        self.C = None\n        self.pc = None\n        self.ps = None\n        self.eval_count = 0\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.D = None\n        self.B = None\n        self.update_decomposition()\n        self.terminate = False\n\n    def update_decomposition(self):\n        self.D, self.B = np.linalg.eigh(self.C)\n        self.D = np.sqrt(self.D)\n\n    def sample_solution(self):\n        z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n        x = self.mean + self.sigma * (self.B @ (self.D * z))\n        return x\n\n    def __call__(self, func):\n        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        while self.eval_count < self.budget and not self.terminate:\n            x = self.sample_solution()\n            \n            f = np.array([func(x[:,i]) for i in range(self.popsize)])\n            self.eval_count += self.popsize\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_sorted = x[:, idx]\n            f_sorted = f[idx]\n\n            xmean = np.sum(x_sorted[:, :self.mu] * self.weights, axis=1)\n            y = (x_sorted[:, :self.mu] - self.mean) / self.sigma\n            \n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.B @ np.mean(y, axis=1))\n            \n            norm_ps = np.linalg.norm(self.ps)\n            \n            if (norm_ps/np.sqrt(1-(1-self.cs)**(2*(self.eval_count/self.popsize))) < (1.4 + 2/(self.dim+1)) * self.chiN):\n                hsig = 1\n            else:\n                hsig = 0\n            \n            self.pc = (1 - 1) * self.pc + hsig * np.sqrt(1 * (2 - 1) * self.mueff) * (xmean - self.mean) / self.sigma\n\n            self.mean = xmean\n\n            C1 = self.ccov1 * (self.pc[:, None] @ self.pc[None, :])\n            Cmu = self.ccovmu * (y @ np.diag(self.weights) @ y.T)\n            self.C = (1 - self.ccov1 - self.ccovmu) * self.C + C1 + Cmu\n\n            self.sigma *= np.exp((self.cs/self.damps) * (norm_ps/self.chiN - 1))\n            \n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            \n            try:\n                self.update_decomposition()\n            except np.linalg.LinAlgError:\n                self.C = np.eye(self.dim)\n                self.update_decomposition()\n\n            if np.any(self.D < 0):\n                self.terminate = True\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "2e0db784-bdaa-430c-9f0b-6b56470eaa1f", "fitness": 0.0, "name": "ADEsShrink", "description": "Adaptive Differential Evolution with shrinking population and archive.", "code": "import numpy as np\n\nclass ADEsShrink:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=None, F=0.7, Cr=0.9):\n        \"\"\"\n        Adaptive Differential Evolution with shrinking population and archive.\n\n        Args:\n            budget (int): The budget of function evaluations.\n            dim (int): The dimensionality of the problem.\n            pop_size (int, optional): The initial population size. Defaults to 10*dim if None.\n            archive_size (int, optional): The initial archive size. Defaults to 2*pop_size if None.\n            F (float): The mutation factor.\n            Cr (float): The crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.archive_size = archive_size if archive_size is not None else 2 * self.pop_size\n        self.F = F\n        self.Cr = Cr\n\n        self.population = None\n        self.fitness = None\n        self.archive = None\n\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n        self.eval_count = 0  # Keep track of function evaluations\n\n    def _initialize(self, func):\n        \"\"\"Initialize the population and archive.\"\"\"\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.eval_count += self.pop_size\n\n        self.archive = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, np.inf) # Initialize archive fitness to infinity\n\n        # Update the best solution found so far\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.population[best_index].copy()\n\n\n    def __call__(self, func):\n        \"\"\"Optimize the given function using Adaptive Differential Evolution.\"\"\"\n        self._initialize(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size + self.archive_size, 3, replace=False)\n                if indices[0] < self.pop_size:\n                    x1 = self.population[indices[0]]\n                else:\n                     x1 = self.archive[indices[0] - self.pop_size]\n\n                if indices[1] < self.pop_size:\n                    x2 = self.population[indices[1]]\n                else:\n                     x2 = self.archive[indices[1] - self.pop_size]\n                     \n                if indices[2] < self.pop_size:\n                    x3 = self.population[indices[2]]\n                else:\n                     x3 = self.archive[indices[2] - self.pop_size]\n\n\n                v = self.population[i] + self.F * (x2 - x3)  # Use current individual as x0\n\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                # Boundary Handling (clip to bounds)\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f = func(u)\n                self.eval_count += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Add replaced vector to archive\n                    self.archive = np.vstack((self.archive, self.population[i]))\n                    self.archive_fitness = np.append(self.archive_fitness, self.fitness[i])\n                    if self.archive.shape[0] > 2*self.pop_size: #Keep archive size appropriate\n                      worst_arch_ind = np.argmax(self.archive_fitness)\n                      self.archive = np.delete(self.archive, worst_arch_ind, axis=0)\n                      self.archive_fitness = np.delete(self.archive_fitness, worst_arch_ind)\n\n                    self.population[i] = u\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = u.copy()\n            \n            # Shrink the population linearly with the number of evaluations to intensify the search.\n            reduction_rate = 0.001\n            new_pop_size = int(self.pop_size * (1 - reduction_rate * (self.eval_count / self.budget)))\n            new_pop_size = max(4, new_pop_size) #Minimum pop size of 4\n            if new_pop_size < self.pop_size:\n                # Select the best individuals to keep\n                indices = np.argsort(self.fitness)[:new_pop_size]\n                self.population = self.population[indices]\n                self.fitness = self.fitness[indices]\n                self.pop_size = new_pop_size\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm ADEsShrink scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0]}}
{"id": "13b1def1-a845-4d0b-9c8d-e55d258012fa", "fitness": 0.6866645542240752, "name": "CMAES", "description": "Covariance matrix adaptation evolution strategy with adaptive step size control and restart mechanism.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, dsigma=0.2, cc=0.1, c_cov=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.dsigma = dsigma\n        self.cc = cc\n        self.c_cov = c_cov\n        self.c_cov_mu = self.c_cov\n        if self.mueff == 1:\n            self.c_cov_mu = 1\n        else:\n            self.c_cov_mu = self.c_cov_mu/self.mueff\n\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n        p_c = np.zeros(self.dim)\n\n        # Adaptation parameters (typically set based on dimension)\n        c_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        c_c = 4 / (self.dim + 4)\n        c_cov = 2 / ((self.dim + np.sqrt(2))**2 + self.mueff)\n        c_cov_mu = 2 * (self.mueff - 2 + 1/self.mueff) / ((self.dim + 2)**2 + self.mueff)\n        d_sigma = 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n\n        while self.evals < self.budget:\n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            for i in range(self.popsize):\n                X[:, i] = np.clip(X[:, i], func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(self.popsize)])\n            self.evals += self.popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :self.mu], self.weights)\n\n            # Update evolution path\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * self.mueff) * np.dot(np.linalg.inv(np.linalg.cholesky(C)), (mean - mean_old)) / sigma\n            p_c = (1- c_c) * p_c + np.sqrt(c_c * (2 - c_c) * self.mueff) * (mean - mean_old) / sigma\n\n            # Update covariance matrix\n            C = (1 - c_cov - c_cov_mu) * C + c_cov * np.outer(p_c, p_c)\n            \n            C += c_cov_mu * np.dot(np.dot(X[:, :self.mu] - mean_old[:, np.newaxis], np.diag(self.weights)), (X[:, :self.mu] - mean_old[:, np.newaxis]).T) / sigma**2\n\n            # Ensure positive definiteness\n            C = np.triu(C) + np.triu(C, 1).T\n            \n            # Update step size\n            sigma = sigma * np.exp((c_sigma / d_sigma) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n            \n            if np.any(np.diag(C) <= 0):\n                C = np.eye(self.dim)\n                sigma = 0.5\n\n            if self.evals > self.budget:\n                self.evals = self.budget\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm CMAES scored 0.687 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.2703063743933436, 0.1618401158312206, 0.9286868460821135, 0.1991929522750454, 0.9473368222405364, 0.9532852929929806, 0.3354019518497958, 0.9413840075498392, 0.9433261908703041, 0.1768471146836691, 0.9575072362940648, 0.9889194385516549, 0.819700699418098, 0.9504129720734231, 0.5871977486524249, 0.9464186385641663, 0.8870142549434292, 0.9636988811265051, 0.274056088960677, 0.5007574571282134]}}
{"id": "cef671ac-3512-483e-a6e8-3f43e268de6c", "fitness": 0.6998764326359186, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with stochastic ranking and archive for constrained exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive_size = archive_size\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for generation in range(self.budget // self.pop_size):\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                \n                # Add a random vector from the archive with a small probability\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    xa = self.archive[np.random.randint(len(self.archive))]\n                    v = x1 + self.F * (x2 - x3) + 0.01 * (xa - self.population[i])\n                else:\n                    v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)  # Ensure bounds\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        # Replace a random element in the archive\n                        self.archive[np.random.randint(self.archive_size)] = u\n                else:\n                    # Add the replaced vector into archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n            # Adapt F and CR (simple adaptation)\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n            \n        # Final check (optional - but good practice)\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.700 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.28818367930240607, 0.663555868686653, 0.6522230476735509, 0.8850931228714982, 0.7678706351522393, 0.7761684159751092, 0.6338620367199779, 0.6681621024037495, 0.750739046042975, 0.7180465448329838, 0.8454173425295405, 0.9997421396795458, 0.6354045867344771, 0.7399483945893298, 0.9131326749322428, 0.7807163009425941, 0.6444308858580011, 0.8555169353699443, 0.26468359294667065, 0.5146312994748794]}}
{"id": "80b2adea-3d58-4cec-8b7e-32fae1360216", "fitness": -Infinity, "name": "CMAES", "description": "Simplified CMA-ES with clipping, adaptive covariance update, and step-size control.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, dsigma=0.2, cc=0.1, c_cov=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.dsigma = dsigma\n        self.cc = cc\n        self.c_cov = c_cov\n        self.c_cov_mu = self.c_cov\n        if self.mueff == 1:\n            self.c_cov_mu = 1\n        else:\n            self.c_cov_mu = self.c_cov_mu/self.mueff\n\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n        p_c = np.zeros(self.dim)\n\n        # Adaptation parameters (typically set based on dimension)\n        c_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        c_c = 4 / (self.dim + 4)\n        c_cov = 2 / ((self.dim + np.sqrt(2))**2 + self.mueff)\n        c_cov_mu = 2 * (self.mueff - 2 + 1/self.mueff) / ((self.dim + 2)**2 + self.mueff)\n        d_sigma = 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n\n        while self.evals < self.budget:\n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            X = np.clip(X, func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(self.popsize)])\n            self.evals += self.popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :self.mu], self.weights)\n\n            # Update evolution paths\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * self.mueff) * np.linalg.solve(np.linalg.cholesky(C), (mean - mean_old)) / sigma\n            p_c = (1 - c_c) * p_c + np.sqrt(c_c * (2 - c_c) * self.mueff) * (mean - mean_old) / sigma\n\n            # Update covariance matrix\n            C = (1 - c_cov - c_cov_mu) * C + c_cov * np.outer(p_c, p_c) + c_cov_mu * np.dot((X[:, :self.mu] - mean_old[:, np.newaxis]) * self.weights, (X[:, :self.mu] - mean_old[:, np.newaxis]).T) / sigma**2\n\n            # Ensure positive definiteness\n            C = np.triu(C) + np.triu(C, 1).T\n            \n            # Update step size\n            sigma = sigma * np.exp((c_sigma / d_sigma) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n            \n            if np.any(np.diag(C) <= 0):\n                C = np.eye(self.dim)\n                sigma = 0.5\n\n            if self.evals > self.budget:\n                self.evals = self.budget\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,6) (2,) (2,) .", "error": "", "parent_ids": ["13b1def1-a845-4d0b-9c8d-e55d258012fa"], "operator": null, "metadata": {}}
{"id": "b295c9e0-7127-49c5-b334-1fb121d63b87", "fitness": -Infinity, "name": "CMAES", "description": "Simplified CMA-ES with a more robust covariance matrix update and handling of numerical issues.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, ccov1=None, ccovmu=None, mueff=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) if mueff is None else mueff\n        self.cs = cs\n        self.damps = 1 + 2 * max(0, np.sqrt((self.mueff-1)/(self.dim+1)) - 1) + self.cs if damps is None else damps\n        self.ccov1 = 2 / ((self.dim + 1.3)**2 + self.mueff) if ccov1 is None else ccov1\n        self.ccovmu = 2 * (self.mueff - 2 + 1/self.mueff) / ((self.dim + 2)**2 + self.mueff) if ccovmu is None else ccovmu\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n        self.mean = None\n        self.sigma = 0.5\n        self.C = None\n        self.pc = None\n        self.ps = None\n        self.eval_count = 0\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.D = None\n        self.B = None\n        self.update_decomposition()\n        self.terminate = False\n\n    def update_decomposition(self):\n        try:\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(self.D)\n        except np.linalg.LinAlgError:\n            self.C = np.eye(self.dim)\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(self.D)\n\n\n    def sample_solution(self):\n        z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n        x = self.mean + self.sigma * (self.B @ (self.D * z))\n        return x\n\n    def __call__(self, func):\n        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        while self.eval_count < self.budget and not self.terminate:\n            x = self.sample_solution()\n            \n            f = np.array([func(x[:,i]) for i in range(self.popsize)])\n            self.eval_count += self.popsize\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_sorted = x[:, idx]\n\n            xmean = np.sum(x_sorted[:, :self.mu] * self.weights, axis=1)\n            y = (x_sorted[:, :self.mu] - self.mean) / self.sigma\n            \n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.B @ np.mean(y, axis=1))\n            norm_ps = np.linalg.norm(self.ps)\n            hsig = 1 if (norm_ps/self.chiN < (1.4 + 2/(self.dim+1))) else 0\n            self.pc = (1 - self.ccov1) * self.pc + hsig * np.sqrt(self.ccov1 * (2 - self.ccov1) * self.mueff) * (xmean - self.mean) / self.sigma\n\n            self.mean = xmean\n\n            C1 = self.ccov1 * (self.pc[:, None] @ self.pc[None, :])\n            Cmu = self.ccovmu * (y @ np.diag(self.weights) @ y.T)\n            self.C = (1 - self.ccov1 - self.ccovmu) * self.C + C1 + Cmu\n\n            self.sigma *= np.exp((self.cs/self.damps) * (norm_ps/self.chiN - 1))\n            \n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            \n            # Regularize covariance matrix\n            self.C = np.diag(np.diag(self.C)) + 0.9 * (self.C - np.diag(np.diag(self.C)))\n            \n            try:\n                self.update_decomposition()\n            except np.linalg.LinAlgError:\n                self.C = np.eye(self.dim)\n                self.update_decomposition()\n\n            if np.any(self.D < 0):\n                self.terminate = True\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["bea03d72-66ef-4522-a989-4a93ecb54439"], "operator": null, "metadata": {}}
{"id": "aac8d440-a791-4f03-969b-f1ec5527d8af", "fitness": -Infinity, "name": "ADEsShrink", "description": "Adaptive Differential Evolution with a dynamically updated archive and population size reduction based on fitness improvement stagnation.", "code": "import numpy as np\n\nclass ADEsShrink:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=None, F=0.7, Cr=0.9, stagnation_threshold=1000):\n        \"\"\"\n        Adaptive Differential Evolution with shrinking population and archive, using stagnation detection.\n\n        Args:\n            budget (int): The budget of function evaluations.\n            dim (int): The dimensionality of the problem.\n            pop_size (int, optional): The initial population size. Defaults to 10*dim if None.\n            archive_size (int, optional): The initial archive size. Defaults to 2*pop_size if None.\n            F (float): The mutation factor.\n            Cr (float): The crossover rate.\n            stagnation_threshold (int): Number of evaluations without improvement before shrinking the population.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.archive_size = archive_size if archive_size is not None else 2 * self.pop_size\n        self.F = F\n        self.Cr = Cr\n        self.stagnation_threshold = stagnation_threshold\n\n        self.population = None\n        self.fitness = None\n        self.archive = None\n        self.archive_fitness = None\n\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.stagnation_counter = 0\n\n    def _initialize(self, func):\n        \"\"\"Initialize the population and archive.\"\"\"\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.eval_count += self.pop_size\n\n        self.archive = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, np.inf)\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n        self.best_eval = self.eval_count  # Evaluation count when best solution was found\n\n    def __call__(self, func):\n        \"\"\"Optimize the given function using Adaptive Differential Evolution.\"\"\"\n        self._initialize(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + self.archive_size, 3, replace=False)\n                xa, xb, xc = self.population[idxs[:min(3, np.sum(idxs<self.pop_size))]] if np.sum(idxs<self.pop_size) > 0 else self.archive[idxs[:min(3, np.sum(idxs<self.pop_size))]-self.pop_size] , self.population[idxs[1:min(3, np.sum(idxs<self.pop_size)+1)]] if np.sum(idxs<self.pop_size) > 1 else self.archive[idxs[1:min(3, np.sum(idxs<self.pop_size)+1)]-self.pop_size] , self.population[idxs[2:min(3, np.sum(idxs<self.pop_size)+2)]] if np.sum(idxs<self.pop_size) > 2 else self.archive[idxs[2:min(3, np.sum(idxs<self.pop_size)+2)]-self.pop_size]\n                v = self.population[i] + self.F * (xb - xc)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.Cr, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f = func(u)\n                self.eval_count += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Add replaced vector to archive\n                    self.archive = np.vstack((self.archive, self.population[i]))\n                    self.archive_fitness = np.append(self.archive_fitness, self.fitness[i])\n                    if self.archive.shape[0] > self.archive_size:\n                        worst_arch_ind = np.argmax(self.archive_fitness)\n                        self.archive = np.delete(self.archive, worst_arch_ind, axis=0)\n                        self.archive_fitness = np.delete(self.archive_fitness, worst_arch_ind)\n\n                    self.population[i] = u\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = u.copy()\n                        self.best_eval = self.eval_count\n                        self.stagnation_counter = 0 #Reset stagnation counter\n                else:\n                  self.stagnation_counter +=1\n\n            # Shrink population if stagnant\n            if self.eval_count - self.best_eval > self.stagnation_threshold and self.pop_size > 4:\n                new_pop_size = max(4, int(self.pop_size * 0.8))\n                indices = np.argsort(self.fitness)[:new_pop_size]\n                self.population = self.population[indices]\n                self.fitness = self.fitness[indices]\n                self.pop_size = new_pop_size\n                self.stagnation_threshold = int(self.stagnation_threshold * 1.1) #Increase stagnation threshold for each shrink\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: index 48 is out of bounds for axis 0 with size 20.", "error": "", "parent_ids": ["2e0db784-bdaa-430c-9f0b-6b56470eaa1f"], "operator": null, "metadata": {}}
{"id": "2eb7e89b-10f5-44a7-b83a-8f3862773cc5", "fitness": 0.7102816218110274, "name": "CMAES", "description": "Simplified CMA-ES with rank-one covariance update and clipping to maintain positive definiteness.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, dsigma=0.2, cc=0.1, c_cov=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.dsigma = dsigma\n        self.cc = cc\n        self.c_cov = c_cov\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n        p_c = np.zeros(self.dim)\n\n        # Adaptation parameters (typically set based on dimension)\n        c_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        c_c = 4 / (self.dim + 4)\n        c_cov = 2 / ((self.dim + np.sqrt(2))**2 + self.mueff)\n        d_sigma = 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n\n        while self.evals < self.budget:\n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            for i in range(self.popsize):\n                X[:, i] = np.clip(X[:, i], func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(self.popsize)])\n            self.evals += self.popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :self.mu], self.weights)\n\n            # Update evolution paths\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * self.mueff) * np.linalg.solve(np.linalg.cholesky(C), (mean - mean_old)) / sigma\n            p_c = (1 - c_c) * p_c + np.sqrt(c_c * (2 - c_c) * self.mueff) * (mean - mean_old) / sigma\n\n            # Update covariance matrix (rank-one update)\n            C = (1 - c_cov) * C + c_cov * np.outer(p_c, p_c)\n\n            # Update step size\n            sigma = sigma * np.exp((c_sigma / d_sigma) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n\n            # Keep C positive definite\n            if np.any(np.diag(C) <= 0):\n                C = np.eye(self.dim)\n                sigma = 0.5\n\n            if self.evals > self.budget:\n                self.evals = self.budget\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm CMAES scored 0.710 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["13b1def1-a845-4d0b-9c8d-e55d258012fa"], "operator": null, "metadata": {"aucs": [0.2591977858099028, 0.2337375015579225, 0.9402281639035278, 0.973138960781327, 0.9450010534648009, 0.9541925773781523, 0.3429586262256409, 0.9236589037381953, 0.937711961319313, 0.18168474884816288, 0.9635053220038746, 0.9951532230496124, 0.7107665396088879, 0.9493007953460877, 0.9670648293805851, 0.8640871619884896, 0.4613080955448705, 0.9639691917621898, 0.15077664253980005, 0.4881903519692059]}}
{"id": "bf286945-fbcd-4ee2-bfc0-44309a0441cd", "fitness": 0.3579888024925317, "name": "CMAES", "description": "CMA-ES with robust covariance matrix handling and simplified update rules to prevent errors.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, ccov1=None, ccovmu=None, mueff=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) if mueff is None else mueff\n        self.cs = cs\n        self.damps = 1 + 2 * max(0, np.sqrt((self.mueff-1)/(self.dim+1)) - 1) + self.cs if damps is None else damps\n        self.ccov1 = 2 / ((self.dim + 1.3)**2 + self.mueff) if ccov1 is None else ccov1\n        self.ccovmu = 2 * (self.mueff - 2 + 1/self.mueff) / ((self.dim + 2)**2 + self.mueff) if ccovmu is None else ccovmu\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n        self.mean = None\n        self.sigma = 0.5\n        self.C = None\n        self.pc = None\n        self.ps = None\n        self.eval_count = 0\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.D = None\n        self.B = None\n        self.update_decomposition()\n        self.terminate = False\n\n    def update_decomposition(self):\n        try:\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(self.D)\n        except np.linalg.LinAlgError:\n            self.C = np.eye(self.dim)  # Reset covariance matrix\n            self.D = np.ones(self.dim)  # Reset eigenvalues\n            self.B = np.eye(self.dim)   # Reset eigenvectors\n\n\n    def sample_solution(self):\n        z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n        x = self.mean[:, None] + self.sigma * (self.B @ (self.D[:, None] * z))\n        return x\n\n    def __call__(self, func):\n        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        while self.eval_count < self.budget and not self.terminate:\n            x = self.sample_solution()\n            \n            f = np.array([func(x[:,i]) for i in range(self.popsize)])\n            self.eval_count += self.popsize\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_sorted = x[:, idx]\n            f_sorted = f[idx]\n\n            xmean = np.sum(x_sorted[:, :self.mu] * self.weights, axis=1)\n            y = (x_sorted[:, :self.mu] - self.mean[:, None]) / self.sigma\n            \n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.B @ np.mean(y, axis=1))\n            \n            norm_ps = np.linalg.norm(self.ps)\n            \n            if (norm_ps/np.sqrt(1-(1-self.cs)**(2*(self.eval_count/self.popsize))) < (1.4 + 2/(self.dim+1)) * self.chiN):\n                hsig = 1\n            else:\n                hsig = 0\n            \n            self.pc = (1 - self.ccov1) * self.pc + hsig * np.sqrt(self.ccov1 * (2 - self.ccov1) * self.mueff) * (xmean - self.mean) / self.sigma\n\n            self.mean = xmean\n\n            C1 = self.ccov1 * (self.pc[:, None] @ self.pc[None, :])\n            Cmu = self.ccovmu * (y @ np.diag(self.weights) @ y.T)\n            self.C = (1 - self.ccov1 - self.ccovmu) * self.C + C1 + Cmu\n\n            self.sigma *= np.exp((self.cs/self.damps) * (norm_ps/self.chiN - 1))\n            \n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            \n            # Robust handling of near-singular covariance matrix\n            try:\n                self.update_decomposition()\n            except np.linalg.LinAlgError:\n                self.C = np.eye(self.dim)\n                self.update_decomposition()\n\n            if np.any(self.D < 0):\n                self.terminate = True\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm CMAES scored 0.358 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["bea03d72-66ef-4522-a989-4a93ecb54439"], "operator": null, "metadata": {"aucs": [0.14548437035131756, 0.19212896454769568, 0.29922595765613325, 0.7908994264835818, 0.25572216852485596, 0.518315388183175, 0.2934395216901846, 0.30942812491858007, 0.17108875199208995, 0.13378412271855455, 0.4190738862840918, 1.0, 0.2863400487148665, 0.27447825652967606, 0.6299740316364169, 0.29902230396373497, 0.24616661475562673, 0.2831048029649029, 0.14066082575138172, 0.4714384821837684]}}
{"id": "0f0ab10c-a9d1-4ee4-83b5-54b5744497bf", "fitness": 0.33765628625406346, "name": "CMAES", "description": "CMA-ES with simplified rank-one update and eigenvalue clipping for robustness.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, ccov1=None, ccovmu=None, mueff=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) if mueff is None else mueff\n        self.cs = cs\n        self.damps = 1 + 2 * max(0, np.sqrt((self.mueff-1)/(self.dim+1)) - 1) + self.cs if damps is None else damps\n        self.ccov1 = 2 / ((self.dim + 1.3)**2 + self.mueff) if ccov1 is None else ccov1\n        self.ccovmu = 2 * (self.mueff - 2 + 1/self.mueff) / ((self.dim + 2)**2 + self.mueff) if ccovmu is None else ccovmu\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n        self.mean = None\n        self.sigma = 0.5\n        self.C = None\n        self.pc = None\n        self.ps = None\n        self.eval_count = 0\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.D = None\n        self.B = None\n        self.update_decomposition()\n        self.terminate = False\n\n    def update_decomposition(self):\n        try:\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(self.D)\n            # Clip eigenvalues to avoid negative values\n            self.D = np.clip(self.D, 1e-10, None)\n        except np.linalg.LinAlgError:\n            self.C = np.eye(self.dim)\n            self.D = np.ones(self.dim)\n            self.B = np.eye(self.dim)\n\n    def sample_solution(self):\n        z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n        x = self.mean[:, None] + self.sigma * (self.B @ (self.D[:, None] * z))\n        return x\n\n    def __call__(self, func):\n        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        while self.eval_count < self.budget and not self.terminate:\n            x = self.sample_solution()\n            f = np.array([func(x[:,i]) for i in range(self.popsize)])\n            self.eval_count += self.popsize\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_sorted = x[:, idx]\n\n            xmean = np.sum(x_sorted[:, :self.mu] * self.weights, axis=1)\n            y = (x_sorted[:, :self.mu] - self.mean[:, None]) / self.sigma\n            \n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.B @ np.mean(y, axis=1))\n            norm_ps = np.linalg.norm(self.ps)\n            hsig = 1 if (norm_ps/self.chiN < (1.4 + 2/(self.dim+1))) else 0\n            self.pc = (1 - 1) * self.pc + hsig * np.sqrt(1 * (2 - 1) * self.mueff) * (xmean - self.mean) / self.sigma\n            self.mean = xmean\n\n            C1 = self.ccov1 * (self.pc[:, None] @ self.pc[None, :])\n            self.C = (1 - self.ccov1 - self.ccovmu) * self.C + C1\n            self.sigma *= np.exp((self.cs/self.damps) * (norm_ps/self.chiN - 1))\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            self.update_decomposition()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm CMAES scored 0.338 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["bea03d72-66ef-4522-a989-4a93ecb54439"], "operator": null, "metadata": {"aucs": [0.10061472520597203, 0.40555812728995666, 0.40028625394264794, 0.2290424896319535, 0.22558099332683346, 0.1742635345514998, 0.27054511763693856, 0.2744529849504823, 0.17239429750223423, 0.12730873067436366, 0.15555793135162244, 0.9862678027529689, 0.32140722521092113, 0.33583721398865474, 0.6344414175880215, 0.43002102361125494, 0.24178471856507378, 0.9766374881388667, 0.14621741295390023, 0.1449062362071023]}}
{"id": "d6baa81e-5416-4bcc-b382-fd224c2ffa8c", "fitness": 0.6981142743375375, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive F/CR and archive, focusing on efficiency and reduced complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    elif np.random.rand() < 0.1:\n                        self.archive[np.random.randint(self.archive_size)] = u #Replace randomly with probability\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.698 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cef671ac-3512-483e-a6e8-3f43e268de6c"], "operator": null, "metadata": {"aucs": [0.35547163362801404, 0.6477822934558611, 0.680152523283722, 0.8597735742527672, 0.7484051110406875, 0.8160149611984893, 0.6252087702425164, 0.6508651857777144, 0.7358314916333082, 0.6837370913416506, 0.8626872051304509, 0.9994987034709396, 0.6411118124135936, 0.7173744569669491, 0.9101772189323879, 0.779818238093708, 0.5986161602714453, 0.8437968836861884, 0.24870391154909444, 0.5572582603812604]}}
{"id": "1ff606f9-685d-4e2e-b3fd-d9542c23a8b8", "fitness": 0.7165270913355926, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and a smaller archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u\n\n            # Adaptation of F and CR\n            self.F = 0.5 + 0.3 * np.random.randn()\n            self.CR = np.random.rand()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.717 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cef671ac-3512-483e-a6e8-3f43e268de6c"], "operator": null, "metadata": {"aucs": [0.3100424814268121, 0.6358731314242941, 0.6986889334414776, 0.8762759647916156, 0.7993186758740373, 0.8280097669807243, 0.7543337565212461, 0.6643392001180746, 0.8189688965150608, 0.6786338891192867, 0.8570087435010056, 0.9956723453327487, 0.3472777477530098, 0.7997074197306725, 0.9194955055448513, 0.8620165900513163, 0.689278619907759, 0.869871385235378, 0.3993942699487507, 0.5263345034937315]}}
{"id": "203187e0-bb8b-4d77-8570-a263cdb56c1f", "fitness": 0.6959503347141756, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive parameters and archive, focusing on reducing complexity and improving exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5  # Initialize F\n        self.CR = 0.9 # Initialize CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for generation in range(self.budget // self.pop_size):\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u\n                #else: # Removed adding old vector to archive\n\n            # Adapt F and CR\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n\n        # Final check\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.696 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cef671ac-3512-483e-a6e8-3f43e268de6c"], "operator": null, "metadata": {"aucs": [0.3319481881712104, 0.7190308355825608, 0.7018054570159957, 0.8548098610631539, 0.7373130637760935, 0.7898011119451915, 0.6220252699589821, 0.6693903715517681, 0.7443248605232119, 0.6495140749742002, 0.8463885103777513, 0.9980137428694785, 0.6864884254597612, 0.716996046747316, 0.8963867794328553, 0.7846845354837264, 0.5660197614721092, 0.8305473632714688, 0.24493474622905897, 0.5285836883776156]}}
{"id": "bad1d008-cc91-4df6-b343-4d377d112f1e", "fitness": 0.7000448979780243, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive F and CR, archive, and stochastic ranking, focusing on fewer parameters and cleaner updates.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        F = 0.5\n        CR = 0.9\n\n        for generation in range(self.budget // self.pop_size):\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)  # Ensure bounds\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy()) #store the replaced vector\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i].copy() #store the replaced vector\n\n                else:\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy()) #store the replaced vector\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i].copy() #store the replaced vector\n\n\n\n            # Adapt F and CR (simple adaptation)\n            F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n            CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n            \n        # Final check (optional - but good practice)\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.700 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cef671ac-3512-483e-a6e8-3f43e268de6c"], "operator": null, "metadata": {"aucs": [0.3060033383675983, 0.6829829133420247, 0.7150965935439234, 0.8581173032312464, 0.7500894286901503, 0.7857011483515224, 0.6046581238647255, 0.6503190833632428, 0.7608765885401189, 0.6958446653174506, 0.852441441046378, 0.9968310264465712, 0.6715843465685785, 0.728261890351876, 0.9120721250881676, 0.7688871271573329, 0.5793381625365261, 0.8265562198519585, 0.32924399684534145, 0.5259924370557512]}}
{"id": "a38cf861-b166-4d31-9d2f-e854ace48a9c", "fitness": -Infinity, "name": "CMAES", "description": "Simplified CMA-ES with vectorized operations and clipping of covariance matrix to improve robustness.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, dsigma=0.2, cc=0.1, c_cov=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.dsigma = dsigma\n        self.cc = cc\n        self.c_cov = c_cov\n        self.c_cov_mu = self.c_cov\n        if self.mueff == 1:\n            self.c_cov_mu = 1\n        else:\n            self.c_cov_mu = self.c_cov_mu/self.mueff\n\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n        p_c = np.zeros(self.dim)\n\n        # Adaptation parameters (typically set based on dimension)\n        c_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        c_c = 4 / (self.dim + 4)\n        c_cov = 2 / ((self.dim + np.sqrt(2))**2 + self.mueff)\n        c_cov_mu = 2 * (self.mueff - 2 + 1/self.mueff) / ((self.dim + 2)**2 + self.mueff)\n        d_sigma = 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n\n        while self.evals < self.budget:\n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            X = np.clip(X, func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(self.popsize)])\n            self.evals += self.popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :self.mu], self.weights)\n\n            # Update evolution path\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * self.mueff) * np.linalg.solve(C, (mean - mean_old)) / sigma\n            p_c = (1- c_c) * p_c + np.sqrt(c_c * (2 - c_c) * self.mueff) * (mean - mean_old) / sigma\n\n            # Update covariance matrix\n            C = (1 - c_cov - c_cov_mu) * C + c_cov * np.outer(p_c, p_c) + c_cov_mu * (X[:, :self.mu] - mean_old[:, np.newaxis]) @ np.diag(self.weights) @ (X[:, :self.mu] - mean_old[:, np.newaxis]).T / sigma**2\n\n            # Ensure positive definiteness\n            C = np.clip(C, 1e-10, None)\n            C = np.triu(C) + np.triu(C, 1).T\n            \n            # Update step size\n            sigma = sigma * np.exp((c_sigma / d_sigma) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n            \n            if np.any(np.diag(C) <= 0):\n                C = np.eye(self.dim)\n                sigma = 0.5\n\n            if self.evals > self.budget:\n                self.evals = self.budget\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,6) (2,) (2,) .", "error": "", "parent_ids": ["13b1def1-a845-4d0b-9c8d-e55d258012fa"], "operator": null, "metadata": {}}
{"id": "3e8fc695-1d27-4a7d-9c8b-cf340cbcc43d", "fitness": 0.0, "name": "ADEsShrink", "description": "Adaptive Differential Evolution with shrinking population and archive, employing a more aggressive shrinking strategy and improved archive management.", "code": "import numpy as np\n\nclass ADEsShrink:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=None, F=0.7, Cr=0.9, shrink_rate=0.1):\n        \"\"\"\n        Adaptive Differential Evolution with shrinking population and archive.\n\n        Args:\n            budget (int): The budget of function evaluations.\n            dim (int): The dimensionality of the problem.\n            pop_size (int, optional): The initial population size. Defaults to 10*dim if None.\n            archive_size (int, optional): The initial archive size. Defaults to 2*pop_size if None.\n            F (float): The mutation factor.\n            Cr (float): The crossover rate.\n            shrink_rate (float): Rate at which the population shrinks (between 0 and 1).\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.archive_size = archive_size if archive_size is not None else 2 * self.pop_size\n        self.F = F\n        self.Cr = Cr\n        self.shrink_rate = shrink_rate\n\n        self.population = None\n        self.fitness = None\n        self.archive = None\n        self.archive_fitness = None\n\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n        self.eval_count = 0  # Keep track of function evaluations\n\n    def _initialize(self, func):\n        \"\"\"Initialize the population and archive.\"\"\"\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.eval_count += self.pop_size\n\n        self.archive = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, np.inf) # Initialize archive fitness to infinity\n\n        # Update the best solution found so far\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.population[best_index].copy()\n\n    def __call__(self, func):\n        \"\"\"Optimize the given function using Adaptive Differential Evolution.\"\"\"\n        self._initialize(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size + self.archive_size, 3, replace=False)\n                \n                pool = np.vstack((self.population, self.archive))\n                x1, x2, x3 = pool[indices[:3]]\n\n                v = self.population[i] + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.Cr, v, self.population[i])\n\n                # Boundary Handling (clip to bounds)\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f = func(u)\n                self.eval_count += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Add replaced vector to archive\n                    self.archive = np.vstack((self.archive, self.population[i]))\n                    self.archive_fitness = np.append(self.archive_fitness, self.fitness[i])\n\n                    self.population[i] = u\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = u.copy()\n\n            # Archive management: Keep archive size appropriate.  Prioritize better fitness.\n            if self.archive.shape[0] > self.archive_size:\n                indices_to_remove = np.argsort(self.archive_fitness)[self.archive_size:]\n                self.archive = np.delete(self.archive, indices_to_remove, axis=0)\n                self.archive_fitness = np.delete(self.archive_fitness, indices_to_remove)\n            \n\n            # Shrink the population linearly with the number of evaluations to intensify the search.\n            new_pop_size = int(self.pop_size * (1 - self.shrink_rate * (self.eval_count / self.budget)))\n            new_pop_size = max(4, new_pop_size) #Minimum pop size of 4\n            if new_pop_size < self.pop_size:\n                # Select the best individuals to keep\n                indices = np.argsort(self.fitness)[:new_pop_size]\n                self.population = self.population[indices]\n                self.fitness = self.fitness[indices]\n                self.pop_size = new_pop_size\n                #Resize archive as well\n                self.archive_size = 2 * self.pop_size\n                if self.archive.shape[0] > self.archive_size:\n                    indices_to_remove = np.argsort(self.archive_fitness)[self.archive_size:]\n                    self.archive = np.delete(self.archive, indices_to_remove, axis=0)\n                    self.archive_fitness = np.delete(self.archive_fitness, indices_to_remove)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm ADEsShrink scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2e0db784-bdaa-430c-9f0b-6b56470eaa1f"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "ec8e2219-1bab-4b95-9987-18fcdc330da9", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and optional archive usage for diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=0):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        if self.archive_size > 0:\n            self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x)] * self.pop_size)\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                    # Archive update\n                    if self.archive_size > 0:\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(u)\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = u\n\n            # Adaptation of F and CR - Simplified\n            self.F = 0.5 + 0.1 * np.random.randn()\n            self.CR = 0.9 + 0.1 * np.random.randn()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "An exception occurred: name 'x' is not defined.", "error": "", "parent_ids": ["1ff606f9-685d-4e2e-b3fd-d9542c23a8b8"], "operator": null, "metadata": {}}
{"id": "3bf9faef-46a6-47f5-afea-3f0e9ffcd68c", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, selective archive usage, and a focus on exploitation through smaller populations.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=15, archive_size=5, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x1, x2 = self.population[idxs]\n                if self.archive:\n                    x3 = self.archive[np.random.randint(len(self.archive))]\n                    v = x1 + self.F * (x2 - x3)\n                else:\n                     v = x1 + self.F * (x2 - self.population[i]) #Exploitation if archive is empty\n\n                # Crossover\n                mask = np.random.rand(self.dim) < self.CR\n                u = np.where(mask, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Archive update (simplified)\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    elif f_u < np.max(self.fitness):\n                        self.archive[np.argmax(self.fitness)] = u  # Replace worst individual in archive\n\n            # Adaptation (simplified)\n            self.F = 0.5 + 0.2 * np.random.normal()\n            self.CR = 0.9 + 0.1 * np.random.normal()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "An exception occurred: list assignment index out of range.", "error": "", "parent_ids": ["1ff606f9-685d-4e2e-b3fd-d9542c23a8b8"], "operator": null, "metadata": {}}
{"id": "9325e937-79b3-4701-9a35-ddf24718196f", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a focused archive update strategy and reduced parameter adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                    # Archive update: Only add if better than worst in archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        worst_idx = np.argmax([func(x) for x in self.archive])\n                        if f_u < func(self.archive[worst_idx]):\n                            self.archive[worst_idx] = u\n\n            # Adaptation of F and CR - Simplified Adaptation\n            self.F = np.clip(0.5 + 0.1 * np.random.randn(), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1ff606f9-685d-4e2e-b3fd-d9542c23a8b8"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "fffb5c24-dc4e-4486-85a4-23f1f94a2592", "fitness": 0.0, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, reduced population size and a concentrated archive update strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Concentrated Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                         #Replace the worst element\n                        worst_index = np.argmax(np.array([func(x) for x in self.archive])) #find worst in archive\n                        self.archive[worst_index] = u\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - simplified adaptation\n            success = self.fitness < np.mean(self.fitness)\n            if np.any(success):\n                self.F = np.clip(np.mean(np.random.normal(0.5, 0.1, np.sum(success))), 0.1, 1.0)\n                self.CR = np.clip(np.mean(np.random.normal(0.9, 0.1, np.sum(success))), 0.1, 1.0)\n            else:\n                self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6baa81e-5416-4bcc-b382-fd224c2ffa8c"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "2d475240-e0eb-4b0f-bbde-f3a41887374c", "fitness": 0.0, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a combined archive-population mutation strategy for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        # Initialization\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        self.f_opt = np.min(self.fitness)\n        self.archive = list(self.population)\n\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: Combined population and archive\n                candidates = list(range(self.pop_size))\n                candidates.remove(i)\n                if len(self.archive) > 3:\n                  use_archive = np.random.rand() < 0.5\n                else:\n                  use_archive = False\n                if use_archive:\n                  xa = np.random.choice(len(self.archive), 2, replace=False)\n                  x1 = self.archive[xa[0]]\n                  x2 = self.archive[xa[1]]\n                  idxs = np.random.choice(self.pop_size, 1, replace=False)\n                  x3 = self.population[idxs[0]]\n\n\n                  v = self.population[i] + self.F * (x1 - x2 + x3 - self.population[i]) # Current to rand\n\n                else:\n                    idxs = np.random.choice(candidates, 3, replace=False)\n                    x1, x2, x3 = self.population[idxs]\n\n                    v = self.population[i] + self.F * (x1 - x2 + x3 - self.population[i])  # Current to rand\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n\n                    # Update archive: replace worst in archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        fitnesses = [func(x) for x in self.archive]\n                        worst_index = np.argmax(fitnesses)\n                        self.archive[worst_index] = u  # Replace worst\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR: Simplified adaptation\n            self.F = 0.5 + 0.3 * np.random.randn()\n            self.CR = 0.9 + 0.1 * np.random.randn()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6baa81e-5416-4bcc-b382-fd224c2ffa8c"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "d0daf72c-1f48-4109-8f15-d29f9b1ea83f", "fitness": 0.765518680385921, "name": "CMAES", "description": "Simplified CMA-ES with rank-one covariance update and dynamic population size based on remaining budget.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, cs=0.3, dsigma=0.2, cc=0.1, c_cov=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.cs = cs\n        self.dsigma = dsigma\n        self.cc = cc\n        self.c_cov = c_cov\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n        p_c = np.zeros(self.dim)\n\n\n        while self.evals < self.budget:\n            #Dynamic Popsize\n            remaining_budget = self.budget - self.evals\n            popsize = min(remaining_budget, 4 + int(3 * np.log(self.dim)))\n            mu = popsize // 2\n            weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n            weights = weights / np.sum(weights)\n            mueff = np.sum(weights)**2 / np.sum(weights**2)\n            \n            # Adaptation parameters (typically set based on dimension)\n            c_sigma = (mueff + 2) / (self.dim + mueff + 5)\n            c_c = 4 / (self.dim + 4)\n            c_cov = 2 / ((self.dim + np.sqrt(2))**2 + mueff)\n            d_sigma = 1 + 2 * max(0, np.sqrt((mueff - 1)/(self.dim + 1)) - 1) + self.cs\n            \n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            for i in range(popsize):\n                X[:, i] = np.clip(X[:, i], func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(popsize)])\n            self.evals += popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :mu], weights)\n\n            # Update evolution paths\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * mueff) * np.linalg.solve(np.linalg.cholesky(C), (mean - mean_old)) / sigma\n            p_c = (1 - c_c) * p_c + np.sqrt(c_c * (2 - c_c) * mueff) * (mean - mean_old) / sigma\n\n            # Update covariance matrix (rank-one update)\n            C = (1 - c_cov) * C + c_cov * np.outer(p_c, p_c)\n\n            # Update step size\n            sigma = sigma * np.exp((c_sigma / d_sigma) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n\n            # Keep C positive definite\n            if np.any(np.diag(C) <= 0):\n                C = np.eye(self.dim)\n                sigma = 0.5\n\n            if self.evals > self.budget:\n                self.evals = self.budget\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm CMAES scored 0.766 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2eb7e89b-10f5-44a7-b83a-8f3862773cc5"], "operator": null, "metadata": {"aucs": [0.23526051653378866, 0.9371721359779343, 0.9332514417130375, 0.9524836589391525, 0.9467379657055384, 0.9560599262420764, 0.3357532192270374, 0.9383906915375279, 0.9420914488651975, 0.18747608140328564, 0.9587334202723635, 0.9898587751373374, 0.7692748318539036, 0.9406204922568709, 0.9478421596708255, 0.8427314160811502, 0.9087597486073048, 0.9643373874414514, 0.14394901552813977, 0.4795892747244981]}}
{"id": "8a71ef9d-f350-4dcd-a595-aa92b3dfa486", "fitness": 0.5624653895930427, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced archive interaction for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation\n            self.F = np.clip(np.random.normal(self.F, 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.562 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6baa81e-5416-4bcc-b382-fd224c2ffa8c"], "operator": null, "metadata": {"aucs": [0.17330121006970345, 0.35825616909726865, 0.4587016543497924, 0.6540149133698658, 0.5208278862835247, 0.7346164139604624, 0.6025675507783765, 0.4406326990209022, 0.6962524843621967, 0.5773332011370309, 0.7455808356955369, 0.9921742171463337, 0.40867813624985205, 0.45952864589597353, 0.6996954078756025, 0.6962940426849463, 0.4882809377263193, 0.7628445734003129, 0.2811095391885552, 0.49861727356829644]}}
{"id": "c4c2a9f4-494e-4e1d-ad27-55dc67f5d43f", "fitness": 0.7022738842138261, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a repair mechanism to enhance boundary constraint handling.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: If out of bounds, reflect back into the search space\n                lb = func.bounds.lb\n                ub = func.bounds.ub\n                u = np.clip(u, lb, ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    elif np.random.rand() < 0.1:\n                        self.archive[np.random.randint(self.archive_size)] = u #Replace randomly with probability\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR with a simpler update rule\n            self.F = 0.5 + 0.3 * np.random.randn()\n            self.CR = 0.9 + 0.1 * np.random.randn()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.702 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6baa81e-5416-4bcc-b382-fd224c2ffa8c"], "operator": null, "metadata": {"aucs": [0.3981076212261727, 0.6681969209946469, 0.6441090521875086, 0.8533362396269063, 0.7414073705726352, 0.7951868921432937, 0.6654622274181616, 0.6659189979881225, 0.757237165099578, 0.7178200271045145, 0.8560757853629013, 0.9850108308348938, 0.620737705869894, 0.7631447681541444, 0.9037477404136158, 0.7579564007848743, 0.6692778883135277, 0.8363232993966631, 0.22322205143327145, 0.5231986993511983]}}
{"id": "1ef3d651-62b8-4fb8-a82e-015220a950a6", "fitness": 0.5730393117404743, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and jitter-based mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.rng = np.random.default_rng()\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = self.rng.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation with jitter\n                idxs = self.rng.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                jitter = self.rng.uniform(-0.01, 0.01, size=self.dim)  # Small random perturbation\n                v = x1 + self.F * (x2 - x3) + jitter\n\n                # Crossover\n                u = np.where(self.rng.random(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Archive update: Simplified, always replace oldest\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        self.archive[i % self.archive_size] = u \n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR: Simplified adaptation\n            self.F = np.clip(0.5 * (1 + self.rng.normal(0, 0.1)), 0.1, 1.0)  # Bias towards 0.5\n            self.CR = np.clip(0.9 * (1 + self.rng.normal(0, 0.1)), 0.1, 1.0)  # Bias towards 0.9\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.573 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6baa81e-5416-4bcc-b382-fd224c2ffa8c"], "operator": null, "metadata": {"aucs": [0.2846698200320926, 0.5212630884976897, 0.5161840802648572, 0.8647583247347654, 0.545697128343283, 0.6008838763279063, 0.4044319014958714, 0.46416402715208527, 0.5285119812770944, 0.44466179250088655, 0.8625929691997135, 0.998157155058766, 0.40458175905966287, 0.5204074035269928, 0.902352996144892, 0.6114325660387439, 0.46043643672827195, 0.7132565964536453, 0.295920011364854, 0.5164223206074112]}}
{"id": "a0e5906a-2421-4d53-9ecf-efca5aafe3a1", "fitness": 0.7248189132344705, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified F/CR adaptation, archive utilization in mutation, and stochastic ranking for efficient exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for generation in range(self.budget // self.pop_size):\n            for i in range(self.pop_size):\n                # Mutation using archive\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x1, x2 = self.population[idxs]\n\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    xa = self.archive[np.random.randint(len(self.archive))]\n                    v = x1 + self.F * (x2 - xa)\n                else:\n                    x3 = self.population[np.random.randint(self.pop_size)]\n                    v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)  # Ensure bounds\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n\n                elif len(self.archive) < self.archive_size:\n                    self.archive.append(self.population[i].copy())\n                else:\n                    self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n\n\n            # Adapt F and CR (simplified)\n            self.F = 0.5 + 0.3 * np.random.randn()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = 0.9 + 0.1 * np.random.randn()\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n\n        # Final check (optional - but good practice)\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.725 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["bad1d008-cc91-4df6-b343-4d377d112f1e"], "operator": null, "metadata": {"aucs": [0.32557562955799435, 0.7287436758366439, 0.6497090009273492, 0.8787626893861386, 0.7614851111305305, 0.785181614398281, 0.62715604217732, 0.6980753763686361, 0.7751137163186617, 0.7515968401882815, 0.8575724264255801, 0.9927000847523272, 0.7110800045576957, 0.7261868718201997, 0.8601592208457927, 0.7624583180537489, 0.6502999974498915, 0.8567911843308502, 0.5663941375222983, 0.5313363226411862]}}
{"id": "e6965859-326d-4340-be08-1818dd2145d1", "fitness": 0.55758505221, "name": "CMAES", "description": "Simplified CMA-ES with fewer parameters and adaptive covariance clipping for stability and performance.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, cc=0.1, c_cov=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.cc = cc\n        self.c_cov = c_cov\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n        p_c = np.zeros(self.dim)\n\n        # Adaptation parameters (typically set based on dimension)\n        c_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        c_c = 4 / (self.dim + 4)\n\n        while self.evals < self.budget:\n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            for i in range(self.popsize):\n                X[:, i] = np.clip(X[:, i], func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(self.popsize)])\n            self.evals += self.popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :self.mu], self.weights)\n\n            # Update evolution paths\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * self.mueff) * np.linalg.solve(np.linalg.cholesky(C), (mean - mean_old)) / sigma\n            p_c = (1 - c_c) * p_c + np.sqrt(c_c * (2 - c_c) * self.mueff) * (mean - mean_old) / sigma\n\n            # Update covariance matrix (rank-one update)\n            C = (1 - self.c_cov) * C + self.c_cov * np.outer(p_c, p_c)\n\n            # Update step size\n            sigma = sigma * np.exp((c_sigma / self.cs) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n\n            # Keep C positive definite, adaptive clipping\n            min_eig = np.min(np.linalg.eigvalsh(C))\n            if min_eig <= 0:\n                C = C + (abs(min_eig) + 1e-10) * np.eye(self.dim)\n\n\n            if self.evals > self.budget:\n                self.evals = self.budget\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm CMAES scored 0.558 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2eb7e89b-10f5-44a7-b83a-8f3862773cc5"], "operator": null, "metadata": {"aucs": [0.21497934645163363, 0.21642817262806224, 0.7951938732858265, 0.9373123974805715, 0.27345938092910127, 0.9698315489842123, 0.3801746065259096, 0.4153079178386674, 0.3097053522698744, 0.09400101341038358, 0.7148025660303929, 0.9958318589133772, 0.580498932543441, 0.9139253519817991, 0.5822718568728329, 0.7405797687997993, 0.39452002538593667, 0.9638944181361163, 0.16900051256485882, 0.48998214316720445]}}
{"id": "82435b34-353e-4ba5-b70a-d0a8486b7197", "fitness": 0.6033510849395662, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and archive handling, focusing on exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.F_memory = [0.5] * 10\n        self.CR_memory = [0.9] * 10\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x1 = self.population[idxs[0]]\n                else:\n                    x1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x2 = self.population[idxs[1]]\n                else:\n                    x2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x3 = self.population[idxs[2]]\n                else:\n                    x3 = self.archive[idxs[2] - self.pop_size]    \n                \n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    delta = self.fitness[i] - f_u\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = self.population[i].copy()\n\n                    #Adapt F and CR\n                    self.F_memory.pop(0)\n                    self.F_memory.append(self.F)\n                    self.CR_memory.pop(0)\n                    self.CR_memory.append(self.CR)\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            self.F = np.clip(np.random.normal(np.mean(self.F_memory), 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(np.mean(self.CR_memory), 0.1), 0.1, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.603 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6baa81e-5416-4bcc-b382-fd224c2ffa8c"], "operator": null, "metadata": {"aucs": [0.2165305671604124, 0.4698104936277211, 0.5338669346473133, 0.7249123352213533, 0.4938449472128319, 0.7381510648778429, 0.6753703648754793, 0.4905256168749179, 0.74437985889736, 0.6418779580375091, 0.7819935644840298, 0.9844305197414828, 0.5266569882045102, 0.6360069855591218, 0.8469229807932843, 0.7683603848921179, 0.5176604579911785, 0.5602519349006925, 0.20952762067626818, 0.5059401201158982]}}
{"id": "0c778849-791d-4369-ac2e-a5bba04d5659", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and improved boundary handling for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Boundary Handling: Reflecting boundaries\n                lb = func.bounds.lb\n                ub = func.bounds.ub\n                for j in range(self.dim):\n                    if u[j] < lb:\n                        u[j] = lb + (lb - u[j])  # Reflect\n                    elif u[j] > ub:\n                        u[j] = ub - (u[j] - ub)  # Reflect\n                u = np.clip(u, lb, ub)\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - simplified\n            success = self.fitness < np.mean(self.fitness) # Successful individuals\n            if np.any(success):\n                self.F = 0.5 * (1 + np.random.randn())\n                self.CR = 0.8 + 0.2 * np.random.randn()\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "An exception occurred: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all().", "error": "", "parent_ids": ["c4c2a9f4-494e-4e1d-ad27-55dc67f5d43f"], "operator": null, "metadata": {}}
{"id": "bf14d79e-b7a8-49eb-91c0-88d3194600f0", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with clipped mutation and probabilistic archive update for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x)] * self.pop_size)\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n                \n                # Clip mutation vector to bounds\n                lb = func.bounds.lb\n                ub = func.bounds.ub\n                v = np.clip(v, lb, ub)\n\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Probabilistic Archive Update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    elif np.random.rand() < 0.1:\n                        self.archive[np.random.randint(self.archive_size)] = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adaptation of F and CR\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "An exception occurred: name 'x' is not defined.", "error": "", "parent_ids": ["c4c2a9f4-494e-4e1d-ad27-55dc67f5d43f"], "operator": null, "metadata": {}}
{"id": "9d8e1027-a838-4149-bd25-808a7293c8f2", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive population size, archive, and parameter control, focusing on balancing exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_factor = pop_factor\n        self.pop_size = min(budget // 2, dim * self.pop_factor)\n        self.archive_size = self.pop_size  # Archive size proportional to pop size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation - using archive more frequently\n                if len(self.archive) > 0 and np.random.rand() < 0.3:\n                    xa = self.archive[np.random.randint(len(self.archive))]\n                else:\n                    xa = self.population[np.random.randint(self.pop_size)]\n                    \n                x1, x2 = self.population[np.random.choice(self.pop_size, 2, replace=False)]\n                \n                v = self.population[i] + self.F * (x1 - x2)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive - only store improvements\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        if f_u < np.max([func(x) for x in self.archive]):\n                            idx_to_replace = np.argmax([func(x) for x in self.archive])\n                            self.archive[idx_to_replace] = u.copy() #replace the worst individual\n                if self.budget <= 0:\n                    break\n\n            # Adaptive F and CR - simplified adaptation\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["82435b34-353e-4ba5-b70a-d0a8486b7197"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "8274e0a2-3719-4ae2-a96b-802b6c7748c4", "fitness": -Infinity, "name": "CMAES", "description": "Simplified CMA-ES with rank-one covariance update, dynamic population size, and clipping of evolution path to enhance exploration.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n        p_c = np.zeros(self.dim)\n\n        while evals < self.budget:\n            # Dynamic Popsize\n            remaining_budget = self.budget - evals\n            popsize = min(remaining_budget, 4 + int(3 * np.log(self.dim)))\n            mu = popsize // 2\n            weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n            weights = weights / np.sum(weights)\n            mueff = np.sum(weights)**2 / np.sum(weights**2)\n            \n            c_sigma = (mueff + 2) / (self.dim + mueff + 5)\n            c_c = 4 / (self.dim + 4)\n            c_cov = 2 / ((self.dim + np.sqrt(2))**2 + mueff)\n            d_sigma = 1 + 2 * max(0, np.sqrt((mueff - 1)/(self.dim + 1)) - 1)\n            \n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            X = np.clip(X, func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(popsize)])\n            evals += popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :mu], weights)\n\n            # Update evolution paths, clip p_sigma\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * mueff) * np.linalg.solve(np.linalg.cholesky(C), (mean - mean_old)) / sigma\n            p_sigma = np.clip(p_sigma, -5, 5)  # Clip p_sigma\n            p_c = (1 - c_c) * p_c + np.sqrt(c_c * (2 - c_c) * mueff) * (mean - mean_old) / sigma\n\n            # Update covariance matrix (rank-one update)\n            C = (1 - c_cov) * C + c_cov * np.outer(p_c, p_c)\n\n            # Update step size\n            sigma = sigma * np.exp((c_sigma / d_sigma) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n\n            # Keep C positive definite\n            if np.any(np.diag(C) <= 0):\n                C = np.eye(self.dim)\n                sigma = 0.5\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,6) (2,) (2,) .", "error": "", "parent_ids": ["d0daf72c-1f48-4109-8f15-d29f9b1ea83f"], "operator": null, "metadata": {}}
{"id": "59d3dc6c-b331-4aed-8182-fca82a9bb208", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and improved archive handling for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, memory_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.F_memory = [0.5] * self.memory_size\n        self.CR_memory = [0.9] * self.memory_size\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                x1 = self.population[idxs[0] % self.pop_size] if idxs[0] < self.pop_size else self.archive[idxs[0] - self.pop_size]\n                x2 = self.population[idxs[1] % self.pop_size] if idxs[1] < self.pop_size else self.archive[idxs[1] - self.pop_size]\n                x3 = self.population[idxs[2] % self.pop_size] if idxs[2] < self.pop_size else self.archive[idxs[2] - self.pop_size]\n                \n                v = x1 + self.F * (x2 - x3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub) # simpler repair\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive: Replace worst with current if better than worst in archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        worst_idx = np.argmax([func(x) for x in self.archive]) #find worst in archive\n                        worst_arch_fitness = func(self.archive[worst_idx])\n                        if f_u < worst_arch_fitness:\n                            self.archive[worst_idx] = u.copy()\n                            \n                    # Adapt F and CR using success history\n                    self.F_memory.pop(0)\n                    self.F_memory.append(self.F)\n                    self.CR_memory.pop(0)\n                    self.CR_memory.append(self.CR)\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR based on memory\n            self.F = np.clip(np.random.normal(np.mean(self.F_memory), 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(np.mean(self.CR_memory), 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["82435b34-353e-4ba5-b70a-d0a8486b7197"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "2f7ef1cd-c538-406c-b1c6-ee7b50bd94a3", "fitness": 0.7016849587062476, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and a focus on efficient constraint handling and population diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            self.F = 0.5 + 0.3 * np.random.normal(0, 1)\n            self.CR = 0.9 + 0.1 * np.random.normal(0, 1)\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.702 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c4c2a9f4-494e-4e1d-ad27-55dc67f5d43f"], "operator": null, "metadata": {"aucs": [0.2990202168960322, 0.7387421774185374, 0.6354246972468073, 0.8871920192407092, 0.7440298046419894, 0.784234539440302, 0.6621726795843693, 0.6641948911582922, 0.7314677558992411, 0.673079946020101, 0.8629652417591931, 0.9845368416701316, 0.631938616660797, 0.7601312878324452, 0.8779599572761307, 0.7776527649159599, 0.6321767209899353, 0.8501193826062449, 0.3094922816561251, 0.5271673512116083]}}
{"id": "aaf566ba-96de-4e20-991d-100fb92a3931", "fitness": 0.5250273496054496, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with improved constraint handling and parameter adaptation based on population fitness.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        \n        if np.min(self.fitness) < self.f_opt:\n            self.f_opt = np.min(self.fitness)\n            self.x_opt = self.population[np.argmin(self.fitness)]\n\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, lb, ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n            \n            #Adaptation of F and CR based on population fitness\n            fitness_values = self.fitness\n            fitness_mean = np.mean(fitness_values)\n            \n            #Adaptive F\n            if fitness_mean !=0:\n                self.F = 0.5 * (1+ np.std(fitness_values)/fitness_mean) #Scale the value of F based on fitness diversity.\n                self.F = np.clip(self.F, 0.1, 1.0)\n                \n            #Adaptive CR\n            if np.std(fitness_values) > 0.01: #Change CR only when there is sufficient diversity\n                 self.CR = 0.7 + 0.2 * np.random.randn() #Slightly change CR adaptively.\n                 self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.525 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c4c2a9f4-494e-4e1d-ad27-55dc67f5d43f"], "operator": null, "metadata": {"aucs": [0.1858393560090138, 0.26851030613877036, 0.5084731178458562, 0.744860906748891, 0.4817311731059083, 0.6398092725400374, 0.42469302286225763, 0.4956894210732463, 0.5498770792760387, 0.45526251740157675, 0.6797170637151293, 0.9988605886485296, 0.3072292325939905, 0.4901700468514619, 0.771454511965661, 0.6585329882121165, 0.4380272474553908, 0.7060663497887196, 0.19435875931343793, 0.5013840305629578]}}
{"id": "9dd6ba67-8911-4e6f-a84d-fd6953f68072", "fitness": 0.6970648770034981, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and a dynamically sized archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size/2)  # Dynamic archive size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x1 = self.population[idxs[0]]\n                else:\n                    x1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x2 = self.population[idxs[1]]\n                else:\n                    x2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x3 = self.population[idxs[2]]\n                else:\n                    x3 = self.archive[idxs[2] - self.pop_size]    \n                \n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = u.copy()\n\n            # Adapt F and CR (Self-adaptive)\n            good_indices = np.where(self.fitness < np.mean(self.fitness))[0]\n            if len(good_indices) > 0:\n                self.F = np.mean(np.random.normal(0.5, 0.3, len(good_indices)))\n                self.CR = np.mean(np.random.normal(0.9, 0.1, len(good_indices)))\n                self.F = np.clip(self.F, 0.1, 1.0)\n                self.CR = np.clip(self.CR, 0.1, 1.0)\n                \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.697 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["82435b34-353e-4ba5-b70a-d0a8486b7197"], "operator": null, "metadata": {"aucs": [0.34971521932983796, 0.6693953909733197, 0.6439316051136212, 0.8823832533514941, 0.7445154781013414, 0.7857490759628544, 0.5783268480481485, 0.6346325751960615, 0.7151411918502748, 0.6609275917518255, 0.8591951002274352, 0.9973314342018683, 0.6203942286784427, 0.7382034450977808, 0.904227044384954, 0.7797286346399548, 0.6066628534584002, 0.8134438492350013, 0.4351137128636472, 0.5222790076036956]}}
{"id": "efcc8335-83fd-40fe-81df-83e5ffcaadf3", "fitness": 0.6664003665563943, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a self-adaptive strategy based on successful mutations and a smaller archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x1 = self.population[idxs[0]]\n                else:\n                    x1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x2 = self.population[idxs[1]]\n                else:\n                    x2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x3 = self.population[idxs[2]]\n                else:\n                    x3 = self.archive[idxs[2] - self.pop_size]    \n                \n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    delta = self.fitness[i] - f_u\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = self.population[i].copy()\n                    \n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            if self.success_F:\n                self.F = np.clip(np.random.normal(np.mean(self.success_F), 0.1), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(np.mean(self.success_CR), 0.1), 0.1, 1.0)\n                self.success_F = []\n                self.success_CR = []\n            else:\n                 self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                 self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.666 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["82435b34-353e-4ba5-b70a-d0a8486b7197"], "operator": null, "metadata": {"aucs": [0.2916822264870702, 0.691687727847903, 0.4911602685670097, 0.9112260547038319, 0.8262859676769025, 0.8543326756327463, 0.6427886047620164, 0.6711937725536183, 0.6104863058772743, 0.6440399788293074, 0.41004131109168285, 0.9994156762099294, 0.6552978026481784, 0.7425765084488827, 0.8488221203882416, 0.8212490493370095, 0.5000484574734454, 0.8992020017626583, 0.2992694613806468, 0.517201359449533]}}
{"id": "d360b951-f69c-410c-88e5-ec439f855c70", "fitness": 0.780243226211197, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, archive utilization, and a focus on population diversity by adjusting mutation strategy and utilizing best solution information.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        for generation in range(self.budget // self.pop_size):\n            for i in range(self.pop_size):\n                # Mutation: Use best solution more often\n                if np.random.rand() < 0.3:\n                    # Mutation using best solution and archive\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    x1, x2 = self.population[idxs]\n                    \n                    if len(self.archive) > 0 and np.random.rand() < 0.5:\n                        xa = self.archive[np.random.randint(len(self.archive))]\n                        v = self.x_opt + self.F * (x1 - x2) #Using best\n                    else:\n                        v = self.x_opt + self.F * (x1 - x2)  # Using best\n                else:\n                    # Standard mutation\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x1, x2, x3 = self.population[idxs]\n                    v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                        #Update best index\n                        best_idx = np.argmin(self.fitness)\n                        self.f_opt = self.fitness[best_idx]\n                        self.x_opt = self.population[best_idx]\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n\n                elif len(self.archive) < self.archive_size:\n                    self.archive.append(self.population[i].copy())\n                else:\n                    self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n\n\n            # Adapt F and CR (simplified) - try different ranges\n            self.F = 0.5 + 0.2 * np.random.randn()\n            self.F = np.clip(self.F, 0.2, 0.8)\n            self.CR = 0.9 + 0.05 * np.random.randn()\n            self.CR = np.clip(self.CR, 0.5, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.780 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a0e5906a-2421-4d53-9ecf-efca5aafe3a1"], "operator": null, "metadata": {"aucs": [0.47432164848739655, 0.23561143035298293, 0.839613219801199, 0.946085480739711, 0.8786364485592464, 0.9077672668390603, 0.8495653405782384, 0.8182211221222888, 0.8620905880068515, 0.8546884630290152, 0.953900869747751, 0.9939104138876015, 0.8229153240614103, 0.8318567759135258, 0.9423145119538802, 0.8937699377154663, 0.8099137188250813, 0.9298088436490587, 0.23948187450861402, 0.5203912454455601]}}
{"id": "0aef56f4-ed7f-4787-bef6-1e6e82ae9924", "fitness": 0.6472974441917497, "name": "CMAES", "description": "Simplified CMA-ES with rank-one covariance update and dynamic population size, further simplified adaptation parameters and covariance update.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Initialize variables\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        sigma = 0.5  # Step size\n        C = np.eye(self.dim)  # Covariance matrix\n        p_sigma = np.zeros(self.dim)\n\n        while self.evals < self.budget:\n            #Dynamic Popsize\n            remaining_budget = self.budget - self.evals\n            popsize = min(remaining_budget, 4 + int(3 * np.log(self.dim)))\n            mu = popsize // 2\n            weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n            weights = weights / np.sum(weights)\n            mueff = np.sum(weights)**2 / np.sum(weights**2)\n            \n            # Adaptation parameters (typically set based on dimension)\n            c_sigma = (mueff + 2) / (self.dim + mueff + 5)\n            c_cov = 2 / ((self.dim + np.sqrt(2))**2 + mueff)\n            d_sigma = 1 + 2 * max(0, np.sqrt((mueff - 1)/(self.dim + 1)) - 1) \n            \n            # Sample population\n            Z = np.random.normal(0, 1, size=(self.dim, popsize))\n            X = mean[:, np.newaxis] + sigma * np.dot(np.linalg.cholesky(C), Z)\n            \n            # Clip to bounds\n            for i in range(popsize):\n                X[:, i] = np.clip(X[:, i], func.bounds.lb, func.bounds.ub)\n\n            # Evaluate population\n            F = np.array([func(X[:, i]) for i in range(popsize)])\n            self.evals += popsize\n\n            # Sort by fitness\n            idx = np.argsort(F)\n            X = X[:, idx]\n            F = F[idx]\n\n            # Update optimal solution\n            if F[0] < self.f_opt:\n                self.f_opt = F[0]\n                self.x_opt = X[:, 0].copy()\n\n            # Update mean\n            mean_old = mean.copy()\n            mean = np.dot(X[:, :mu], weights)\n\n            # Update evolution path\n            p_sigma = (1 - c_sigma) * p_sigma + np.sqrt(c_sigma * (2 - c_sigma) * mueff) * np.linalg.solve(np.linalg.cholesky(C), (mean - mean_old)) / sigma\n\n            # Update covariance matrix (rank-one update)\n            C = (1 - c_cov) * C + c_cov * np.outer(p_sigma, p_sigma)\n\n            # Update step size\n            sigma = sigma * np.exp((c_sigma / d_sigma) * (np.linalg.norm(p_sigma) / self.chiN - 1))\n\n            # Keep C positive definite\n            if np.any(np.diag(C) <= 0):\n                C = np.eye(self.dim)\n                sigma = 0.5\n\n            if self.evals > self.budget:\n                self.evals = self.budget\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm CMAES scored 0.647 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d0daf72c-1f48-4109-8f15-d29f9b1ea83f"], "operator": null, "metadata": {"aucs": [0.23266055098393934, 0.14905895882952358, 0.9482095495206921, 0.16893053275261904, 0.9520174016778101, 0.9582473737542035, 0.3408226083134487, 0.9326219316738876, 0.9488501565845879, 0.19445701867005583, 0.9665748904720336, 0.9891783401373737, 0.24968677872424883, 0.9545156828459651, 0.9491772968042472, 0.9210312052919103, 0.4384696135859296, 0.9647406745669558, 0.16743601216836235, 0.5192623064771995]}}
{"id": "b2fa83d3-16b9-4f24-a266-2b0db910ba59", "fitness": 0.7202430616669699, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive F/CR and archive based mutation, combined with a stochastic local search.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, local_search_prob=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.local_search_prob = local_search_prob\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        self.F_history = []\n        self.CR_history = []\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                if len(self.archive) > 0 and np.random.rand() < 0.5:\n                    #Use archive\n                    x_archive = self.archive[np.random.randint(len(self.archive))]\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    x1, x2 = self.population[idxs]\n                    v = x_archive + self.F * (x1 - x2)\n                else:\n                    #Original mutation\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x1, x2, x3 = self.population[idxs]\n                    v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                lb = func.bounds.lb\n                ub = func.bounds.ub\n                u = np.clip(u, lb, ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u #Replace randomly\n\n                #Local Search\n                elif np.random.rand() < self.local_search_prob:\n                    u_ls = u + 0.05*np.random.randn(self.dim) #Stochastic local search\n                    u_ls = np.clip(u_ls, lb, ub)\n                    f_u_ls = func(u_ls)\n                    self.budget -= 1\n                    if f_u_ls < self.fitness[i]:\n                        self.population[i] = u_ls\n                        self.fitness[i] = f_u_ls\n                        if f_u_ls < self.f_opt:\n                            self.f_opt = f_u_ls\n                            self.x_opt = u_ls\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            success_idxs = self.fitness < np.mean(self.fitness)  # Indices of successful individuals\n            if np.sum(success_idxs) > 0:\n                 self.F = 0.5 + 0.3 * np.random.randn()\n                 self.CR = 0.9 + 0.1 * np.random.randn()\n                 self.F = np.clip(self.F, 0.1, 1.0)\n                 self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.720 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c4c2a9f4-494e-4e1d-ad27-55dc67f5d43f"], "operator": null, "metadata": {"aucs": [0.45332708735476235, 0.7338436406471172, 0.7147344955062431, 0.8655250954344158, 0.7894003889558612, 0.8159765407059105, 0.6746563305240955, 0.6842934312809478, 0.7409227958105762, 0.7180094297056007, 0.8583986409955606, 0.9817992827909601, 0.5463319286595467, 0.7728423097434461, 0.8786125704108699, 0.7898498715307893, 0.6629156642426468, 0.8502847591584822, 0.3699275673282624, 0.503209402553303]}}
{"id": "1615d85f-485d-456f-a81b-8b2e5fb579ca", "fitness": 0.0, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with dynamic F/CR adaptation, archive, and a focused local search using a shrinking radius around the best solution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, local_search_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.local_search_prob = local_search_prob #Probability of performing local search\n\n        self.F = 0.5\n        self.CR = 0.9\n        self.search_radius = 0.1  # Initial search radius for local search\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        for generation in range(self.budget // self.pop_size):\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Local Search\n                if np.random.rand() < self.local_search_prob:\n                    u_local = self.x_opt + np.random.uniform(-self.search_radius, self.search_radius, size=self.dim)\n                    u_local = np.clip(u_local, func.bounds.lb, func.bounds.ub)\n                    f_local = func(u_local)\n                    self.budget -= 1\n\n                    if f_local < func(u):\n                        u = u_local  # Replace u with the locally searched point if it's better\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n                elif len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                else:\n                    self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n\n            # Adapt F and CR\n            self.F = 0.5 + 0.2 * np.random.randn()\n            self.F = np.clip(self.F, 0.2, 0.8)\n            self.CR = 0.9 + 0.05 * np.random.randn()\n            self.CR = np.clip(self.CR, 0.5, 1.0)\n\n            # Shrink search radius\n            self.search_radius *= 0.99\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d360b951-f69c-410c-88e5-ec439f855c70"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "d5d0aa6d-4598-4b47-a8b8-54054b957077", "fitness": 0.46885565077694497, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and self-adaptive parameters, focusing on exploration via larger F and CR variations early on, and reduced local search.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, local_search_prob=0.02):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.local_search_prob = local_search_prob\n        self.F_history = []\n        self.CR_history = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                if len(self.archive) > 0 and np.random.rand() < 0.5:\n                    # Use archive\n                    x_archive = self.archive[np.random.randint(len(self.archive))]\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    x1, x2 = self.population[idxs]\n                    v = x_archive + self.F * (x1 - x2)\n                else:\n                    # Original mutation\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x1, x2, x3 = self.population[idxs]\n                    v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                lb = func.bounds.lb\n                ub = func.bounds.ub\n                u = np.clip(u, lb, ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u  # Replace randomly\n\n                # Local Search (reduced probability)\n                elif np.random.rand() < self.local_search_prob:\n                    u_ls = u + 0.05 * np.random.randn(self.dim)  # Stochastic local search\n                    u_ls = np.clip(u_ls, lb, ub)\n                    f_u_ls = func(u_ls)\n                    self.budget -= 1\n                    if f_u_ls < self.fitness[i]:\n                        self.population[i] = u_ls\n                        self.fitness[i] = f_u_ls\n                        if f_u_ls < self.f_opt:\n                            self.f_opt = f_u_ls\n                            self.x_opt = u_ls\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR (larger variation early)\n            self.F = 0.5 + 0.5 * np.random.randn()\n            self.CR = 0.9 + 0.2 * np.random.randn()\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.469 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b2fa83d3-16b9-4f24-a266-2b0db910ba59"], "operator": null, "metadata": {"aucs": [0.481841995280755, 0.7351562964483278, 0.6293213119750869, 0.19711038345511278, 0.7697039175023874, 0]}}
{"id": "622ba5b5-3ef2-44e0-ac4a-8d88813af472", "fitness": 0.7039464279473504, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, archive and parameter adaptation, focusing on computational efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size/2)\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Adapt F and CR (Self-adaptive)\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n                \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.704 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9dd6ba67-8911-4e6f-a84d-fd6953f68072"], "operator": null, "metadata": {"aucs": [0.33446197782846454, 0.6520562059462955, 0.7303593967016644, 0.8707723848883093, 0.7398986573950772, 0.7859962799004223, 0.6611399635196559, 0.6343792445034198, 0.7457174624443057, 0.6816102695018447, 0.8681738880646553, 0.9997423002820861, 0.672992775165731, 0.709551897202171, 0.9034198492050003, 0.7694152257629315, 0.683525641520498, 0.8257164128519068, 0.31173291840191464, 0.49826580786065267]}}
{"id": "166e128d-ac30-479c-9c40-70e76ef30583", "fitness": 0.702295733222975, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and self-adaptive parameters, removing unnecessary complexity and focusing on efficient exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size/2)\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x1 = self.population[idxs[0]]\n                else:\n                    x1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x2 = self.population[idxs[1]]\n                else:\n                    x2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x3 = self.population[idxs[2]]\n                else:\n                    x3 = self.archive[idxs[2] - self.pop_size]    \n                \n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = u.copy()\n\n            # Adapt F and CR (Self-adaptive - simplified)\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.702 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9dd6ba67-8911-4e6f-a84d-fd6953f68072"], "operator": null, "metadata": {"aucs": [0.37120595736442097, 0.7254988619809986, 0.662309541260486, 0.8509909774518404, 0.7381217011874935, 0.800722576813538, 0.6443526970593905, 0.653272715907496, 0.7447005937454727, 0.6896019693503954, 0.8307117253509859, 0.9991621355419069, 0.6338506662768533, 0.7386442074504032, 0.9254991577337119, 0.7896919855155692, 0.6430061225334984, 0.8331703169407876, 0.24563799754883886, 0.5257627574454149]}}
{"id": "d319aec8-9b37-4b5c-9d99-5b19d9f1ff2a", "fitness": 0.6989115403427564, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and self-adaptive F/CR, focusing on reducing parameter tuning overhead and computational complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size/2)  # Dynamic archive size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x1 = self.population[idxs[0]]\n                else:\n                    x1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x2 = self.population[idxs[1]]\n                else:\n                    x2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x3 = self.population[idxs[2]]\n                else:\n                    x3 = self.archive[idxs[2] - self.pop_size]    \n                \n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = u.copy()\n\n            # Adapt F and CR (Self-adaptive) - Simplified adaptation\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n                \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.699 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9dd6ba67-8911-4e6f-a84d-fd6953f68072"], "operator": null, "metadata": {"aucs": [0.3290664184583745, 0.6365990267961792, 0.636139333154372, 0.8528487377280844, 0.7490274243928946, 0.7769575057044523, 0.6436958529682393, 0.6396550484049878, 0.7308562176341917, 0.707635564607646, 0.8675797536271292, 0.9970457229243328, 0.6625644129902182, 0.6997503464317625, 0.9195292717122119, 0.7400052931295811, 0.6134811407510885, 0.8255648007178742, 0.32225169355869454, 0.6279772411628126]}}
{"id": "d63f191b-33b2-4c90-8644-8da5c19bb3a6", "fitness": 0.7187401041963859, "name": "AdaptiveDE", "description": "Improved Adaptive Differential Evolution with simplified parameter adaptation and enhanced exploration through dynamic F and CR adjustments.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                mask = np.random.rand(self.dim) < self.CR\n                u = np.where(mask, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            success_indices = self.fitness < np.mean(self.fitness)\n            if np.any(success_indices):\n                self.F = 0.5 + 0.3 * np.random.normal(0, 1)\n                self.CR = 0.9 + 0.1 * np.random.normal(0, 1)\n                self.F = np.clip(self.F, 0.1, 1.0)\n                self.CR = np.clip(self.CR, 0.1, 1.0)\n            else:\n                self.F = np.random.uniform(0.5, 0.8) # Increased exploration\n                self.CR = np.random.uniform(0.6, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.719 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2f7ef1cd-c538-406c-b1c6-ee7b50bd94a3"], "operator": null, "metadata": {"aucs": [0.38224627656667987, 0.7668863052869238, 0.6255037721305061, 0.8304916466268223, 0.7428527519941421, 0.7958701373811308, 0.6705321285874823, 0.6812481354496149, 0.7473292740967405, 0.6601103596990381, 0.8363543046080497, 0.9971997290282597, 0.6787927132420022, 0.7235938655516636, 0.9187109879492974, 0.7950072580062363, 0.6209168370138369, 0.8508958954405234, 0.4405877519980671, 0.6096719532707011]}}
{"id": "25afa3b9-01a1-4c21-a925-ad9a5ad5a6fd", "fitness": 0.6874033876898211, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive F/CR and dynamic population size adjustment based on stagnation detection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, stagnation_tolerance=500):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size/2)\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.stagnation_tolerance = stagnation_tolerance\n        self.stagnation_counter = 0\n        self.best_fitness_history = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x1 = self.population[idxs[0]]\n                else:\n                    x1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x2 = self.population[idxs[1]]\n                else:\n                    x2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x3 = self.population[idxs[2]]\n                else:\n                    x3 = self.archive[idxs[2] - self.pop_size]    \n                \n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        self.stagnation_counter = 0 # Reset stagnation counter\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = u.copy()\n\n            # Adapt F and CR (Self-adaptive)\n            good_indices = np.where(self.fitness < np.mean(self.fitness))[0]\n            if len(good_indices) > 0:\n                self.F = np.mean(np.random.normal(0.5, 0.3, len(good_indices)))\n                self.CR = np.mean(np.random.normal(0.9, 0.1, len(good_indices)))\n                self.F = np.clip(self.F, 0.1, 1.0)\n                self.CR = np.clip(self.CR, 1e-6, 1.0) #Ensure CR is not zero.\n            \n            #Stagnation Check and Population Size Adjustment\n            self.best_fitness_history.append(self.f_opt)\n            if len(self.best_fitness_history) > self.stagnation_tolerance:\n                self.best_fitness_history.pop(0)\n                if np.std(self.best_fitness_history) < 1e-8:  #Stagnation detected\n                    self.stagnation_counter +=1\n                    if self.stagnation_counter > self.stagnation_tolerance/5:\n                        #Increase population size to add diversity.\n                        self.pop_size = min(100, int(self.pop_size * 1.2))\n                        self.archive_size = int(self.pop_size/2)\n\n                        new_population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size - len(self.population), self.dim))\n                        new_fitness = np.array([func(x) for x in new_population])\n                        self.budget -= (self.pop_size - len(self.population))\n\n                        self.population = np.concatenate((self.population, new_population))\n                        self.fitness = np.concatenate((self.fitness, new_fitness))\n\n                        self.stagnation_counter = 0 #reset counter\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.687 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9dd6ba67-8911-4e6f-a84d-fd6953f68072"], "operator": null, "metadata": {"aucs": [0.31007098481242745, 0.6787898476864227, 0.6498636993369021, 0.8675130296098905, 0.7316965388231127, 0.7674004764668502, 0.6440850910218159, 0.6423418338579683, 0.7271749019476212, 0.6805753960849894, 0.8430699156863756, 0.9901752704180529, 0.6220936037343572, 0.7441773362088769, 0.9068485715570377, 0.772554755473666, 0.5809125529644956, 0.8242914079145819, 0.24005289268353958, 0.5243796475074383]}}
{"id": "e94cd89a-e0f0-4cc6-8bac-cacf281c6b71", "fitness": 0.706637661146652, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with dynamic F/CR adaptation based on population fitness improvements and reduced archive interaction for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        for generation in range(self.budget // self.pop_size):\n            \n            successful_mutations_F = []\n            successful_mutations_CR = []\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    \n                    successful_mutations_F.append(self.F)\n                    successful_mutations_CR.append(self.CR)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        best_idx = np.argmin(self.fitness)\n\n            # Adapt F and CR (simplified) - based on successful mutations\n            if successful_mutations_F:\n                self.F = np.mean(successful_mutations_F)\n            else:\n                self.F = 0.5 + 0.2 * np.random.randn()\n            self.F = np.clip(self.F, 0.2, 0.8)\n\n            if successful_mutations_CR:\n                self.CR = np.mean(successful_mutations_CR)\n            else:\n                self.CR = 0.9 + 0.05 * np.random.randn()\n            self.CR = np.clip(self.CR, 0.5, 1.0)\n                \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.707 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d360b951-f69c-410c-88e5-ec439f855c70"], "operator": null, "metadata": {"aucs": [0.26504901191358055, 0.7107954614519086, 0.6900370333186768, 0.8762858542721914, 0.7475974264475866, 0.7850538496803667, 0.6117611316112133, 0.6708592073759929, 0.7729847691336984, 0.6856017856895933, 0.8693919021909609, 0.9907015335311787, 0.667119156686717, 0.7567548405612924, 0.902498385141168, 0.8039280111854475, 0.6005803193818504, 0.8380172293595607, 0.31912070197002473, 0.5686156120300304]}}
{"id": "e599b19d-48c9-4f04-8f47-7aaeee1ad960", "fitness": 0.6584793227138297, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, optional random restarts, and focus on constraint handling.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, restart_prob=0.01):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.restart_prob = restart_prob\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            self.F = 0.5 + 0.3 * np.random.normal(0, 1)\n            self.CR = 0.9 + 0.1 * np.random.normal(0, 1)\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n            # Optional Restart\n            if np.random.rand() < self.restart_prob:\n                self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.population])\n                self.budget -= self.pop_size # Account for new evaluations\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.658 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2f7ef1cd-c538-406c-b1c6-ee7b50bd94a3"], "operator": null, "metadata": {"aucs": [0.2641893736307255, 0.662370827770436, 0.5172210144845016, 0.8665979400022413, 0.6632473664721263, 0.8045191644348981, 0.6231329354829405, 0.6855844975023058, 0.7479199212437151, 0.46014723098216737, 0.825064764021858, 0.9847106137341518, 0.45958760369292484, 0.7219843744879253, 0.9156742975180353, 0.6670497296580105, 0.6602898163771245, 0.8552489917411205, 0.27336514309238324, 0.5116808479470007]}}
{"id": "b19a1781-fd57-405d-923b-1f992a72f9dd", "fitness": 0.6756744992976047, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive F/CR, archive-based mutation, and a reduced local search probability for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, local_search_prob=0.01):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.local_search_prob = local_search_prob\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                if len(self.archive) > 0 and np.random.rand() < 0.5:\n                    #Use archive\n                    x_archive = self.archive[np.random.randint(len(self.archive))]\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    x1, x2 = self.population[idxs]\n                    v = x_archive + self.F * (x1 - x2)\n                else:\n                    #Original mutation\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x1, x2, x3 = self.population[idxs]\n                    v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                lb = func.bounds.lb\n                ub = func.bounds.ub\n                u = np.clip(u, lb, ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u #Replace randomly\n\n                #Local Search\n                elif np.random.rand() < self.local_search_prob:\n                    u_ls = u + 0.05*np.random.randn(self.dim) #Stochastic local search\n                    u_ls = np.clip(u_ls, lb, ub)\n                    f_u_ls = func(u_ls)\n                    self.budget -= 1\n                    if f_u_ls < self.fitness[i]:\n                        self.population[i] = u_ls\n                        self.fitness[i] = f_u_ls\n                        if f_u_ls < self.f_opt:\n                            self.f_opt = f_u_ls\n                            self.x_opt = u_ls\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR\n            if np.random.rand() < 0.1: #Adapt more seldom\n                self.F = 0.5 + 0.3 * np.random.randn()\n                self.CR = 0.9 + 0.1 * np.random.randn()\n                self.F = np.clip(self.F, 0.1, 1.0)\n                self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.676 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b2fa83d3-16b9-4f24-a266-2b0db910ba59"], "operator": null, "metadata": {"aucs": [0.27355762979150355, 0.5378113394849847, 0.6113366402215414, 0.885632509430456, 0.710730530057353, 0.781268113754527, 0.7270187329324804, 0.6190233968339756, 0.7596532393586559, 0.6094043989932083, 0.8583860403377309, 0.9976670487472309, 0.39982099406509086, 0.7939045998510861, 0.9049915391854095, 0.7378133478786252, 0.4849983066632918, 0.8276875859517278, 0.5012938151517153, 0.49149017726150246]}}
{"id": "3cdc3fda-aba3-4777-a9fb-cf523bbb7b1e", "fitness": 0.7081561096828523, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and a smaller, dynamically updated archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size/5)  # Smaller dynamic archive\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x1 = self.population[idxs[0]]\n                else:\n                    x1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x2 = self.population[idxs[1]]\n                else:\n                    x2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x3 = self.population[idxs[2]]\n                else:\n                    x3 = self.archive[idxs[2] - self.pop_size]    \n                \n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update archive (reservoir sampling)\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        if np.random.rand() < self.archive_size / (len(self.archive) + 1):\n                            idx_to_replace = np.random.randint(self.archive_size)\n                            self.archive[idx_to_replace] = u.copy()\n\n            # Adapt F and CR (Self-adaptive, simplified)\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n                \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.708 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9dd6ba67-8911-4e6f-a84d-fd6953f68072"], "operator": null, "metadata": {"aucs": [0.38106293727957485, 0.6306599187297152, 0.6724573798301531, 0.9118869620371498, 0.7484885115865983, 0.7903473790258245, 0.7150212052653654, 0.7062418700753781, 0.7474246970930714, 0.7225806291563459, 0.8590687751578812, 0.999663343705227, 0.5895890299209033, 0.7421737427129211, 0.9016616060816585, 0.8296140869901982, 0.6398331638486481, 0.8495640534088904, 0.2241137791338298, 0.5016691226177117]}}
{"id": "2c58b301-0344-4144-952d-3633b6409803", "fitness": 0.7713394512038483, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using a success-history based adaptation for F and CR, and reduced population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.p = 0.1\n        self.archive = []\n        self.success_count = 0\n    \n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                self.F = self.memory_F[ind]\n                self.CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.archive.append(self.population[i].copy())\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update F and CR memory\n                    self.memory_F[ind] = self.F\n                    self.memory_CR[ind] = self.CR\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation\n            self.F = 0.5 + 0.3 * np.random.normal(0, 1)\n            self.CR = 0.9 + 0.1 * np.random.normal(0, 1)\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.771 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2f7ef1cd-c538-406c-b1c6-ee7b50bd94a3"], "operator": null, "metadata": {"aucs": [0.48940340084445233, 0.8336271805175893, 0.8071762820981466, 0.9342738140982106, 0.8681152870182467, 0.891680131059614, 0.819021932665405, 0.825302436621683, 0.8708936474860199, 0.825654463639913, 0.9342217071913677, 0.9984162853139855, 0.37690081987013135, 0.8602609291936385, 0.8295895888532934, 0.8810952977962814, 0.4455071986375565, 0.9134302352261623, 0.26401561110844174, 0.7582027748368265]}}
{"id": "f24181f5-e538-4ac3-ae85-f6f71f81942b", "fitness": 0.0, "name": "AdaptiveDE", "description": "Streamlined Adaptive Differential Evolution with simplified mutation, self-adaptive parameters, and reduced archive management for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size/5)\n        self.archive = []\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation (simplified: three distinct individuals from the population)\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Simplified Archive Update (no reservoir sampling): replace worst\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        worst_idx = np.argmax([func(x) for x in self.archive])\n                        self.archive[worst_idx] = u.copy()\n\n\n            # Adapt F and CR (Self-adaptive, simplified)\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n                \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3cdc3fda-aba3-4777-a9fb-cf523bbb7b1e"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "728cb4a0-8728-4c4d-8422-0c544f71580d", "fitness": 0.0, "name": "AdaptiveDE", "description": "Streamlined Adaptive Differential Evolution with simplified parameter adaptation and enhanced exploitation using a local search component.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Local search around the best solution\n                    if np.random.rand() < 0.1: # Apply local search with a small probability\n                      x_local = u + np.random.normal(0, 0.05, size=self.dim) # Smaller step size\n                      x_local = np.clip(x_local, func.bounds.lb, func.bounds.ub)\n                      f_local = func(x_local)\n                      self.budget -= 1\n\n                      if f_local < f_u:\n                        self.population[i] = x_local\n                        self.fitness[i] = f_local\n                        if f_local < self.f_opt:\n                          self.f_opt = f_local\n                          self.x_opt = x_local\n\n\n            # Adapt F and CR (Self-adaptive, simplified)\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n                \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3cdc3fda-aba3-4777-a9fb-cf523bbb7b1e"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "53d8c2cf-e033-4fd7-bf26-786390afb34b", "fitness": 0.7386323736908199, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic parameter adaptation based on successful mutations and reduced population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                mask = np.random.rand(self.dim) < self.CR\n                u = np.where(mask, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Adapt F and CR based on successful mutation\n                    self.F = 0.5 + 0.3 * np.random.normal(0, 1)\n                    self.CR = 0.7 + 0.1 * np.random.normal(0, 1)\n                    self.F = np.clip(self.F, 0.1, 1.0)\n                    self.CR = np.clip(self.CR, 0.1, 1.0)\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.739 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d63f191b-33b2-4c90-8644-8da5c19bb3a6"], "operator": null, "metadata": {"aucs": [0.2826714322202414, 0.4724802663995118, 0.7718675672483262, 0.8844847970015834, 0.8374922379231156, 0.8602206414331608, 0.7934569310280849, 0.7532125208102969, 0.8176096447382223, 0.7932696970725747, 0.8761430603606826, 0.9998263411519268, 0.3980024049827825, 0.830962177004734, 0.9436866589561096, 0.8641985145515594, 0.7205906123376031, 0.9017585189021371, 0.24475338603731678, 0.7259600636564305]}}
{"id": "250cfc29-17f2-46ce-906a-afb1a95b9109", "fitness": 0.6946004297352808, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified F/CR adaptation based on successful mutations and improved exploration using a larger F range and jitter in CR.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        for generation in range(self.budget // self.pop_size):\n            \n            successful_mutations_F = []\n            successful_mutations_CR = []\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    \n                    successful_mutations_F.append(self.F)\n                    successful_mutations_CR.append(self.CR)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        best_idx = np.argmin(self.fitness)\n\n            # Adapt F and CR (simplified) - based on successful mutations\n            if successful_mutations_F:\n                self.F = np.mean(successful_mutations_F)\n            else:\n                self.F = 0.5 + 0.3 * np.random.randn()  # Larger range for exploration\n            self.F = np.clip(self.F, 0.1, 0.9) # Wider range\n\n            if successful_mutations_CR:\n                self.CR = np.mean(successful_mutations_CR)\n            else:\n                self.CR = 0.9 + 0.1 * np.random.randn()  # More jitter\n            self.CR = np.clip(self.CR, 0.5, 1.0)\n                \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.695 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e94cd89a-e0f0-4cc6-8bac-cacf281c6b71"], "operator": null, "metadata": {"aucs": [0.22671502541711896, 0.6603375433440742, 0.6788814184599923, 0.8728534899905823, 0.7397915888510727, 0.7877576977465448, 0.6629513958110322, 0.6460651658734713, 0.7314562566296465, 0.6762835400007186, 0.8660369609174506, 0.9989935946317484, 0.6430949656271874, 0.7505737860444477, 0.9245976351187984, 0.7653938577506757, 0.5930163677664806, 0.8461912480881122, 0.2927164165592884, 0.528300640077172]}}
{"id": "580a8e20-7ce9-4f25-afcc-879b9e18156a", "fitness": 0.7108615514427195, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F/CR adaptation based on successful mutations and reduced population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):  # Reduced pop_size\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n        self.archive_rate = 0.1\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                v = x1 + self.F * (x2 - x3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n                    if len(self.archive) < self.pop_size * self.archive_rate:\n                      self.archive.append(self.population[i])\n                    else:\n                      self.archive[np.random.randint(len(self.archive))] = self.population[i]\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Adapt F and CR (Self-adaptive, simplified)\n            if self.success_F:\n                self.F = np.clip(np.mean(self.success_F), 0.1, 1.0)\n                self.CR = np.clip(np.mean(self.success_CR), 0.1, 1.0)\n            else:\n                self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n            \n            self.success_F = []\n            self.success_CR = []\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.711 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3cdc3fda-aba3-4777-a9fb-cf523bbb7b1e"], "operator": null, "metadata": {"aucs": [0.23300571269827364, 0.8134944528638341, 0.783970004810507, 0.929821123014511, 0.8566012727718192, 0.89442979506246, 0.7978008619691972, 0.8287265117715592, 0.8590936084083499, 0.19348175157140124, 0.9284254457792804, 0.9964844599475272, 0.42424577255445484, 0.8708669325451394, 0.7820082170150131, 0.873628383896968, 0.39457427227003106, 0.9201717344862125, 0.3281566384736305, 0.5082440769442194]}}
{"id": "4c8131a9-c7c8-4379-b560-2c27a7e9443f", "fitness": 0.7901162832182551, "name": "AdaptiveDE", "description": "Streamlined Adaptive Differential Evolution with a more focused memory and simplified parameter updates, reducing computational overhead.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Archive successful individuals\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                    else:\n                        # Replace worst individual in archive\n                        worst_idx = np.argmax([fit for _, fit in self.archive])\n                        self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update F and CR memory with successful values, prioritizing recent success.\n                    self.memory_F[ind] = F\n                    self.memory_CR[ind] = CR\n\n                if self.budget <= 0:\n                    break\n\n            # Simplified adaptation of F and CR - No normal distribution\n            self.memory_F = np.clip(0.5 * np.ones(self.archive_size) + 0.3 * np.random.rand(self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(0.9 * np.ones(self.archive_size) + 0.1 * np.random.rand(self.archive_size), 0.1, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.790 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2c58b301-0344-4144-952d-3633b6409803"], "operator": null, "metadata": {"aucs": [0.45895034106551, 0.799051870706185, 0.7956212558607366, 0.8985251856631508, 0.8229801687865643, 0.8446994488193225, 0.7772268303782253, 0.7466194592771869, 0.8273086056715987, 0.751467439239999, 0.9114321721719558, 0.9919688048697224, 0.8122170929741601, 0.8226118994739409, 0.9365130862538443, 0.8538611363311159, 0.76285034810173, 0.889728719196706, 0.3128873200164386, 0.7858044795070065]}}
{"id": "a8624553-f118-4535-8e0c-e89805d9f4d8", "fitness": 0.7490460863877184, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using a success-history based adaptation for F and CR, focusing on reducing complexity and improving exploration by dynamically adjusting the population.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    if len(self.archive) < self.archive_size:\n                      self.archive.append(self.population[i].copy())\n                    else:\n                      self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update F and CR memory\n                    self.memory_F[ind] = F\n                    self.memory_CR[ind] = CR\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation - more stable adaptation\n            successful_F = []\n            successful_CR = []\n            for i in range(self.archive_size):\n                if len(self.archive) > 0:\n                    idx = np.random.randint(0, len(self.archive))\n                    successful_F.append(np.random.uniform(0.1, 0.9))\n                    successful_CR.append(np.random.uniform(0.1, 0.9))\n\n\n            if successful_F:\n                self.memory_F = np.array(successful_F)\n            if successful_CR:\n                self.memory_CR = np.array(successful_CR)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.749 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2c58b301-0344-4144-952d-3633b6409803"], "operator": null, "metadata": {"aucs": [0.32907906229663864, 0.6600010955128, 0.7625696300380538, 0.9004590508697237, 0.8304099829155974, 0.8640942183040787, 0.7810894243904002, 0.7708038892933414, 0.8398580977934015, 0.7795542880096389, 0.8549041422515598, 0.9999117773422972, 0.345677755816193, 0.8261075095038476, 0.8661078020975561, 0.8776942644624008, 0.6327405569400801, 0.8802658672083603, 0.6535653358469635, 0.5260279768614351]}}
{"id": "e9f66459-f7e8-4595-be0b-a6f5a1dd4179", "fitness": 0.7440573224301295, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a population-weighted historical memory for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n        self.success_count = 0\n        self.fitness_history = []  # Store fitness improvements\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        self.fitness_history.append(np.min(self.fitness))\n\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Archive update\n                    self.archive.append((self.population[i].copy(), self.fitness[i]))  # Store fitness as well\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                    \n                    # Update F and CR memory - population-weighted approach\n                    delta_fitness = self.fitness[i] - f_u\n                    weight = np.abs(delta_fitness)  # Use absolute value to avoid negative weights\n\n                    self.memory_F[ind] = (1 - weight) * self.memory_F[ind] + weight * F  # Weighted average\n                    self.memory_CR[ind] = (1 - weight) * self.memory_CR[ind] + weight * CR\n\n                if self.budget <= 0:\n                    break\n\n            # Simplified Adaptation of F and CR\n            self.memory_F = np.clip(np.random.normal(0.5, 0.3, self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(np.random.normal(0.9, 0.2, self.archive_size), 0.1, 1.0)\n\n            self.fitness_history.append(np.min(self.fitness))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.744 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2c58b301-0344-4144-952d-3633b6409803"], "operator": null, "metadata": {"aucs": [0.25957976995204934, 0.8097460699182775, 0.6422802321190466, 0.9375453952268393, 0.8425619888329064, 0.8897348754243986, 0.8389298861785737, 0.8309283493334938, 0.8432613705038794, 0.8292818426541195, 0.9030168704748284, 0.9957727413302144, 0.4536163233661866, 0.8647020743452205, 0.7252201672935542, 0.8917179815425642, 0.6268712424728732, 0.896364482279299, 0.2972149246141984, 0.5027998607400657]}}
{"id": "2a3cfeaf-1b23-46f7-bfde-255034ad7c6a", "fitness": 0.709177200185992, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified F/CR adaptation based on the median of successful mutations and enhanced exploration using a per-dimension CR.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        for generation in range(self.budget // self.pop_size):\n            \n            successful_mutations_F = []\n            successful_mutations_CR = []\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    successful_mutations_F.append(self.F)\n                    successful_mutations_CR.append(self.CR)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        best_idx = np.argmin(self.fitness)\n\n            # Adapt F and CR (simplified) - based on successful mutations\n            if successful_mutations_F:\n                self.F = np.median(successful_mutations_F)\n            else:\n                self.F = 0.5 + 0.1 * np.random.randn()  # Reduced exploration range for F\n            self.F = np.clip(self.F, 0.1, 0.9)\n\n            if successful_mutations_CR:\n                self.CR = np.median(successful_mutations_CR)\n            else:\n                self.CR = 0.9 + 0.02 * np.random.randn() # Reduced exploration range for CR\n            self.CR = np.clip(self.CR, 0.6, 1.0) # Narrowed CR range\n                \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.709 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e94cd89a-e0f0-4cc6-8bac-cacf281c6b71"], "operator": null, "metadata": {"aucs": [0.336405490575296, 0.6650505967360123, 0.6739485661055737, 0.8675868471395776, 0.7358008315030558, 0.7629199694436344, 0.6622515207538988, 0.6447822735296567, 0.7446680890819448, 0.6527062708707942, 0.8587270245678175, 0.9894504635107451, 0.6838211531828511, 0.7160561908976005, 0.9269518868798555, 0.7904079495604529, 0.6606483374114502, 0.849869018669804, 0.31176644251308505, 0.6497250807867347]}}
{"id": "d3da3f1c-5bff-46ea-bd21-34a0d59891f8", "fitness": 0.809928395436479, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with jitter-based mutation and adaptive F/CR parameters promoting diversity and convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.p = 0.1\n        self.archive = []\n        self.success_count = 0\n    \n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation with jitter\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                # Adding jitter to F to increase diversity\n                F_jitter = F + 0.05 * np.random.normal(0, 1)\n                F_jitter = np.clip(F_jitter, 0.1, 1.0)  # Clip jittered F\n                v = x1 + F_jitter * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.archive.append(self.population[i].copy())\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update F and CR memory - Simplified update\n                    self.memory_F[ind] = F  # Store the original F value\n                    self.memory_CR[ind] = CR\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation, less aggressive\n            success_indices = self.fitness < np.mean(self.fitness)\n            if np.any(success_indices):\n                F_mean = np.mean(self.memory_F[np.random.choice(self.archive_size, size=min(self.archive_size,sum(success_indices)), replace=False)]) #using only successful F\n                CR_mean = np.mean(self.memory_CR[np.random.choice(self.archive_size, size=min(self.archive_size,sum(success_indices)), replace=False)]) #using only successful CR\n\n                self.memory_F = 0.8 * self.memory_F + 0.2*F_mean\n                self.memory_CR = 0.8 * self.memory_CR + 0.2*CR_mean\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.810 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2c58b301-0344-4144-952d-3633b6409803"], "operator": null, "metadata": {"aucs": [0.5370269069214824, 0.8467479617085486, 0.4860831086774444, 0.9225278128486885, 0.8739406344036356, 0.9009175214000955, 0.810377017367675, 0.8229621177978368, 0.8724019445574098, 0.8631484927735478, 0.9259068129784389, 0.9914441298248073, 0.8064855501456573, 0.8618762962309606, 0.8105209303007351, 0.8745386486891914, 0.813528922534341, 0.9022687898712366, 0.7729351676149658, 0.5029291420828802]}}
{"id": "4136193a-aeb1-413c-83af-03b0bb7ffaf5", "fitness": 0.7077643576389846, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified F/CR adaptation based on the median of successful values and reduced parameter range.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        for generation in range(self.budget // self.pop_size):\n            \n            successful_mutations_F = []\n            successful_mutations_CR = []\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    \n                    successful_mutations_F.append(self.F)\n                    successful_mutations_CR.append(self.CR)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        best_idx = np.argmin(self.fitness)\n\n            # Adapt F and CR (simplified) - based on successful mutations\n            if successful_mutations_F:\n                self.F = np.median(successful_mutations_F)\n            else:\n                self.F = 0.5\n            self.F = np.clip(self.F, 0.3, 0.7)\n\n            if successful_mutations_CR:\n                self.CR = np.median(successful_mutations_CR)\n            else:\n                self.CR = 0.9\n            self.CR = np.clip(self.CR, 0.7, 1.0)\n                \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.708 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e94cd89a-e0f0-4cc6-8bac-cacf281c6b71"], "operator": null, "metadata": {"aucs": [0.3912212435818597, 0.6424366724214726, 0.7078535432349464, 0.8880407326918279, 0.730817128737164, 0.7908708840964714, 0.6482708004099775, 0.6612567385245709, 0.768984677159353, 0.6927953986250914, 0.847584404341185, 0.997891455737956, 0.6315493760952706, 0.7324599653828271, 0.919694975673874, 0.7829547865335139, 0.6427214440965445, 0.8476631560605562, 0.307519757221411, 0.5227000121538201]}}
{"id": "3c7fb47b-c1cd-42f8-8f96-15729962d983", "fitness": 0.6587239632977402, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified F/CR adaptation using exponentially weighted moving averages and rank-based selection pressure.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Initial scaling factor\n        self.CR = CR  # Initial crossover rate\n        self.F_ewma = F\n        self.CR_ewma = CR\n        self.ewma_alpha = 0.2  # Weight for EWMA update\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        for generation in range(self.budget // self.pop_size):\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                \n                # Adapt F on a per-individual basis\n                F_ind = np.clip(np.random.normal(self.F_ewma, 0.1), 0.1, 1.0)\n                v = x1 + F_ind * (x2 - x3)\n\n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n\n                #Adapt CR on a per-individual basis\n                CR_ind = np.clip(np.random.normal(self.CR_ewma, 0.1), 0.0, 1.0)\n\n                for j in range(self.dim):\n                    if np.random.rand() < CR_ind or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i, j]\n\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    # Update EWMA for successful F and CR\n                    self.F_ewma = self.ewma_alpha * F_ind + (1 - self.ewma_alpha) * self.F_ewma\n                    self.CR_ewma = self.ewma_alpha * CR_ind + (1 - self.ewma_alpha) * self.CR_ewma\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.659 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e94cd89a-e0f0-4cc6-8bac-cacf281c6b71"], "operator": null, "metadata": {"aucs": [0.3128413625258276, 0.32482483131297424, 0.5257835052413649, 0.9092171375379581, 0.7044783786641209, 0.8132619050974124, 0.7103423100911574, 0.5262078866617566, 0.804937226061708, 0.7733294970423792, 0.8754324457119598, 0.9956100517332724, 0.48803831121144126, 0.7859723684964932, 0.8041070159684989, 0.804238305991003, 0.5407016398610381, 0.6611163991759841, 0.3001093355256369, 0.5139293520428196]}}
{"id": "3866d0e6-015e-41d8-8da9-9d69a365254f", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a small, focused archive for enhanced exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=3):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x)] * self.pop_size)\n        self.budget -= self.pop_size\n        \n        # Initial evaluation\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                mask = np.random.rand(self.dim) < CR\n                u = np.where(mask, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Archive successful individuals\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                    else:\n                        # Replace worst individual in archive if new fitness better than the worst in archive\n                        worst_idx = np.argmax([fit for _, fit in self.archive])\n                        if f_u < self.archive[worst_idx][1]:\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n                            \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update F and CR memory with successful values, prioritizing recent success.\n                    self.memory_F[ind] = F\n                    self.memory_CR[ind] = CR\n\n                if self.budget <= 0:\n                    break\n            # Simplified adaptation of F and CR - No normal distribution\n            self.memory_F = np.clip(0.5 + 0.3 * np.random.randn(self.archive_size), 0.1, 1.0) # Gaussian for better exploration\n            self.memory_CR = np.clip(0.9 + 0.1 * np.random.randn(self.archive_size), 0.1, 1.0) # Gaussian for better exploration\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "An exception occurred: name 'x' is not defined.", "error": "", "parent_ids": ["4c8131a9-c7c8-4379-b560-2c27a7e9443f"], "operator": null, "metadata": {}}
{"id": "99dcda02-3442-4557-8b09-d2f469d30b41", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with enhanced parameter adaptation and jitter-based mutation, focusing on balancing exploration and exploitation via dynamic F/CR adjustments.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n    \n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation with jitter\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                F_jitter = F + 0.05 * np.random.normal(0, 0.1) # Reduced jitter strength\n                F_jitter = np.clip(F_jitter, 0.1, 1.0)\n                v = x1 + F_jitter * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.archive.append(self.population[i].copy())\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update F and CR memory - Simplified update\n                    self.memory_F[ind] = 0.9 * self.memory_F[ind] + 0.1 * F_jitter # More direct F update\n                    self.memory_CR[ind] = 0.9 * self.memory_CR[ind] + 0.1 * CR     # More direct CR update\n\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation, less aggressive\n            successful_F = []\n            successful_CR = []\n\n            for k in range(min(self.archive_size,len(self.archive))):\n              ind = np.random.randint(0, self.archive_size)\n              if func(self.archive[k]) < np.mean(self.fitness):\n                successful_F.append(self.memory_F[ind])\n                successful_CR.append(self.memory_CR[ind])\n            \n            if successful_F:\n              F_mean = np.mean(successful_F)\n              CR_mean = np.mean(successful_CR)\n\n              self.memory_F = 0.8 * self.memory_F + 0.2 * F_mean\n              self.memory_CR = 0.8 * self.memory_CR + 0.2 * CR_mean\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d3da3f1c-5bff-46ea-bd21-34a0d59891f8"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "0ca04a16-bd7d-48bf-947e-beefb8163827", "fitness": 0.7471081378524894, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with success-history adaptation for F/CR, simplified population update, and focused memory update for exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=5, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    if len(self.archive) < self.archive_size:\n                      self.archive.append(self.population[i].copy())\n                    else:\n                      self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation - more stable adaptation\n            if len(self.archive) > 0:\n                self.F = np.random.uniform(0.1, 0.9)\n                self.CR = np.random.uniform(0.1, 0.9)\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.747 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a8624553-f118-4535-8e0c-e89805d9f4d8"], "operator": null, "metadata": {"aucs": [0.31820497170883, 0.64688469851591, 0.7740130959399596, 0.9039582048539683, 0.8583854481930528, 0.8715820158191144, 0.799425322890896, 0.7839005760165305, 0.8543259786668312, 0.7673281059062746, 0.8696937456532078, 0.9965919645497285, 0.31349368141723, 0.8078241572270944, 0.9164530900562605, 0.8970402884224665, 0.6626644683314945, 0.903012788103934, 0.23042965545238325, 0.7669504993246221]}}
{"id": "6e03156c-aa69-4de7-9fd8-2c03fc790b11", "fitness": 0.7266277628572997, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using a success-history based adaptation for F and CR, further simplifying parameter updates and memory handling for reduced complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_F.append(F)\n                    self.success_CR.append(CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation - more stable adaptation\n            if self.success_F:\n                self.memory_F = np.clip(np.mean(self.success_F) * np.ones(self.archive_size), 0.1, 0.9)\n                self.memory_CR = np.clip(np.mean(self.success_CR) * np.ones(self.archive_size), 0.1, 0.9)\n                self.success_F = []\n                self.success_CR = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.727 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a8624553-f118-4535-8e0c-e89805d9f4d8"], "operator": null, "metadata": {"aucs": [0.24526150168518168, 0.37153644546336684, 0.6270889103737134, 0.9459350749348028, 0.8612754837651542, 0.6885845601055229, 0.8518162814250264, 0.8703842390765874, 0.8974666562284828, 0.8816641238075169, 0.9154378309958269, 0.9953476569690369, 0.30457638172610846, 0.8815831688410007, 0.8048693255460595, 0.9166706125610221, 0.4476445612287726, 0.7315956377004132, 0.7583413552694012, 0.535475449442999]}}
{"id": "e1d41fe6-f98b-4b2b-8838-2e24f0f8a074", "fitness": 0.7225362772441202, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with probabilistic parameter updates and archive-based exploration for improved convergence and diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=5, p_adapt=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n        self.p_adapt = p_adapt # Probability of adaptation\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Probabilistic Adaptation of F and CR\n            if np.random.rand() < self.p_adapt:\n                successful_F = []\n                successful_CR = []\n                for _ in range(self.archive_size):\n                    if len(self.archive) > 0:\n                        successful_F.append(np.random.uniform(0.1, 0.9))\n                        successful_CR.append(np.random.uniform(0.1, 0.9))\n\n                if successful_F:\n                    self.memory_F = np.array(successful_F)\n                if successful_CR:\n                    self.memory_CR = np.array(successful_CR)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.723 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a8624553-f118-4535-8e0c-e89805d9f4d8"], "operator": null, "metadata": {"aucs": [0.31808050037217694, 0.6620641938988958, 0.8234449713933968, 0.9358724997925738, 0.8494982199135188, 0.8745622218264533, 0.7654790225020259, 0.7934991671332132, 0.8681023195315567, 0.7975098247173685, 0.905708922256717, 0.9908645618797193, 0.3312788584423526, 0.7888512188221707, 0.7937861638932664, 0.8742854437638956, 0.35479012242465147, 0.902695755805424, 0.3034527397384852, 0.5168988167745434]}}
{"id": "b80aa8cb-7b6c-4a1e-849a-09c4eaa634c0", "fitness": 0.4329391797927132, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a success-based memory that directly influences mutation and crossover probabilities.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n        self.fitness_history = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        self.fitness_history.append(np.min(self.fitness))\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Select from memory\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    # Update memory with success\n                    self.memory_F[ind] = 0.9 * self.memory_F[ind] + 0.1 * F\n                    self.memory_CR[ind] = 0.9 * self.memory_CR[ind] + 0.1 * CR\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n                else:\n                    # If unsuccessful, decrease F and CR slightly\n                    self.memory_F[ind] = max(0.1, self.memory_F[ind] - 0.01)\n                    self.memory_CR[ind] = max(0.1, self.memory_CR[ind] - 0.01)\n\n                if self.budget <= 0:\n                    break\n\n            self.fitness_history.append(np.min(self.fitness))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.433 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9f66459-f7e8-4595-be0b-a6f5a1dd4179"], "operator": null, "metadata": {"aucs": [0.1793420471469388, 0.24831863769731566, 0.35717959205916106, 0.47840458954176024, 0.44801083586156865, 0.3933458202729532, 0.359332102382083, 0.4795587146264304, 0.5757835214441713, 0.2561678930870337, 0.4702767602816176, 0.994416737086106, 0.25236288540255736, 0.4343466063936239, 0.8025710537472431, 0.4237254664230774, 0.42230446457770676, 0.2997525974830434, 0.27927967881546245, 0.5043035915244101]}}
{"id": "dbab20af-818d-48b3-b7f1-4a7f913e7174", "fitness": 0.790690119425605, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a focused archive, using a probability-based update rule for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5, p_adapt=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.p_adapt = p_adapt\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Update archive with a probability\n                    if np.random.rand() < self.p_adapt:\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append((self.population[i].copy(), self.fitness[i]))\n                        else:\n                            worst_idx = np.argmax([fit for _, fit in self.archive])\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n\n                        # Update F and CR memory with successful values\n                        self.memory_F[ind] = F\n                        self.memory_CR[ind] = CR\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Simplified adaptation of F and CR - No normal distribution\n            self.memory_F = np.clip(0.5 + 0.3 * np.random.rand(self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(0.9 + 0.1 * np.random.rand(self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.791 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c8131a9-c7c8-4379-b560-2c27a7e9443f"], "operator": null, "metadata": {"aucs": [0.4780853857690942, 0.7776558691349877, 0.7731991342727352, 0.9104199553074313, 0.7971193459831869, 0.8463822118779118, 0.6593855806645865, 0.7562523709966891, 0.8422448168623058, 0.8124989332322202, 0.9203800600127985, 0.9941526068202327, 0.7851324945711811, 0.8208990365247193, 0.9633636266337874, 0.8458349673459344, 0.7469186341837178, 0.8927106127211605, 0.6629107060015855, 0.5282560395958332]}}
{"id": "41e89613-5678-4e59-8ff6-944c74444587", "fitness": 0.8051912028507877, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and a focused archive, balancing exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Update archive: Replace worst individual in archive if applicable, otherwise append\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                    else:\n                        worst_idx = np.argmax([fit for _, fit in self.archive])\n                        if self.fitness[i] > self.archive[worst_idx][1]:\n                            pass #Don't update if current fitness is worse than worst archive fitness\n                        else:\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n\n                    # Update F and CR memory with a small probability\n                    if np.random.rand() < 0.1:\n                        self.memory_F[ind] = F\n                        self.memory_CR[ind] = CR\n\n\n                if self.budget <= 0:\n                    break\n\n            # Adaptation of F and CR using uniform distribution within a narrower range\n            self.memory_F = np.clip(np.random.uniform(0.3, 0.7, self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(np.random.uniform(0.7, 1.0, self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.805 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c8131a9-c7c8-4379-b560-2c27a7e9443f"], "operator": null, "metadata": {"aucs": [0.3916492089848991, 0.8651272887746836, 0.8185568965885103, 0.9462615924016964, 0.8434512427120209, 0.891983136301565, 0.8155738662917448, 0.8237195463085677, 0.8561055309715961, 0.8300964469032954, 0.9216009930003276, 0.9986330930700598, 0.5031704953694045, 0.8323066301948024, 0.8976288913396216, 0.8796255094814155, 0.8087971452464, 0.9133500130826251, 0.7315435360861684, 0.5346429939063475]}}
{"id": "574042bc-82d5-4bd8-bd11-bee62287f7d0", "fitness": 0.3028931921903313, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with orthogonal design for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.orthogonal_matrix = self._create_orthogonal_matrix(dim)\n\n    def _create_orthogonal_matrix(self, dim):\n        # Simplified orthogonal matrix creation (Hadamard matrix if dim is a power of 2)\n        if (dim & (dim - 1)) == 0:  # Check if dim is a power of 2\n            n = 1\n            while n < dim:\n                n *= 2\n            H = np.ones((2, 2))\n            while H.shape[0] < n:\n                H = np.vstack((np.hstack((H, H)), np.hstack((H, -H))))\n            return H[:dim, :dim]\n        else:\n            # If dim is not a power of 2, generate a random orthogonal matrix\n            Q, _ = np.linalg.qr(np.random.randn(dim, dim))\n            return Q\n\n    def __call__(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation using orthogonal design\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Apply orthogonal design to the difference vector\n                diff = v - self.population[i]\n                u = self.population[i] + CR * np.dot(self.orthogonal_matrix, diff)\n                \n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    # Archive update (simplified)\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)                    \n                    self.archive.append((self.population[i], self.fitness[i]))\n                    \n                    # Update population and fitness\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update optimal solution\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Update F and CR memory using simplified adaptation\n                    self.memory_F[ind] = 0.9 * self.memory_F[ind] + 0.1 * F\n                    self.memory_CR[ind] = 0.9 * self.memory_CR[ind] + 0.1 * CR\n\n\n                if self.budget <= 0:\n                    break\n\n            # Simplified Adaptation of F and CR (Gaussian distribution)\n            self.memory_F = np.clip(np.random.normal(0.5, 0.3, self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(np.random.normal(0.9, 0.2, self.archive_size), 0.1, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.303 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9f66459-f7e8-4595-be0b-a6f5a1dd4179"], "operator": null, "metadata": {"aucs": [0.12014195344125689, 0.18652363998093346, 0.2767291505470253, 0.2565592915137207, 0.23616136556111966, 0.2797267633254207, 0.22911803476870363, 0.26958440405912476, 0.2713355737059657, 0.19635250371624202, 0.21175779763287994, 0.9978051412027839, 0.23334606722727846, 0.27525703678255653, 0.5631922240880594, 0.3034293449037634, 0.2346860620580301, 0.3095187497495493, 0.15525881562517585, 0.4513799239170363]}}
{"id": "7fa4b396-53d0-4959-92e0-708d241de849", "fitness": 0.4814343542917642, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with probabilistic mutation based on fitness rank and simplified F/CR adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n    \n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            ranked_indices = np.argsort(self.fitness) #rank individuals\n\n            for i in range(self.pop_size):\n                # Probabilistic mutation based on rank\n                rank = np.where(ranked_indices == i)[0][0]\n                p = (rank / self.pop_size) #probability decreases with rank\n\n                if np.random.rand() < (1-p): #less likely to mutate if rank is high\n\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x1, x2, x3 = self.population[idxs]\n                    v = x1 + self.F * (x2 - x3)\n\n                    # Crossover\n                    u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n                else:\n                    u = np.random.uniform(func.bounds.lb, func.bounds.ub) #random mutation\n\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n            \n            # Adapt F and CR - Simplified adaptation based on mean fitness\n            if np.std(self.fitness) > 0.0001:  # Check for diversity to avoid premature convergence\n                self.F = 0.9 * self.F + 0.1 * np.random.rand() #random small changes\n                self.CR = 0.9 * self.CR + 0.1 * np.random.rand()\n\n                self.F = np.clip(self.F, 0.1, 1.0) # bound F and CR\n                self.CR = np.clip(self.CR, 0.1, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.481 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d3da3f1c-5bff-46ea-bd21-34a0d59891f8"], "operator": null, "metadata": {"aucs": [0.15998503352190507, 0.2622903415631558, 0.46845756776335934, 0.7207694750677718, 0.48263041977416943, 0.5515241928654768, 0.3926140127364123, 0.4398378662074841, 0.4524113260533493, 0.277503834499643, 0.697920940127517, 0.996336842466886, 0.31542258626100994, 0.3760412155747601, 0.7312398987166071, 0.545627616632149, 0.37765183990155204, 0.6299021767915234, 0.24425157382478335, 0.5062683254857683]}}
{"id": "ca1fbbbc-762f-4061-bfad-c2aaa975fbaf", "fitness": 0.6961967076061992, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters, greedy selection, and a repair mechanism to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Fixed F\n        self.CR = 0.9  # Fixed CR\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                else:\n                    #Greedy Selection: replace 'u' with original 'x' if it's worse\n                    u = self.population[i] # Keep old position\n                    \n\n                if self.budget <= 0:\n                    break\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.696 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c8131a9-c7c8-4379-b560-2c27a7e9443f"], "operator": null, "metadata": {"aucs": [0.24831487490336834, 0.6116778894379358, 0.6817341325070834, 0.9446622085069513, 0.8989865113055111, 0.9183073254289547, 0.3317725328608099, 0.8702047287790462, 0.8998944028397649, 0.22207779716163312, 0.9435662439627952, 0.9975522202490734, 0.2717549559956446, 0.7676184916229316, 0.7561163548511647, 0.9128413851394119, 0.40097721404015463, 0.9300841721771186, 0.7760663101038697, 0.5397244002507607]}}
{"id": "fc7bee79-f466-4a42-ba8d-a2fecd78bff3", "fitness": 0.6809751618415035, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with success-history based parameter adaptation, simplified memory handling, and improved mutation strategy for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.ones(archive_size) * 0.5\n        self.memory_CR = np.ones(archive_size) * 0.9\n        self.archive = []\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            self.success_F = []\n            self.success_CR = []\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                # Improved mutation with jitter\n                v = x1 + F * (x2 - x3) + 0.001 * np.random.randn(self.dim) \n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n                    \n                    # Store successful F and CR\n                    self.success_F.append(F)\n                    self.success_CR.append(CR)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation - more stable adaptation\n            if self.success_F:\n                self.memory_F = (0.9 * self.memory_F + 0.1 * np.mean(self.success_F))\n            if self.success_CR:\n                self.memory_CR = (0.9 * self.memory_CR + 0.1 * np.mean(self.success_CR))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.681 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a8624553-f118-4535-8e0c-e89805d9f4d8"], "operator": null, "metadata": {"aucs": [0.3933092215872833, 0.3375297602014481, 0.6419131206654216, 0.9503218499896806, 0.6710251361962586, 0.7515910042566991, 0.5824866552273147, 0.5750715028554239, 0.7001371784162271, 0.6688150669479357, 0.9410901502887763, 0.9980501147850729, 0.44051229280768944, 0.6978798423037123, 0.9061190572966753, 0.7297774780366182, 0.6120236863528741, 0.9095669667627241, 0.6031374753443557, 0.509145676507879]}}
{"id": "b17d8ecb-de1a-46e5-9e02-c0af790afbb5", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with success-based parameter adaptation and reduced archive update frequency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5, adapt_freq=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.adapt_freq = adapt_freq  # Reduced adaptation frequency\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Probabilistic archive update and parameter adaptation\n                    if np.random.rand() < self.adapt_freq:\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append((self.population[i].copy(), self.fitness[i]))\n                        else:\n                            worst_idx = np.argmax([fit for _, fit in self.archive])\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i]))\n\n                        # Update F and CR memory with successful values\n                        self.memory_F[ind] = 0.9 * self.memory_F[ind] + 0.1 * F  # Exponential smoothing\n                        self.memory_CR[ind] = 0.9 * self.memory_CR[ind] + 0.1 * CR\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Simplified adaptation of F and CR - No normal distribution. Adapt every generation, but smoothed.\n            self.memory_F = np.clip(0.8 * self.memory_F + 0.2 * np.random.rand(self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(0.8 * self.memory_CR + 0.2 * (0.8 + 0.2*np.random.rand(self.archive_size)), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "An exception occurred: unmatched ')' (<string>, line 49).", "error": "", "parent_ids": ["dbab20af-818d-48b3-b7f1-4a7f913e7174"], "operator": null, "metadata": {}}
{"id": "4ccbf879-b88d-4884-9b9d-6e038011a31d", "fitness": 0.7718662094496754, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with success-history adaptation for F/CR, using a narrower range for F/CR adaptation, and removing the archive for memory updates, which reduces complexity and may improve exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Adaptation of F and CR using uniform distribution within a narrower range\n            self.F = np.clip(np.random.uniform(0.3, 0.7), 0.1, 1.0)\n            self.CR = np.clip(np.random.uniform(0.7, 1.0), 0.1, 1.0)\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.772 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["41e89613-5678-4e59-8ff6-944c74444587"], "operator": null, "metadata": {"aucs": [0.5415121925527174, 0.7993202108204713, 0.7887289247354786, 0.9100633137548034, 0.8696706020546345, 0.8877389289946268, 0.8177575224897953, 0.8140672907716919, 0.8743523615537223, 0.8326021843491345, 0.9313974235846126, 0.9959496194489064, 0.3428212969100348, 0.8458058410217575, 0.8117677803101406, 0.8756728924920247, 0.8168695025194439, 0.9208062025451083, 0.22480360598238336, 0.5356164921020208]}}
{"id": "13d22f5d-518a-45ce-a740-ec57b07b940c", "fitness": 0.730850619081386, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive, using a single random value for F and CR, and simplified archive replacement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            F = np.random.uniform(0.1, 0.9)\n            CR = np.random.uniform(0.1, 0.9)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.731 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0ca04a16-bd7d-48bf-947e-beefb8163827"], "operator": null, "metadata": {"aucs": [0.2962141139755521, 0.5254419908113842, 0.7468077419909385, 0.8837730454699302, 0.8526010131980528, 0.8815123050387486, 0.7829252105008726, 0.7948443094750257, 0.8524550518343732, 0.7883511867951036, 0.8555489343366085, 0.9962667351369373, 0.3800828251133077, 0.8108563366017235, 0.7286042205592997, 0.8871167227621626, 0.6803388027827512, 0.879485273907175, 0.2769822726567557, 0.7168042886810174]}}
{"id": "6783de54-5879-4e57-ac72-0770d19609f1", "fitness": 0.7420709590626239, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with reduced archive interactions and probabilistic parameter updates based on population performance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_rate=0.1, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_rate = archive_rate  # Fraction of pop_size to archive\n        self.archive_size = int(pop_size * archive_rate)\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Archive with probability, less frequent updates\n                    if np.random.rand() < self.archive_rate:\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i].copy())\n                        elif self.archive_size > 0: #Ensure archive not empty to avoid errors\n                            self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Adaptive F and CR based on improvement, probabilistic update\n                    if np.random.rand() < 0.2:  # Reduced update frequency\n                        self.F = np.random.uniform(0.1, 0.9)\n                        self.CR = np.random.uniform(0.1, 0.9)\n                elif np.random.rand() < 0.05: # Even less frequent adaptation if no improvement\n                     self.F = np.random.uniform(0.1, 0.9)\n                     self.CR = np.random.uniform(0.1, 0.9)\n\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.742 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0ca04a16-bd7d-48bf-947e-beefb8163827"], "operator": null, "metadata": {"aucs": [0.265080148375326, 0.6501768630803144, 0.7792851358677928, 0.9076214319991965, 0.8232147035017096, 0.8675212787956107, 0.7485162657066433, 0.7605796192760466, 0.8485485099223726, 0.7516457947993649, 0.8454875604824128, 0.9946213568409751, 0.352250028244144, 0.8029840618749645, 0.9304601816960474, 0.864626793492624, 0.7104940680765925, 0.8830812374882172, 0.3411486190605908, 0.7140755226715332]}}
{"id": "b4539894-e5e3-4610-bc03-81bd89c260ae", "fitness": 0.4478547090649648, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic population size adjustment and parameter adaptation for better exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=5, F=0.5, CR=0.9, pop_reduction_factor=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.pop_reduction_factor = pop_reduction_factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    if len(self.archive) < self.archive_size:\n                      self.archive.append(self.population[i].copy())\n                    else:\n                      self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR - Simplified adaptation - more stable adaptation\n            self.F = np.clip(np.random.normal(self.F, 0.1), 0.1, 0.9) # More stable F adaptation\n            self.CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 0.9) # More stable CR adaptation\n\n            #Dynamic population size reduction\n            if self.budget > self.pop_size and np.random.rand() < 0.1:\n                new_pop_size = int(self.pop_size * self.pop_reduction_factor)\n                if new_pop_size > 3:\n                    self.pop_size = new_pop_size\n                    self.population = self.population[:self.pop_size]\n                    self.fitness = self.fitness[:self.pop_size]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.448 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0ca04a16-bd7d-48bf-947e-beefb8163827"], "operator": null, "metadata": {"aucs": [0.24085092627212068, 0.45621525183062017, 0.33537740061026344, 0.2488614585017721, 0.3805701864982265, 0.37676002815120946, 0.42099198419586636, 0.43551941520075865, 0.5499460011151968, 0.19617251500827615, 0.9077966936612875, 0.9947218440265466, 0.2701817110690954, 0.4235743957535443, 0.7403552063905054, 0.5319525078184528, 0.3274788040965403, 0.40843136849415007, 0.20584743397093763, 0.5054890486339241]}}
{"id": "5cd27e83-c565-497b-8532-ad33f05fb524", "fitness": 0.7254837351041201, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with reduced parameter tuning and direct F/CR updates, focusing on faster adaptation and reduced complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation: Select F and CR from memory\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Simplified F/CR update: Directly replace memory with current values\n                    self.memory_F[ind] = F\n                    self.memory_CR[ind] = CR\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Randomize F and CR memory less aggressively\n            self.memory_F = np.clip(self.memory_F + 0.1 * np.random.randn(self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(self.memory_CR + 0.1 * np.random.randn(self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.725 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["dbab20af-818d-48b3-b7f1-4a7f913e7174"], "operator": null, "metadata": {"aucs": [0.24389104635771308, 0.6061300187117012, 0.7825369095769433, 0.8920012810721512, 0.8382142271115899, 0.8601273586669675, 0.7584546215598981, 0.7211220581634636, 0.7825726277860989, 0.7151220292657838, 0.9063921570916939, 0.9987651331426849, 0.39373286879897007, 0.7330192776797604, 0.9116791282646655, 0.8252695269000351, 0.7554488276034809, 0.8823045855852973, 0.3656395024704827, 0.5372515162730236]}}
{"id": "ac28b989-d0af-4fc0-882d-7fd5860d5310", "fitness": 0.7393207925861403, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, focused archive updates, and reduced complexity for enhanced efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5, p_adapt=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.p_adapt = p_adapt\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                mask = np.random.rand(self.dim) < CR\n                u = np.where(mask, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Update archive with a probability\n                    if np.random.rand() < self.p_adapt:\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append((self.population[i].copy(), self.fitness[i]))\n                        else:\n                            worst_idx = np.argmax([fit for _, fit in self.archive])\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n\n                        # Update F and CR memory with successful values (simplified)\n                        self.memory_F[ind] = 0.9 * self.memory_F[ind] + 0.1 * F\n                        self.memory_CR[ind] = 0.9 * self.memory_CR[ind] + 0.1 * CR\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Simplified adaptation of F and CR\n            self.memory_F = np.clip(0.5 + 0.3 * np.random.randn(self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(0.9 + 0.1 * np.random.randn(self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.739 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["dbab20af-818d-48b3-b7f1-4a7f913e7174"], "operator": null, "metadata": {"aucs": [0.2446136119268394, 0.7396084081310257, 0.8488579562692677, 0.9216160947489422, 0.8811428502341642, 0.8930498338998981, 0.37336791474252984, 0.8604997321654516, 0.8506888475950176, 0.8415536771374366, 0.9247352603034644, 0.9976464194638007, 0.45219147782436053, 0.8386058646347149, 0.7839004310031411, 0.874884831671271, 0.7823774387504179, 0.9119435032946026, 0.2587031739055956, 0.5064285240208615]}}
{"id": "2f024fac-9aee-45bb-8584-6f997bb873be", "fitness": 0.6519334897873188, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with success-history adaptation, focused parameter tuning, and simplified archive management for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive_fitness = np.full(archive_size, np.inf)\n        self.archive_parameters = np.zeros((archive_size, 2))  # Store F and CR\n        self.archive_idx = 0\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Archive update\n                    if f_u < self.archive_fitness[self.archive_idx]:\n                        self.archive_fitness[self.archive_idx] = f_u\n                        self.archive_parameters[self.archive_idx] = [F, CR]\n                        self.archive_idx = (self.archive_idx + 1) % self.archive_size\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Adaptation of F and CR - Simplified\n            successful_indices = np.where(self.fitness < np.median(self.fitness))[0]\n            if len(successful_indices) > 0:\n                chosen_idx = np.random.choice(successful_indices)\n                best_F = self.archive_parameters[np.argmin(self.archive_fitness)][0]\n                best_CR = self.archive_parameters[np.argmin(self.archive_fitness)][1]\n                self.memory_F = np.clip(np.random.normal(best_F, 0.1, self.archive_size), 0.1, 1.0)\n                self.memory_CR = np.clip(np.random.normal(best_CR, 0.1, self.archive_size), 0.1, 1.0)\n            \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.652 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["41e89613-5678-4e59-8ff6-944c74444587"], "operator": null, "metadata": {"aucs": [0.3021978192769462, 0.5924516412170528, 0.7795226146914562, 0.9244949832257783, 0.7874804771492792, 0.7286487232896979, 0.7994048935151252, 0.48414847014290163, 0.30170335588344355, 0.7732500939292938, 0.8743554666711, 0.995714713644646, 0.3058490846809274, 0.7102625853243586, 0.8918094958020333, 0.8429928331407889, 0.3499447577618924, 0.8707064524278252, 0.22128192554319515, 0.5024494084286308]}}
{"id": "d71236cb-b30a-4eda-b6a8-41114ffc1a5d", "fitness": 0.7814906584266077, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adjusting F/CR values based on past success, reducing complexity and maintaining exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                if self.success_F and self.success_CR:\n                    F = np.random.choice(self.success_F)\n                    CR = np.random.choice(self.success_CR)\n                else:\n                    F = 0.5\n                    CR = 0.9\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_F.append(F)\n                    self.success_CR.append(CR)\n                    if len(self.success_F) > self.archive_size:\n                        self.success_F.pop(0)\n                        self.success_CR.pop(0)\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.781 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["dbab20af-818d-48b3-b7f1-4a7f913e7174"], "operator": null, "metadata": {"aucs": [0.4562896835328385, 0.8546353914860219, 0.8490170357971693, 0.9362370311884922, 0.8753339222724801, 0.8924447992766698, 0.8258399792105438, 0.836961052733857, 0.8640090877061717, 0.7762118337891488, 0.9281174087371873, 0.9970098863091763, 0.43630623419640235, 0.8741188067357603, 0.9445838170340976, 0.8878136178157509, 0.7083390486580231, 0.9156317625152187, 0.25402068420683865, 0.5168920853303054]}}
{"id": "4e94d2e9-d32c-4d1f-998b-b1084393d510", "fitness": 0.30821509696756755, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F/CR adaptation and focused archive management, prioritizing population diversity and search stability.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_rate=0.1, F_base=0.5, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = int(pop_size * archive_rate)  # Dynamic archive size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Dynamic F/CR adaptation based on population diversity\n                diversity = np.std(self.population)\n                F = self.F_base * (1 + diversity) # Adaptation of F\n                CR = min(1.0, self.CR_base * (1 + diversity)) # Adaptation of CR\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Archive update - simplified\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        if np.random.rand() < 0.5: # 50% chance of replacement\n                            self.archive[np.random.randint(0, self.archive_size)] = self.population[i].copy()\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.308 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0ca04a16-bd7d-48bf-947e-beefb8163827"], "operator": null, "metadata": {"aucs": [0.12862677572783543, 0.27613422835003754, 0.38653203956934323, 0.2432240219465659, 0.17186194665466514, 0.19872549423150598, 0.23253684666147212, 0.2982468302745096, 0.2524252983080534, 0.20073186723884695, 0.18575181090694637, 0.9952824694434925, 0.19018955378353664, 0.2682897225840628, 0.551183231454945, 0.3363380585156258, 0.26806308656243105, 0.34922631036045204, 0.15864649777408268, 0.47228584900294135]}}
{"id": "4df3da11-d530-49fc-81bc-93d21d157d97", "fitness": 0.7729904246552686, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with reduced memory and parameter adaptation, using a single F/CR value for all individuals and immediate adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Adapt F and CR immediately after each generation\n            if self.success_F:\n                self.F = np.clip(np.mean(self.success_F), 0.1, 0.9)\n                self.CR = np.clip(np.mean(self.success_CR), 0.1, 0.9)\n                self.success_F = []\n                self.success_CR = []\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.773 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6e03156c-aa69-4de7-9fd8-2c03fc790b11"], "operator": null, "metadata": {"aucs": [0.37435983239026427, 0.8703515507500925, 0.6205954064873449, 0.9483760003355023, 0.8826553940062608, 0.9250215127228449, 0.8540572658321388, 0.8660096581572537, 0.8989592938981115, 0.8347022608043848, 0.9428508377377635, 0.9981479845322171, 0.3332499683940261, 0.8634566364516478, 0.7824454545375393, 0.9185179173726301, 0.361979453334772, 0.9436301405361451, 0.7198922879182408, 0.5205496369061913]}}
{"id": "cf708eb9-c125-462b-af45-0e3b32051bb3", "fitness": 0.7819005902719022, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and memory update, focusing on exploitation around promising solutions using a tighter F/CR range and a rank-based archive replacement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Update archive: Replace worst individual in archive if applicable\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                        \n                    else:\n                        fitness_values = [fit for _, fit in self.archive]\n                        worst_idx = np.argmax(fitness_values)\n                        if f_u < fitness_values[worst_idx]:  # Compare f_u with the worst fitness\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adaptation of F and CR using uniform distribution within a narrower range\n            self.memory_F = np.clip(np.random.uniform(0.3, 0.7, self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(np.random.uniform(0.7, 1.0, self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.782 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["41e89613-5678-4e59-8ff6-944c74444587"], "operator": null, "metadata": {"aucs": [0.524348024707258, 0.8458569181112892, 0.7662914950037737, 0.9092654991973974, 0.8712314650012536, 0.8710004677697559, 0.8154190207139668, 0.8351928594479945, 0.8628358168401145, 0.8022025437043128, 0.9176823462297945, 0.999319302067857, 0.37197942883395685, 0.8498721760723816, 0.9516898325494674, 0.8872111714509333, 0.798055853402419, 0.9041586084291044, 0.32549263882085255, 0.5289063370841616]}}
{"id": "3f8d7e43-9439-4dbc-932f-a300106cd9a4", "fitness": 0.7479511885471934, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified adaptation, focusing on population diversity and constraint handling through boundary-aware mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                \n                # Boundary-aware mutation\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clipping unnecessary because of new approach in mutation\n                u = np.clip(u, lb, ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Simplified Adaptation (fixed values to improve speed)\n            # self.F = 0.5  # Keep F constant for simplicity\n            # self.CR = 0.9 # Keep CR constant for simplicity\n\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.748 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4df3da11-d530-49fc-81bc-93d21d157d97"], "operator": null, "metadata": {"aucs": [0.5785123378219232, 0.36436637362792956, 0.5960552038933564, 0.938419036234481, 0.8957860111486464, 0.901500009271419, 0.8572609978140742, 0.8629793754685547, 0.8730019629709566, 0.847600278766417, 0.9387689040255742, 0.9954379872889926, 0.6412397157764835, 0.8798936555711218, 0.7215461327950139, 0.9188053314419843, 0.45677732931690285, 0.9309512248841361, 0.23638791291565353, 0.5237339899102479]}}
{"id": "0929f4a6-2117-449f-8284-3ea4dde5b073", "fitness": 0.7436519770234277, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a population-wide learning rate (gamma) to control the magnitude of mutation, and clipping to repair solutions.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, gamma=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.gamma = gamma  # Learning rate for mutation\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: Simplified with learning rate gamma\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.gamma * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.744 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4ccbf879-b88d-4884-9b9d-6e038011a31d"], "operator": null, "metadata": {"aucs": [0.3834412142796667, 0.6997917797029862, 0.7243570551225622, 0.9067315510404572, 0.8152109513857608, 0.8492152904361998, 0.6426875901561062, 0.7307917300131768, 0.7800147631986795, 0.7239233611398322, 0.8803255098554407, 0.997276913589187, 0.723991929227924, 0.7656005861959589, 0.9364573678585477, 0.8357592974777375, 0.6600905216680424, 0.8795630000579554, 0.4106567066891783, 0.5271524213731541]}}
{"id": "4e877ae3-3cb3-4a9a-a97c-b3ad27659b2b", "fitness": 0.717679942941625, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a reduced parameter adaptation frequency and adaptive population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size_factor=4):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_size_factor)  # Adaptive population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n        self.adapt_freq = 10  # Reduce adaptation frequency\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        generation = 0\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            generation += 1\n            # Adapt F and CR less frequently\n            if generation % self.adapt_freq == 0 and self.success_F:\n                self.F = np.clip(np.mean(self.success_F), 0.1, 0.9)\n                self.CR = np.clip(np.mean(self.success_CR), 0.1, 0.9)\n                self.success_F = []\n                self.success_CR = []\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.718 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4df3da11-d530-49fc-81bc-93d21d157d97"], "operator": null, "metadata": {"aucs": [0.6352849830055463, 0.29103036533643356, 0.5049895456311164, 0.9278240159045853, 0.8509166405155365, 0.903730573719158, 0.3618697207301399, 0.8559952386821083, 0.8865718035312382, 0.27859864257920197, 0.9379376295189817, 0.9962229303268305, 0.37126101497481134, 0.8841281026013381, 0.6991501683229753, 0.8986473689373926, 0.8547505991635904, 0.9363136042840314, 0.7563853381436433, 0.5219905729238383]}}
{"id": "c701f90a-b01b-4f1a-994b-8659e07a7c72", "fitness": 0.652282709784879, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced memory, using a fixed F and CR adjusted by a simple success rate to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_count = 0\n        self.generation_count = 0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            self.success_count = 0  # Reset success count for each generation\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_count += 1\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Adapt F and CR based on success rate\n            success_rate = self.success_count / self.pop_size\n            if success_rate > 0.4:\n                self.F = np.clip(self.F + 0.05, 0.1, 0.9)\n                self.CR = np.clip(self.CR + 0.05, 0.1, 0.9)\n            elif success_rate < 0.1:\n                self.F = np.clip(self.F - 0.05, 0.1, 0.9)\n                self.CR = np.clip(self.CR - 0.05, 0.1, 0.9)\n\n            self.generation_count += 1\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.652 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4df3da11-d530-49fc-81bc-93d21d157d97"], "operator": null, "metadata": {"aucs": [0.1594609048636998, 0.2675048856558494, 0.7956773012087484, 0.8978863103289093, 0.8484867921931512, 0.8379064602559214, 0.7689940492206591, 0.7737738720355163, 0.8315630794809418, 0.3318807926945132, 0.9153271024733256, 0.996134994483939, 0.26176170927743003, 0.530062507390348, 0.8308935032157754, 0.8616503071850887, 0.49339807194585106, 0.8874057580750994, 0.2344648022448349, 0.5214209914679786]}}
{"id": "97726fbe-cbaf-40be-9d4c-2e128f8d661a", "fitness": 0.3834348024766559, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and population-wide best solution exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        \n        best_idx = np.argmin(self.fitness)\n        best_x = self.population[best_idx]\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = best_x\n\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation - using current best for exploitation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x1, x2 = self.population[idxs]\n                v = self.population[i] + self.F * (best_x - self.population[i]) + self.F * (x1 - x2) # current-to-best mutation\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        best_x = u  # Update best_x if a better solution is found\n                        \n\n            # Adapt F and CR immediately after each generation\n            if self.success_F:\n                self.F = np.clip(np.mean(self.success_F), 0.1, 0.9)\n                self.CR = np.clip(np.mean(self.success_CR), 0.1, 0.9)\n                self.success_F = []\n                self.success_CR = []\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.383 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4df3da11-d530-49fc-81bc-93d21d157d97"], "operator": null, "metadata": {"aucs": [0.160721676284461, 0.2048745452119186, 0.3732687750232734, 0.24657553285079947, 0.2336567028391715, 0.41397930958167883, 0.32818531655429084, 0.5674621562724518, 0.3171428345830053, 0.22119585276953335, 0.4246362348948425, 0.998165874589872, 0.30719851370340034, 0.3834954021415812, 0.6714676099218913, 0.28067655762522914, 0.336904949351971, 0.47072676243052736, 0.2265634208234083, 0.50179802207981]}}
{"id": "d99b8439-b9aa-4ce0-8514-e3e5761cb967", "fitness": 0.7348627662195275, "name": "AdaptiveDE", "description": "Streamlined Adaptive Differential Evolution with simplified parameter adaptation and population initialization for enhanced efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = self.lb + np.random.rand(self.pop_size, self.dim) * (self.ub - self.lb)\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + self.F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, self.lb, self.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n            # Adapt F and CR immediately after each generation\n            if self.success_F:\n                self.F = 0.9 * self.F + 0.1 * np.mean(np.clip(self.success_F, 0.1, 0.9))\n                self.CR = 0.9 * self.CR + 0.1 * np.mean(np.clip(self.success_CR, 0.1, 0.9))\n                self.success_F = []\n                self.success_CR = []\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.735 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4df3da11-d530-49fc-81bc-93d21d157d97"], "operator": null, "metadata": {"aucs": [0.5152948701455585, 0.8698382672330885, 0.6611036829725856, 0.9080245668277447, 0.8356774978990638, 0.9184674214471075, 0.8402181777951099, 0.8399452104910299, 0.891416918514726, 0.8861527640263843, 0.5722405543125832, 0.9997421453455158, 0.4092325942513365, 0.8944718933510404, 0.7476349974115992, 0.9050887258179025, 0.2837726528839767, 0.932515721053139, 0.26346856553167597, 0.5229480970793825]}}
{"id": "34cf0ea0-6840-4dae-a7c3-8648b7702b53", "fitness": 0.7730223904490688, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a focused F/CR range and a rank-based replacement in a smaller archive, emphasizing recent search experience.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, archive_size=3):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Simplified archive update: replace a random element in archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                    else:\n                        replace_idx = np.random.randint(0, self.archive_size)\n                        self.archive[replace_idx] = (self.population[i].copy(), self.fitness[i])\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adaptation of F and CR\n            self.memory_F = np.clip(np.random.normal(0.5, 0.1, self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(np.random.normal(0.9, 0.1, self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.773 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cf708eb9-c125-462b-af45-0e3b32051bb3"], "operator": null, "metadata": {"aucs": [0.5081014508522466, 0.8531526920868048, 0.6096836554957692, 0.9482835542166947, 0.8872895182827645, 0.8864278631675577, 0.8776055287069533, 0.7121120873771742, 0.884584110443702, 0.8805060580045445, 0.49358344477323457, 0.9958454694784081, 0.2800717821445533, 0.8869359437839159, 0.7911838157708799, 0.8425688374891375, 0.7635250955948176, 0.9156671595618113, 0.8657412268723315, 0.5775785148780748]}}
{"id": "4638cd6a-4656-4627-8767-37774d30eeb7", "fitness": 0.5918647224579859, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, dynamic population size adjustment, and a rank-based archive replacement strategy for enhanced exploitation and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5, shrink_factor=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n        self.shrink_factor = shrink_factor\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Update archive: Replace worst individual in archive if applicable\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                        \n                    else:\n                        fitness_values = [fit for _, fit in self.archive]\n                        worst_idx = np.argmax(fitness_values)\n                        if f_u < fitness_values[worst_idx]:  # Compare f_u with the worst fitness\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adaptation of F and CR using uniform distribution within a narrower range\n            self.memory_F = np.clip(np.random.uniform(0.3, 0.7, self.archive_size), 0.1, 1.0)\n            self.memory_CR = np.clip(np.random.uniform(0.7, 1.0, self.archive_size), 0.1, 1.0)\n\n            # Dynamic population size adjustment\n            if generation % 10 == 0:\n                self.pop_size = max(int(self.pop_size * self.shrink_factor), 5)  # Ensure a minimum pop_size\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.592 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cf708eb9-c125-462b-af45-0e3b32051bb3"], "operator": null, "metadata": {"aucs": [0.38560923579196504, 0.41252311291125543, 0.36883423999068277, 0.9401742865867077, 0.639775333060018, 0.590883748221385, 0.5792622446129128, 0.5629718858353874, 0.44634797244515234, 0.4549938686716867, 0.9333919263446244, 0.9980779533866524, 0.33883277811537027, 0.4963479599219509, 0.7767454477017982, 0.7093647899889097, 0.47549275076686737, 0.8895715204477861, 0.3345928732548208, 0.5035005211037851]}}
{"id": "cb17f8bb-c809-49aa-9df1-6f9c2c9e1236", "fitness": 0.7827641061560128, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with success-history adaptation for F/CR and rank-based archive replacement, using a dynamically updated archive and simplified parameter update mechanism to enhance exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n        self.archive_fitness = []  # Store fitness values separately for efficient sorting\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Update archive: Replace worst individual in archive if applicable\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                        self.archive_fitness.append(self.fitness[i])\n                    else:\n                        worst_idx = np.argmax(self.archive_fitness) # Directly use precomputed fitnesses\n                        if f_u < self.archive_fitness[worst_idx]:  # Compare f_u with the worst fitness\n                            self.archive[worst_idx] = self.population[i].copy()\n                            self.archive_fitness[worst_idx] = self.fitness[i]\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adaptation of F and CR using success-based update\n            successful_F = []\n            successful_CR = []\n            for i in range(len(self.archive)):\n                if self.archive_fitness[i] < self.fitness[np.argmin(self.fitness)]:\n                  successful_F.append(np.random.uniform(0.3, 0.7))\n                  successful_CR.append(np.random.uniform(0.7, 1.0))\n\n            if successful_F:\n                self.memory_F = np.clip(np.mean(successful_F), 0.1, 1.0) * np.ones(self.archive_size)\n                self.memory_CR = np.clip(np.mean(successful_CR), 0.1, 1.0) * np.ones(self.archive_size)\n            else:\n                self.memory_F = np.clip(np.random.uniform(0.3, 0.7, self.archive_size), 0.1, 1.0)\n                self.memory_CR = np.clip(np.random.uniform(0.7, 1.0, self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.783 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cf708eb9-c125-462b-af45-0e3b32051bb3"], "operator": null, "metadata": {"aucs": [0.47099815812079615, 0.8042015277698038, 0.7028106401552776, 0.9256259362824595, 0.8623654081500278, 0.8081254554959493, 0.7725855160321486, 0.8054745608581494, 0.8484527147390484, 0.8346543006100962, 0.9130110429360786, 0.9995910447436184, 0.5292887954911614, 0.8566132068147407, 0.8397340526379139, 0.8824045378665586, 0.6349759606897489, 0.9159618913887959, 0.7155101755097536, 0.5328971968281262]}}
{"id": "dc21044b-6b6d-4549-bc73-0fecd9ab99a1", "fitness": 0.7359939126590678, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and memory update, focusing on exploitation around promising solutions using a tighter F/CR range, rank-based archive, and improved memory update based on successful parameter pairs.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n        self.success_pairs = []  # Store successful F/CR pairs\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Store successful F/CR pairs\n                    self.success_pairs.append((F, CR))\n\n                    # Update archive: Replace worst individual in archive if applicable\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                    else:\n                        fitness_values = [fit for _, fit in self.archive]\n                        worst_idx = np.argmax(fitness_values)\n                        if f_u < fitness_values[worst_idx]:\n                            self.archive[worst_idx] = (self.population[i].copy(), self.fitness[i])\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n            # Adaptation of F and CR based on successful pairs\n            if self.success_pairs:\n                successful_F = np.array([pair[0] for pair in self.success_pairs])\n                successful_CR = np.array([pair[1] for pair in self.success_pairs])\n\n                # Update memory with the mean of successful values\n                self.memory_F = np.full(self.archive_size, np.mean(successful_F)) if len(successful_F) > 0 else np.clip(np.random.uniform(0.3, 0.7, self.archive_size), 0.1, 1.0)\n                self.memory_CR = np.full(self.archive_size, np.mean(successful_CR)) if len(successful_CR) > 0 else np.clip(np.random.uniform(0.7, 1.0, self.archive_size), 0.1, 1.0)\n\n                self.success_pairs = []  # Reset successful pairs\n\n            else:\n                 # Adaptation of F and CR using uniform distribution within a narrower range\n                self.memory_F = np.clip(np.random.uniform(0.3, 0.7, self.archive_size), 0.1, 1.0)\n                self.memory_CR = np.clip(np.random.uniform(0.7, 1.0, self.archive_size), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.736 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cf708eb9-c125-462b-af45-0e3b32051bb3"], "operator": null, "metadata": {"aucs": [0.31697277490807974, 0.8205755165517672, 0.6085294467606546, 0.9338627345338909, 0.8709808513579228, 0.8909764999709273, 0.36725480873605687, 0.8098806078161895, 0.8775591049005221, 0.8639850087245887, 0.9256407762213305, 0.988880489452744, 0.30701715553675146, 0.8853919532818764, 0.8146371938952846, 0.8914078560389292, 0.7995165263000643, 0.920010050554262, 0.3093212636115228, 0.5174776340279916]}}
{"id": "a6e8b6e0-5de9-458b-8d2b-78663f095c54", "fitness": 0.7961390871771757, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with momentum-based adaptation of F/CR and simplified archive update, focusing on maintaining diversity and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=5, momentum=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.memory_F = np.full(archive_size, 0.5)\n        self.memory_CR = np.full(archive_size, 0.9)\n        self.archive = []\n        self.momentum = momentum\n        self.f_opt = np.inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter adaptation using success history with momentum\n                ind = np.random.randint(0, self.archive_size)\n                F = self.memory_F[ind]\n                CR = self.memory_CR[ind]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    # Simplified archive update: replace a random member\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append((self.population[i].copy(), self.fitness[i]))\n                    else:\n                        replace_idx = np.random.randint(0, self.archive_size)\n                        self.archive[replace_idx] = (self.population[i].copy(), self.fitness[i])\n\n                    # Momentum-based update of memory\n                    success_F = np.random.uniform(0.3, 0.7)\n                    success_CR = np.random.uniform(0.7, 1.0)\n                    self.memory_F[ind] = (1 - self.momentum) * self.memory_F[ind] + self.momentum * success_F\n                    self.memory_CR[ind] = (1 - self.momentum) * self.memory_CR[ind] + self.momentum * success_CR\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.796 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cf708eb9-c125-462b-af45-0e3b32051bb3"], "operator": null, "metadata": {"aucs": [0.49752294370710404, 0.8172456086860811, 0.7916520955635766, 0.9222726835726207, 0.8542427831514321, 0.9049087162799574, 0.7840161735882867, 0.7909726301524473, 0.8659588844859862, 0.7972435127927434, 0.9153986413399505, 0.9985531860039066, 0.7696721784789503, 0.8599023718998964, 0.9405571668715175, 0.874192321441722, 0.7505469156762785, 0.9146306463071178, 0.33627491652385855, 0.5370173670200824]}}
{"id": "07a40675-7185-48d4-b37e-b37b05737c81", "fitness": 0.7686895459295552, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using a truncated Cauchy distribution for F and a fixed CR, focusing on exploration with occasional re-initialization.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F_mean=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_mean = F_mean\n        self.CR = CR\n        self.min_F = 0.1\n        self.period = 100  # Re-initialization period\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        self.generation = 0\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = self.population[idxs]\n\n                # Sample F from truncated Cauchy distribution\n                F = self.F_mean + 0.1 * np.tan(np.pi * (np.random.rand() - 0.5))  # Cauchy-like\n                F = np.clip(F, self.min_F, 1.0)  # Truncate\n\n                v = x1 + F * (x2 - x3)\n\n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Repair: Clip to bounds\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                f_u = func(u)\n                self.budget -= 1\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                if self.budget <= 0:\n                    break\n            self.generation += 1\n\n            if self.generation % self.period == 0:\n                # Re-initialize a random portion of the population\n                num_reinit = self.pop_size // 5  # Re-initialize 20%\n                reinit_indices = np.random.choice(self.pop_size, num_reinit, replace=False)\n                self.population[reinit_indices] = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(num_reinit, self.dim))\n                self.fitness[reinit_indices] = np.array([func(x) for x in self.population[reinit_indices]])\n                self.budget -= num_reinit\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.769 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d71236cb-b30a-4eda-b6a8-41114ffc1a5d"], "operator": null, "metadata": {"aucs": [0.3168981385162639, 0.7037428819465064, 0.7847256088767879, 0.9099638372556038, 0.845611367456036, 0.8714374122305071, 0.7698804677123489, 0.766534301075245, 0.8484362298062058, 0.798614511717175, 0.8896907368001218, 0.9951746021066035, 0.5577677912669452, 0.8166629900562559, 0.9215102697407254, 0.8811477895155391, 0.7015307563583522, 0.9016764584176664, 0.3148226596836904, 0.7779621080525234]}}
