{"id": "8aad9235-1f2b-4f42-af39-e65cd64b7965", "fitness": 0.093444945119788, "name": "CMAES", "description": "Covariance matrix adaptation evolution strategy with adaptive population size and restart mechanism.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None,\n                 ccov1=None, ccovmu=None, restarts=5):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n\n        # Strategy parameter setting: Selection\n        self.mu = int(popsize // 2) if popsize else int(4 + np.floor(3 * np.log(self.dim)))  # Number of parents/individuals for recombination\n        self.weights = np.log(self.mu + 1) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        # Strategy parameter setting: Adaptation\n        self.cs = cs  # Cumulation for sigma (step-size)\n        self.damps = damps if damps else 1 + 2 * np.max([0, np.sqrt((self.mueff - 1) / (self.dim + 1)) - 1]) + self.cs  # Damping for sigma\n        self.ccov1 = ccov1 if ccov1 else 2 / ((self.dim + 1.3)**2 + self.mueff)  # Learning rate for rank-one update\n        self.ccovmu = ccovmu if ccovmu else 2 * (self.mueff - 2 + 1 / self.mueff) / ((self.dim + 2)**2 + self.mueff)  # Learning rate for rank-mu update\n        self.ccov1sep = min(1, self.ccov1 * (self.dim + 1.5) / 3)  # Learning rate for rank-one update when diagonal covariance matrix is used\n        self.ccovmusep = min(1, self.ccovmu * (self.dim + 1.5) / 3)  # Learning rate for rank-mu update when diagonal covariance matrix is used\n\n        # Initialize dynamic (internal) strategy parameters and constants\n        self.C = np.eye(self.dim)  # Covariance matrix\n        self.sigma = 0.3  # Step-size\n        self.pc = np.zeros(self.dim)  # Evolution path for C\n        self.ps = np.zeros(self.dim)  # Evolution path for sigma\n        self.normps = np.sqrt(np.sum(self.ps**2))\n        self.chiN = self.dim**0.5 * (1 - 1 / (4 * self.dim) + 1 / (21 * self.dim**2))  # Expectation of ||N(0,I)||\n\n        self.popsize = popsize if popsize else int(4 + np.floor(3 * np.log(self.dim))) # Population size\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def sample_population(self, func, mean):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        x = mean + self.sigma * (z @ np.linalg.cholesky(self.C).T)\n        f = np.array([func(xi) for xi in x])\n        return x, f\n\n    def update_distribution(self, x, f, mean):\n        # Sort by fitness and compute weighted mean into xmean\n        idx = np.argsort(f)\n        xmean = np.sum(x[idx[:self.mu]] * self.weights[:, np.newaxis], axis=0)\n\n        # Cumulation: Update evolution paths\n        ps_tmp = np.linalg.solve(np.sqrt(self.C), (xmean - mean))\n        self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * ps_tmp\n        self.normps = np.sqrt(np.sum(self.ps**2))\n\n        self.pc = (1 - self.ccov1) * self.pc + np.sqrt(self.ccov1 * (2 - self.ccov1) * self.mueff) * (xmean - mean)\n\n        # Adapt covariance matrix C\n        artmp = (x[idx[:self.mu]] - mean).T / self.sigma\n        self.C = (1 - self.ccov1 - self.ccovmu + self.ccov1 * self.ccovmu * np.sum(self.weights) + self.ccovmu * np.sum(self.weights * np.sum(artmp**2, axis=0))) * self.C + self.ccov1 * self.pc[:, np.newaxis] @ self.pc[np.newaxis, :] + self.ccovmu * artmp @ np.diag(self.weights) @ artmp.T\n\n        # Adapt step-size sigma\n        self.sigma = self.sigma * np.exp((self.cs / self.damps) * (self.normps / self.chiN - 1))\n        \n        # Decomposition for robustness\n        try:\n          self.C = np.triu(self.C) + np.triu(self.C, 1).T\n          self.C = np.linalg.cholesky(self.C)\n          self.C = self.C @ self.C.T\n        except:\n          self.C = np.eye(self.dim)\n    \n\n    def __call__(self, func):\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        used_budget = 0\n\n        for _ in range(self.restarts):\n            while used_budget + self.popsize <= self.budget:\n                x, f = self.sample_population(func, mean)\n                used_budget += self.popsize\n\n                if np.min(f) < self.f_opt:\n                    self.f_opt = np.min(f)\n                    self.x_opt = x[np.argmin(f)]\n                \n                self.update_distribution(x, f, mean)\n                idx = np.argsort(f)\n                mean = np.sum(x[idx[:self.mu]] * self.weights[:, np.newaxis], axis=0)\n\n            if used_budget >= self.budget:\n                break\n            \n            self.popsize = int(self.popsize * 1.2)\n            self.popsize = min(self.popsize, self.budget)\n            \n            mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n            self.C = np.eye(self.dim)  # Covariance matrix\n            self.sigma = 0.3  # Step-size\n            self.pc = np.zeros(self.dim)  # Evolution path for C\n            self.ps = np.zeros(self.dim)  # Evolution path for sigma\n            self.normps = np.sqrt(np.sum(self.ps**2))\n            self.chiN = self.dim**0.5 * (1 - 1 / (4 * self.dim) + 1 / (21 * self.dim**2))  # Expectation of ||N(0,I)||\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm CMAES scored 0.093 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0, 0.05796689793040244, 0.16259528609502083, 0.07764045769307582, 0.0, 0.10986100821475409, 0.15935601505222696, 0.1421622527017522, 0.0, 0.09737336941968189, 0.12279798899686722, 0.1151305793166868, 0.097573719955527, 0.06823258645195052, 0.13064707447073254, 0.12490460672379755, 0.06726084786053432, 0.10720651048848939, 0.10997226952685069, 0.11821743149740993]}}
{"id": "5110ab53-0119-46cc-8b2a-6250ca613a44", "fitness": 0.296194678058909, "name": "AdaptiveStepSizeES", "description": "Adaptively adjusts the step size based on the success rate of improving solutions within a local neighborhood, biasing search towards promising regions.", "code": "import numpy as np\n\nclass AdaptiveStepSizeES:\n    def __init__(self, budget=10000, dim=10, initial_step_size=0.1, success_threshold=0.2, step_size_multiplier=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.step_size = initial_step_size\n        self.success_threshold = success_threshold\n        self.step_size_multiplier = step_size_multiplier\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim) # Initialize x_opt within bounds\n        self.f_opt = func(self.x_opt) # Evaluate initial x_opt, crucially before the loop.\n\n        successes = 0\n        evaluations = 1 # Account for the initial evaluation.\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution by adding noise to the current best\n            x_candidate = self.x_opt + self.step_size * np.random.normal(0, 1, size=self.dim)\n\n            # Clip the candidate solution to stay within the bounds\n            x_candidate = np.clip(x_candidate, func.bounds.lb, func.bounds.ub)\n\n            f_candidate = func(x_candidate)\n            evaluations += 1\n\n            if f_candidate < self.f_opt:\n                self.f_opt = f_candidate\n                self.x_opt = x_candidate\n                successes += 1\n\n            # Adapt step size based on success rate\n            if evaluations % 100 == 0: # Adjust step size every 100 evaluations\n                success_rate = successes / 100\n                if success_rate > self.success_threshold:\n                    self.step_size *= (1 + self.step_size_multiplier)\n                else:\n                    self.step_size *= (1 - self.step_size_multiplier)\n                self.step_size = max(self.step_size, 1e-6)  # Ensure step size doesn't become too small\n                successes = 0\n\n            if evaluations >= self.budget: # Budget check inside the loop\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveStepSizeES scored 0.296 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.037519336113657986, 0.16176066011645762, 0.5158089592298761, 0.9418160783292667, 0.11213797918607238, 0.13575318845718154, 0.19043282083169932, 0.14700924906486124, 0.14625428695598153, 0.10348346124886543, 0.9196575822244425, 0.12637094064677679, 0.2745450437027207, 0.16702017601328956, 0.9163366692699922, 0.30849969528884513, 0.20058670531378664, 0.17098920683912966, 0.15277684844550166, 0.19513467389977546]}}
{"id": "cf977fdf-fa0e-432f-b056-e4437df2db6d", "fitness": 0.5115321403187469, "name": "SelfAdaptiveVelocityPSO", "description": "A population-based algorithm employing a velocity-based update rule, inspired by Particle Swarm Optimization, but incorporating a self-adaptive exploration-exploitation balance using a Cauchy mutation to enhance diversity and escape local optima.", "code": "import numpy as np\n\nclass SelfAdaptiveVelocityPSO:\n    def __init__(self, budget=10000, dim=10, pop_size=20, inertia_weight=0.7, cognitive_coeff=1.5, social_coeff=1.5, exploration_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.inertia_weight = inertia_weight\n        self.cognitive_coeff = cognitive_coeff\n        self.social_coeff = social_coeff\n        self.exploration_rate = exploration_rate  # Probability of Cauchy mutation\n\n    def __call__(self, func):\n        # Initialize population and velocities\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, size=(self.pop_size, self.dim))  # Initialize velocities\n\n        # Evaluate initial population\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size  # Adjust budget\n\n        # Initialize personal best positions and fitnesses\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n\n        # Initialize global best position and fitness\n        global_best_index = np.argmin(fitness)\n        global_best_position = population[global_best_index].copy()\n        global_best_fitness = fitness[global_best_index]\n\n        while self.budget > 0:\n            # Update velocities and positions\n            for i in range(self.pop_size):\n                # Update velocity\n                inertia = self.inertia_weight * velocities[i]\n                cognitive = self.cognitive_coeff * np.random.rand(self.dim) * (personal_best_positions[i] - population[i])\n                social = self.social_coeff * np.random.rand(self.dim) * (global_best_position - population[i])\n                velocities[i] = inertia + cognitive + social\n\n                # Update position\n                new_position = population[i] + velocities[i]\n                \n                # Apply boundary handling (clip)\n                new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n\n                # Exploration via Cauchy mutation\n                if np.random.rand() < self.exploration_rate:\n                    mutation = np.random.standard_cauchy(size=self.dim) * 0.1  # Scale Cauchy distribution\n                    new_position += mutation\n                    new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n\n                # Evaluate new position\n                new_fitness = func(new_position)\n                self.budget -= 1\n                \n                # Update personal best\n                if new_fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = new_fitness\n                    personal_best_positions[i] = new_position.copy()\n\n                # Update global best\n                if new_fitness < global_best_fitness:\n                    global_best_fitness = new_fitness\n                    global_best_position = new_position.copy()\n\n                population[i] = new_position.copy()\n\n\n            if self.budget <= 0:\n                break\n\n        return global_best_fitness, global_best_position", "configspace": "", "generation": 0, "feedback": "The algorithm SelfAdaptiveVelocityPSO scored 0.512 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.19612711332244903, 0.3059188888297605, 0.5532443994954337, 0.9139092092022798, 0.4868443100401614, 0.6118840399480825, 0.3237999800263529, 0.46153821569377373, 0.5128880541273247, 0.3372409909073938, 0.8737556174210341, 0.9964547308207562, 0.32402719305306005, 0.40052938070641486, 0.7228160036805942, 0.36191183260442383, 0.35690936905355897, 0.7876274651769813, 0.25242036720898176, 0.4507956450561188]}}
{"id": "38c76f28-a362-4234-b7aa-46347b1bcac9", "fitness": 0.702802500265531, "name": "ADE_SR", "description": "Adaptive Differential Evolution with Archive and Stochastic Ranking.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=100, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_fitness = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member with probability 0.1\n                if np.random.rand() < 0.1 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (self.fitness[i] <= 0 and f_u <= 0) or (self.fitness[i] > 0 and f_u > 0 and f_u < self.fitness[i]):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                        self.archive_fitness.append(self.fitness[i])\n                    else:\n                        # Replace a random element in the archive\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n                        self.archive_fitness[rand_idx] = self.fitness[i]\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm ADE_SR scored 0.703 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.3042753961829797, 0.6617603913079693, 0.7127391038042684, 0.8787308289123188, 0.7341973513768172, 0.7741557739343723, 0.6349708711940224, 0.6705242984116481, 0.7609613227631266, 0.6394646149993544, 0.8812226572316535, 0.9935864709041469, 0.6921379211013936, 0.7364461008934647, 0.911627007096108, 0.7722285563720535, 0.6265102803836055, 0.8536907466685923, 0.2893522820657457, 0.5274680297069787]}}
{"id": "33a04c35-0dc2-4573-b3de-21f1bd6154cd", "fitness": 0.0, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with Stochastic Ranking and reduced archive interaction for faster convergence.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (self.fitness[i] <= 0 and f_u <= 0) or (self.fitness[i] > 0 and f_u > 0 and f_u < self.fitness[i]):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n                \n                    # Archive update: Add only if better than worst in archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    elif f_u < np.max([func(x) for x in self.archive]):\n                         self.archive[np.argmax([func(x) for x in self.archive])] = self.population[i]\n                \n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm ADE_SR scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["38c76f28-a362-4234-b7aa-46347b1bcac9"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "55bccc47-b406-4d6d-9e45-73db9874f7db", "fitness": -Infinity, "name": "SimplifiedCMAES", "description": "Simplified CMA-ES with fewer parameters and restart mechanism, focusing on core adaptation.", "code": "import numpy as np\n\nclass SimplifiedCMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, restarts=5, sigma=0.3):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.sigma = sigma  # Initial step-size\n        self.popsize = popsize if popsize else int(4 + np.floor(3 * np.log(self.dim))) # Population size\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.C = np.eye(self.dim) # Covariance Matrix\n\n    def sample_population(self, func, mean):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        x = mean + self.sigma * (z @ np.linalg.cholesky(self.C).T)\n        f = np.array([func(xi) for xi in x])\n        return x, f\n\n    def update_distribution(self, x, f, mean):\n        idx = np.argsort(f)[:self.mu]\n        xmean = np.sum(x[idx] * self.weights[:, np.newaxis], axis=0)\n        \n        artmp = (x[idx] - mean).T / self.sigma\n        self.C = (0.5) * self.C + (0.5) * artmp @ np.diag(self.weights) @ artmp.T # Simplified covariance update\n        \n        try:\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            self.C = np.linalg.cholesky(self.C)\n            self.C = self.C @ self.C.T\n        except:\n            self.C = np.eye(self.dim)\n            \n        return xmean\n\n    def __call__(self, func):\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        used_budget = 0\n\n        for _ in range(self.restarts):\n            while used_budget + self.popsize <= self.budget:\n                x, f = self.sample_population(func, mean)\n                used_budget += self.popsize\n\n                if np.min(f) < self.f_opt:\n                    self.f_opt = np.min(f)\n                    self.x_opt = x[np.argmin(f)]\n                \n                mean = self.update_distribution(x, f, mean)\n                self.sigma *= np.exp(0.05 * (np.mean(f) - self.f_opt) / np.std(f)) # Adapt sigma\n\n            if used_budget >= self.budget:\n                break\n            \n            mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n            self.C = np.eye(self.dim)\n            self.sigma = 0.3\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: Matrix is not positive definite.", "error": "", "parent_ids": ["8aad9235-1f2b-4f42-af39-e65cd64b7965"], "operator": null, "metadata": {}}
{"id": "e3c4d294-4258-4986-ab59-fa7ce6982d2b", "fitness": -Infinity, "name": "SimplifiedCMAES", "description": "Simplified CMA-ES with reduced parameters and population size adaptation based on budget.", "code": "import numpy as np\n\nclass SimplifiedCMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize else int(4 + np.floor(3 * np.log(self.dim)))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.C = np.eye(self.dim)\n        self.sigma = 0.3\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.mean = None\n\n    def sample_population(self, func):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        x = self.mean + self.sigma * (z @ np.linalg.cholesky(self.C).T)\n        f = np.array([func(xi) for xi in x])\n        return x, f\n\n    def update_distribution(self, x, f):\n        idx = np.argsort(f)[:self.mu]\n        xmean = np.sum(x[idx] * self.weights[:, np.newaxis], axis=0)\n        artmp = (x[idx] - self.mean).T / self.sigma\n        self.C = (1 - 1/self.dim) * self.C + (1/self.dim) * artmp @ np.diag(self.weights) @ artmp.T\n        self.sigma *= np.exp(0.5/self.dim * (np.mean(np.sum(artmp**2, axis=0)) - self.dim))\n        self.mean = xmean\n\n    def __call__(self, func):\n        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        used_budget = 0\n        \n        while used_budget + self.popsize <= self.budget:\n            x, f = self.sample_population(func)\n            used_budget += self.popsize\n\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[np.argmin(f)]\n\n            self.update_distribution(x, f)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: Matrix is not positive definite.", "error": "", "parent_ids": ["8aad9235-1f2b-4f42-af39-e65cd64b7965"], "operator": null, "metadata": {}}
{"id": "c18313b6-20b4-4260-bb65-9601ed1ca7eb", "fitness": -Infinity, "name": "SimplifiedCMAES", "description": "Simplified CMA-ES with fewer parameters and a more robust covariance matrix adaptation, focusing on efficient exploration and exploitation within the budget.", "code": "import numpy as np\n\nclass SimplifiedCMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, sigma=0.3, restarts=3):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.sigma = sigma  # Step-size\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.popsize = popsize if popsize else int(4 + np.floor(3 * np.log(self.dim)))\n\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n\n        self.C = np.eye(self.dim)\n\n    def sample_population(self, func, mean):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        x = mean + self.sigma * (z @ np.linalg.cholesky(self.C).T)\n        f = np.array([func(xi) for xi in x])\n        return x, f\n\n    def update_distribution(self, x, f, mean):\n        idx = np.argsort(f)\n        xmean = np.sum(x[idx[:self.mu]] * self.weights[:, np.newaxis], axis=0)\n\n        artmp = (x[idx[:self.mu]] - mean).T / self.sigma\n        self.C = (0.8 * self.C + 0.2 * artmp @ np.diag(self.weights) @ artmp.T)\n        \n        try:\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            self.C = np.linalg.cholesky(self.C)\n            self.C = self.C @ self.C.T\n        except:\n            self.C = np.eye(self.dim)\n        \n\n    def __call__(self, func):\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        used_budget = 0\n\n        for _ in range(self.restarts):\n            while used_budget + self.popsize <= self.budget:\n                x, f = self.sample_population(func, mean)\n                used_budget += self.popsize\n\n                if np.min(f) < self.f_opt:\n                    self.f_opt = np.min(f)\n                    self.x_opt = x[np.argmin(f)]\n\n                self.update_distribution(x, f, mean)\n                idx = np.argsort(f)\n                mean = np.sum(x[idx[:self.mu]] * self.weights[:, np.newaxis], axis=0)\n\n            if used_budget >= self.budget:\n                break\n            mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n            self.C = np.eye(self.dim)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: Matrix is not positive definite.", "error": "", "parent_ids": ["8aad9235-1f2b-4f42-af39-e65cd64b7965"], "operator": null, "metadata": {}}
{"id": "3993e210-b765-4a46-8358-c6dfde8c4016", "fitness": 0.27906682963684243, "name": "AdaptiveStepSizeES", "description": "Adaptively adjusts step size based on success, using a simplified update rule and periodic step size adjustments.", "code": "import numpy as np\n\nclass AdaptiveStepSizeES:\n    def __init__(self, budget=10000, dim=10, initial_step_size=0.1, success_threshold=0.2, step_size_multiplier=0.05, adaptation_frequency=100):\n        self.budget = budget\n        self.dim = dim\n        self.step_size = initial_step_size\n        self.success_threshold = success_threshold\n        self.step_size_multiplier = step_size_multiplier\n        self.adaptation_frequency = adaptation_frequency\n        self.successes = 0\n        self.evaluations = 0\n\n\n    def __call__(self, func):\n        self.x_opt = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.f_opt = func(self.x_opt)\n        self.evaluations = 1\n\n        while self.evaluations < self.budget:\n            x_candidate = self.x_opt + self.step_size * np.random.normal(0, 1, size=self.dim)\n            x_candidate = np.clip(x_candidate, func.bounds.lb, func.bounds.ub)\n            f_candidate = func(x_candidate)\n            self.evaluations += 1\n\n            if f_candidate < self.f_opt:\n                self.f_opt = f_candidate\n                self.x_opt = x_candidate\n                self.successes += 1\n\n            if self.evaluations % self.adaptation_frequency == 0:\n                success_rate = self.successes / self.adaptation_frequency\n                if success_rate > self.success_threshold:\n                    self.step_size *= (1 + self.step_size_multiplier)\n                else:\n                    self.step_size *= (1 - self.step_size_multiplier)\n\n                self.step_size = max(self.step_size, 1e-6)\n                self.successes = 0\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveStepSizeES scored 0.279 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5110ab53-0119-46cc-8b2a-6250ca613a44"], "operator": null, "metadata": {"aucs": [0.09250398734861354, 0.15171108984190174, 0.20511758061397567, 0.19652225464259276, 0.08980586968576776, 0.11158532985537062, 0.22129712581808636, 0.12126086777339917, 0.15986951472219224, 0.08617277244836363, 0.9296650484706047, 0.18258207017327743, 0.2820538033346247, 0.158068849328858, 0.9338613682548067, 0.3607928378305768, 0.27457087567507565, 0.7387507079868412, 0.1351285643485307, 0.15001607458338917]}}
{"id": "83f32468-fc7b-4145-a101-1a730d0a087c", "fitness": 0.2677583413609862, "name": "AdaptiveStepSizeES", "description": "Adaptively adjusts the step size based on the success rate, using a simplified step size update and a more stable success rate calculation.", "code": "import numpy as np\n\nclass AdaptiveStepSizeES:\n    def __init__(self, budget=10000, dim=10, initial_step_size=0.1, success_threshold=0.2, step_size_multiplier=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.step_size = initial_step_size\n        self.success_threshold = success_threshold\n        self.step_size_multiplier = step_size_multiplier\n        self.successes = 0\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.x_opt = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.f_opt = func(self.x_opt)\n        self.evaluations += 1\n\n        while self.evaluations < self.budget:\n            x_candidate = self.x_opt + self.step_size * np.random.normal(0, 1, size=self.dim)\n            x_candidate = np.clip(x_candidate, func.bounds.lb, func.bounds.ub)\n\n            f_candidate = func(x_candidate)\n            self.evaluations += 1\n\n            if f_candidate < self.f_opt:\n                self.f_opt = f_candidate\n                self.x_opt = x_candidate\n                self.successes += 1\n\n            # Adapt step size based on a moving average of success\n            if self.evaluations % 100 == 0:\n                success_rate = self.successes / 100\n                if success_rate > self.success_threshold:\n                    self.step_size *= (1 + self.step_size_multiplier)\n                else:\n                    self.step_size *= (1 - self.step_size_multiplier)\n                self.step_size = max(self.step_size, 1e-6)\n                self.successes = 0 # Reset successes counter\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveStepSizeES scored 0.268 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5110ab53-0119-46cc-8b2a-6250ca613a44"], "operator": null, "metadata": {"aucs": [0.006912448998758758, 0.10379015182852158, 0.5422066965494428, 0.17723392128431914, 0.14130839369134207, 0.11946466377302245, 0.16229119059212627, 0.17433276074194526, 0.1383874625396897, 0.17084349018785638, 0.8923808305517679, 0.1893212365795135, 0.2681351345292474, 0.15572115917317408, 0.17696708309993792, 0.36129393126801723, 0.31281277186374223, 0.7499624267431165, 0.11979787111388518, 0.39200320211029815]}}
{"id": "6a5ad6ee-62e2-4ce8-a47d-38cd0a187632", "fitness": 0.28051192873094916, "name": "AdaptiveStepSizeES", "description": "Adaptively adjusts the step size based on the moving average of fitness improvements, promoting exploration or exploitation.", "code": "import numpy as np\n\nclass AdaptiveStepSizeES:\n    def __init__(self, budget=10000, dim=10, initial_step_size=0.1, learning_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.step_size = initial_step_size\n        self.learning_rate = learning_rate\n        self.fitness_history = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.f_opt = func(self.x_opt)\n        self.fitness_history.append(self.f_opt)\n\n        for i in range(1, self.budget):\n            x_candidate = self.x_opt + self.step_size * np.random.normal(0, 1, size=self.dim)\n            x_candidate = np.clip(x_candidate, func.bounds.lb, func.bounds.ub)\n            f_candidate = func(x_candidate)\n\n            if f_candidate < self.f_opt:\n                self.f_opt = f_candidate\n                self.x_opt = x_candidate\n                self.fitness_history.append(self.f_opt)\n            else:\n                self.fitness_history.append(self.f_opt)\n\n\n            # Adapt step size based on fitness improvement\n            if len(self.fitness_history) > 1:\n                improvement = self.fitness_history[-2] - self.fitness_history[-1]\n                self.step_size *= np.exp(self.learning_rate * (improvement / abs(self.fitness_history[-2] + 1e-8))) # avoid division by zero\n                self.step_size = max(self.step_size, 1e-6)  # Ensure step size doesn't become too small\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveStepSizeES scored 0.281 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5110ab53-0119-46cc-8b2a-6250ca613a44"], "operator": null, "metadata": {"aucs": [0.08409424847722125, 0.19067749862064864, 0.40165803962679003, 0.1685566810924758, 0.1683063536578271, 0.12757887700567516, 0.2887096563115841, 0.3395555517407126, 0.33841345840644377, 0.13495859969408353, 0.5081903334440758, 0.12803679485774333, 0.27817500641138115, 0.18770008196394083, 0.8646504562530422, 0.3175460221995572, 0.2783793952789724, 0.5240030368122669, 0.12355471224050796, 0.15749377052403435]}}
{"id": "13a00eee-a595-457b-bdf4-47e8320568bf", "fitness": 0.6597633834353155, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with Archive and Stochastic Ranking, prioritizing computational efficiency and parameter reduction.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x_r1 = self.population[idxs[0]]\n                else:\n                    x_r1 = self.archive[idxs[0] - self.pop_size]\n                    \n                if idxs[1] < self.pop_size:\n                    x_r2 = self.population[idxs[1]]\n                else:\n                    x_r2 = self.archive[idxs[1] - self.pop_size]\n                    \n                if idxs[2] < self.pop_size:\n                    x_r3 = self.population[idxs[2]]\n                else:\n                    x_r3 = self.archive[idxs[2] - self.pop_size]\n\n                v = self.population[i] + self.F * (x_r1 - self.population[i]) + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection - comparing only objective values\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        # Replace random archive element\n                        self.archive[np.random.randint(self.archive_size)] = u\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm ADE_SR scored 0.660 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["38c76f28-a362-4234-b7aa-46347b1bcac9"], "operator": null, "metadata": {"aucs": [0.21367191040861833, 0.6482144930899418, 0.5582793883936896, 0.8802501605341111, 0.742620936641939, 0.7962068634790322, 0.6342955196509357, 0.7016826170232329, 0.7737942683611458, 0.23873296139394118, 0.8925716573993512, 0.9919478451560313, 0.5964806371494055, 0.7372729203255193, 0.9066131114909115, 0.7657296375850379, 0.5678998720398782, 0.8496370925924502, 0.20028108371886777, 0.4990846922722678]}}
{"id": "0f761397-9082-4e4d-9e8d-86ea104e74a4", "fitness": 0.7093084451189392, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with stochastic ranking and archive, removing fitness-based archive selection for simplicity and focusing on exploration.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=100, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member with probability 0.1\n                if np.random.rand() < 0.1 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (self.fitness[i] <= 0 and f_u <= 0) or (self.fitness[i] > 0 and f_u > 0 and f_u < self.fitness[i]):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update - simplified, just add without checking fitness\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm ADE_SR scored 0.709 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["38c76f28-a362-4234-b7aa-46347b1bcac9"], "operator": null, "metadata": {"aucs": [0.304572619180591, 0.6738882116420772, 0.7127076600563026, 0.8935926958896812, 0.7473209020378282, 0.7912505320666923, 0.6483051548621925, 0.6743649991811265, 0.7589487187734736, 0.7257199796275629, 0.8737716728129169, 0.9914187382570394, 0.6918976850839349, 0.7508815836377426, 0.9028390341057103, 0.7926504946832098, 0.6496456240918502, 0.8593822945399214, 0.24392755789128429, 0.49908274395764607]}}
{"id": "287ae0d7-4a30-46e7-b30a-48c4694bfd86", "fitness": 0.7000461696459359, "name": "Simplified_ADE_SR", "description": "Simplified Adaptive Differential Evolution with optional Archive and Stochastic Ranking, focusing on computational efficiency and reduced parameter tuning.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_rate=0.1, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_rate = archive_rate\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                # Add archive member with probability archive_rate\n                if np.random.rand() < self.archive_rate and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection:  Always replace if better, otherwise archive the replaced vector.\n                if f_u < self.fitness[i]:\n                    if len(self.archive) < self.pop_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        idx_replace = np.random.randint(len(self.archive))\n                        self.archive[idx_replace] = self.population[i].copy()\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                elif len(self.archive) < self.pop_size:\n                      self.archive.append(u.copy())\n                else:\n                    idx_replace = np.random.randint(len(self.archive))\n                    self.archive[idx_replace] = u.copy()\n\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm Simplified_ADE_SR scored 0.700 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["38c76f28-a362-4234-b7aa-46347b1bcac9"], "operator": null, "metadata": {"aucs": [0.30774522316300224, 0.6471875566407734, 0.6684818701420117, 0.8503729817416046, 0.7365725918087602, 0.7915867429328872, 0.6431389857997554, 0.6598384613294287, 0.7538597417484463, 0.7147803151735754, 0.8519825271142512, 0.9889878023550431, 0.6634515498922244, 0.7166529488449714, 0.9040171064698711, 0.7790255506674839, 0.6013580370046985, 0.8311663014991668, 0.3730561530670212, 0.5176609455237442]}}
{"id": "80c3545f-efe0-47eb-bfe3-a0ef3ae6745d", "fitness": -Infinity, "name": "SimplifiedCMAES", "description": "Simplified CMA-ES with reduced complexity and improved robustness.", "code": "import numpy as np\n\nclass SimplifiedCMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, sigma=0.3, restarts=3):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.sigma = sigma\n        self.popsize = popsize if popsize else int(4 + np.floor(3 * np.log(self.dim)))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1) - np.log(np.arange(1, self.mu + 1))\n        self.weights /= np.sum(self.weights)\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def sample_population(self, func, mean, covariance):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        x = mean + self.sigma * (z @ np.linalg.cholesky(covariance).T)\n        f = np.array([func(xi) for xi in x])\n        return x, f\n\n    def update_distribution(self, x, f, mean, covariance):\n        idx = np.argsort(f)[:self.mu]\n        xmean = np.sum(x[idx] * self.weights[:, np.newaxis], axis=0)\n        \n        diff = x[idx] - mean\n        covariance = np.cov(diff.T, aweights=self.weights, bias=True)\n        covariance = (covariance + covariance.T) / 2  # Ensure symmetry\n        \n        return xmean, covariance\n\n    def __call__(self, func):\n        mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        covariance = np.eye(self.dim)\n        used_budget = 0\n\n        for _ in range(self.restarts):\n            while used_budget + self.popsize <= self.budget:\n                x, f = self.sample_population(func, mean, covariance)\n                used_budget += self.popsize\n\n                if np.min(f) < self.f_opt:\n                    self.f_opt = np.min(f)\n                    self.x_opt = x[np.argmin(f)]\n\n                mean, covariance = self.update_distribution(x, f, mean, covariance)\n                \n            if used_budget >= self.budget:\n                break\n\n            mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n            covariance = np.eye(self.dim)\n            self.sigma *= 0.8 # Reduce step size after restart\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: Matrix is not positive definite.", "error": "", "parent_ids": ["8aad9235-1f2b-4f42-af39-e65cd64b7965"], "operator": null, "metadata": {}}
{"id": "8d70a2d5-eba7-4cd0-8a6d-dfd851175866", "fitness": 0.25207696403013574, "name": "AdaptiveStepSizeES", "description": "Adaptively adjusts step size based on the success rate, using a simplified update rule and resetting to the best seen solution upon failure to improve.", "code": "import numpy as np\n\nclass AdaptiveStepSizeES:\n    def __init__(self, budget=10000, dim=10, initial_step_size=0.1, success_threshold=0.2, step_size_multiplier=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.step_size = initial_step_size\n        self.success_threshold = success_threshold\n        self.step_size_multiplier = step_size_multiplier\n        self.x_best = None  # Initialize best solution found so far\n        self.f_best = np.inf\n\n    def __call__(self, func):\n        x = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        f = func(x)\n        self.x_best = x\n        self.f_best = f\n        \n        successes = 0\n        evaluations = 1\n\n        while evaluations < self.budget:\n            x_candidate = x + self.step_size * np.random.normal(0, 1, size=self.dim)\n            x_candidate = np.clip(x_candidate, func.bounds.lb, func.bounds.ub)\n            f_candidate = func(x_candidate)\n            evaluations += 1\n\n            if f_candidate < f:\n                x = x_candidate\n                f = f_candidate\n                successes += 1\n                if f < self.f_best:\n                  self.x_best = x\n                  self.f_best = f\n\n            else:\n                # Reset to best known position if no improvement\n                x = self.x_best\n                f = self.f_best  # Reset f too\n                \n\n            if evaluations % 100 == 0:\n                success_rate = successes / 100\n                if success_rate > self.success_threshold:\n                    self.step_size *= (1 + self.step_size_multiplier)\n                else:\n                    self.step_size *= (1 - self.step_size_multiplier)\n                self.step_size = max(self.step_size, 1e-6)\n                successes = 0\n\n        return self.f_best, self.x_best", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveStepSizeES scored 0.252 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5110ab53-0119-46cc-8b2a-6250ca613a44"], "operator": null, "metadata": {"aucs": [0.016967423776002577, 0.14826597558182553, 0.5372292121743738, 0.12790572135236167, 0.12081200934366876, 0.13565949793613985, 0.1756293556149745, 0.1287620598745729, 0.19402771513729744, 0.1015971160621515, 0.9086921187434209, 0.12511108306349017, 0.24700410092694747, 0.16953215221815154, 0.9367642648826917, 0.2843172977133068, 0.2694350297134138, 0.1448455087847086, 0.12497567230564088, 0.14400596539757393]}}
{"id": "bb89123c-5d61-4981-89ec-857731838700", "fitness": 0.2785216478943644, "name": "AdaptiveStepSizeES", "description": "Adaptively adjusts the step size based on success rate of updates, promoting exploration or exploitation with simplified step size adaptation.", "code": "import numpy as np\n\nclass AdaptiveStepSizeES:\n    def __init__(self, budget=10000, dim=10, initial_step_size=0.1, success_rate_threshold=0.2):\n        self.budget = budget\n        self.dim = dim\n        self.step_size = initial_step_size\n        self.success_rate_threshold = success_rate_threshold\n        self.successes = 0\n        self.trials = 0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.f_opt = func(self.x_opt)\n\n        for i in range(1, self.budget):\n            x_candidate = self.x_opt + self.step_size * np.random.normal(0, 1, size=self.dim)\n            x_candidate = np.clip(x_candidate, func.bounds.lb, func.bounds.ub)\n            f_candidate = func(x_candidate)\n\n            self.trials += 1\n            if f_candidate < self.f_opt:\n                self.f_opt = f_candidate\n                self.x_opt = x_candidate\n                self.successes += 1\n\n\n            # Adapt step size based on success rate\n            if self.trials > 10: # only adapt after a few trials\n                success_rate = self.successes / self.trials\n                if success_rate > self.success_rate_threshold:\n                    self.step_size *= 1.1  # Increase step size if success rate is high\n                else:\n                    self.step_size *= 0.9  # Decrease step size if success rate is low\n                self.step_size = max(self.step_size, 1e-6) # prevent step size from becoming too small.\n                self.successes = 0\n                self.trials = 0\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveStepSizeES scored 0.279 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6a5ad6ee-62e2-4ce8-a47d-38cd0a187632"], "operator": null, "metadata": {"aucs": [0.06875284367740919, 0.1770106954800431, 0.16652508873635397, 0.1502191056690777, 0.1317021133814642, 0.13908634389293728, 0.2062260323161803, 0.12158809184954822, 0.13471178154106178, 0.12367402514893822, 0.9599053200463782, 0.15783247078724216, 0.24069184399973043, 0.12491496839543836, 0.878609943829883, 0.2867347212319573, 0.30734475637376246, 0.9540949221088824, 0.09122764555085172, 0.1495802438701488]}}
{"id": "d4b99fb3-1b23-4fb0-84b4-63632ed6eb73", "fitness": 0.7130944688051984, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with stochastic acceptance based on fitness improvement ratio, simplifying archive management and selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n                \n                # Stochastic Acceptance\n                delta_f = self.fitness[i] - f_u\n                if delta_f > 0 or np.random.rand() < delta_f / abs(self.fitness[i]):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.713 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["287ae0d7-4a30-46e7-b30a-48c4694bfd86"], "operator": null, "metadata": {"aucs": [0.3388329073312508, 0.6709629938035979, 0.6745574290154246, 0.874933187917527, 0.7321792371983098, 0.7873990888934947, 0.6662885475013908, 0.6283441701522166, 0.7432021718572791, 0.6849844753244738, 0.8580828085033689, 0.9913619060887395, 0.6608843538952007, 0.7123537610251334, 0.9232683555746464, 0.7979998325647082, 0.6084525402553923, 0.8291300301766981, 0.5032621410161513, 0.5754094380089669]}}
{"id": "6a0fb7ce-d2a0-4f78-a0e1-92c6e3947206", "fitness": 0.7176507618427722, "name": "Simplified_ADE_SR", "description": "Simplified Adaptive Differential Evolution with Archive, removing stochastic ranking and focusing on a simpler update rule.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_rate=0.1, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_rate = archive_rate\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                # Add archive member with probability archive_rate\n                if np.random.rand() < self.archive_rate and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm Simplified_ADE_SR scored 0.718 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["287ae0d7-4a30-46e7-b30a-48c4694bfd86"], "operator": null, "metadata": {"aucs": [0.3604215255803942, 0.662750408325748, 0.6955458274949696, 0.8718113514760153, 0.7440496480437659, 0.7877481598562086, 0.6413010552488754, 0.6644249901087589, 0.7630439590131182, 0.6835715728030751, 0.8511720558778324, 0.9950332369729783, 0.6407634692179238, 0.7402711174989296, 0.9182190426402836, 0.7675885660067042, 0.6241623698824345, 0.8482891404125519, 0.566731495937276, 0.5261162444576033]}}
{"id": "0356a5fc-25af-4593-b1b7-5a6f394a8345", "fitness": 0.2620124137467291, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with Archive and Stochastic Ranking, focusing on computational efficiency by removing one differential vector and archive replacement based on fitness.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x_r1 = self.population[idxs[0]]\n                else:\n                    x_r1 = self.archive[idxs[0] - self.pop_size]\n                    \n                if idxs[1] < self.pop_size:\n                    x_r2 = self.population[idxs[1]]\n                else:\n                    x_r2 = self.archive[idxs[1] - self.pop_size]\n                    \n                \n                v = self.population[i] + self.F * (x_r1 - self.population[i]) + self.F * (x_r2 - self.population[i])\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection - comparing only objective values\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        # Replace random archive element\n                        self.archive[np.random.randint(self.archive_size)] = u\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR scored 0.262 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["13a00eee-a595-457b-bdf4-47e8320568bf"], "operator": null, "metadata": {"aucs": [0.11693358543660437, 0.2378935069342757, 0.2888705418409049, 0.1649153777742256, 0.1814000133580429, 0.20796988749191403, 0.24568254556823943, 0.26892799839446124, 0.20196994533680845, 0.1734084213742635, 0.1815718135455835, 0.9962114026427054, 0.26445731809361883, 0.1848147297513668, 0.14636580697464974, 0.2622768820427115, 0.24539268972694772, 0.22374238631094046, 0.1957587488784257, 0.4516846734578932]}}
{"id": "43fdd275-9656-4e1a-a6a1-f4dc4443c347", "fitness": 0.30979564898390305, "name": "Simplified_ADE_SR", "description": "Adaptive Differential Evolution with simplified archive handling and parameter adaptation based on success rate.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_rate=0.1, F=0.5, CR=0.9, F_step=0.1, CR_step=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_rate = archive_rate\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.F_step = F_step\n        self.CR_step = CR_step\n        self.success_count = 0\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        self.eval_count += self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            self.success_count_epoch = 0\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                # Add archive member with probability archive_rate\n                if np.random.rand() < self.archive_rate and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n                self.eval_count += 1\n\n                # Selection\n                if f_u < self.fitness[i]:\n                    self.success_count += 1\n                    self.success_count_epoch += 1\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                # Simplified Archive:  Replace random archive member.  If no archive, don't add.\n                elif len(self.archive) > 0:\n                    idx_replace = np.random.randint(len(self.archive))\n                    self.archive[idx_replace] = u.copy()\n\n\n                if self.budget <= 0:\n                    break\n            # Adaptive F and CR: adjust after each generation based on success rate\n            success_rate = self.success_count_epoch / self.pop_size\n            if success_rate > 0.2:\n                self.CR = min(1.0, self.CR + self.CR_step)\n                self.F = max(0.1, self.F - self.F_step)  # Reduce F for exploitation\n            else:\n                self.CR = max(0.0, self.CR - self.CR_step)\n                self.F = min(1.0, self.F + self.F_step)  # Increase F for exploration\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm Simplified_ADE_SR scored 0.310 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["287ae0d7-4a30-46e7-b30a-48c4694bfd86"], "operator": null, "metadata": {"aucs": [0.18220026604631034, 0.30553029986310143, 0.3051291575778209, 0.20671030687408465, 0.24843013444979367, 0.2399824272480534, 0.29885374948599375, 0.24519441275825726, 0.2259651701042068, 0.21427568307887424, 0.19279602414076802, 0.9931013630536936, 0.2560068708101012, 0.24286952985990584, 0.6376135928911593, 0.30641005235256236, 0.21324828703800547, 0.19951424541032636, 0.2075816881204231, 0.4744997185146179]}}
{"id": "9501c646-166a-4ef7-ae1d-bd4f6ccb1974", "fitness": 0.7209049344675955, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with stochastic ranking and archive, employing a reduced archive update frequency and population interaction for efficiency.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9, archive_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_prob = archive_prob\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member\n                if np.random.rand() < self.archive_prob and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (self.fitness[i] <= 0 and f_u <= 0) or (self.fitness[i] > 0 and f_u > 0 and f_u < self.fitness[i]):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update - simplified, less frequent\n                    if np.random.rand() < 0.2:  # Reduced update frequency\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            rand_idx = np.random.randint(self.archive_size)\n                            self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR scored 0.721 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0f761397-9082-4e4d-9e8d-86ea104e74a4"], "operator": null, "metadata": {"aucs": [0.30830653915777406, 0.6523041573323813, 0.6568370353404357, 0.8619759796083637, 0.7511176899398209, 0.8106150556123392, 0.6558094363110591, 0.7247852913944803, 0.750831511935093, 0.7081134669262952, 0.8551085489507496, 0.9935463456969121, 0.7319797863527792, 0.7593269400903303, 0.9212394462341758, 0.7963349952797529, 0.6542896307845631, 0.8553370550976868, 0.39230949368727797, 0.5779302836196398]}}
{"id": "67280e26-87fd-44ba-8437-92d7c7d2daa3", "fitness": 0.5870066407748015, "name": "ADE_SR", "description": "Adaptive Differential Evolution with Stochastic Ranking and simplified archive handling, focusing on parameter adaptation and simplified update mechanisms.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9, adapt_freq = 10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.adapt_freq = adapt_freq\n        self.F_history = []\n        self.CR_history = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n        \n        generation = 0\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x_r1 = self.population[idxs[0]]\n                else:\n                    x_r1 = self.archive[idxs[0] - self.pop_size]\n                    \n                if idxs[1] < self.pop_size:\n                    x_r2 = self.population[idxs[1]]\n                else:\n                    x_r2 = self.archive[idxs[1] - self.pop_size]\n                    \n                if idxs[2] < self.pop_size:\n                    x_r3 = self.population[idxs[2]]\n                else:\n                    x_r3 = self.archive[idxs[2] - self.pop_size]\n\n                v = self.population[i] + self.F * (x_r1 - x_r2) + self.F * (x_r3 - self.population[i])\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection - comparing only objective values\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        # Replace random archive element\n                        self.archive[np.random.randint(len(self.archive))] = self.population[i].copy()\n\n            if generation % self.adapt_freq == 0:\n                # Adapt F and CR\n                success_indices = np.where(self.fitness < self.fitness)[0] #all indices are success, since always replace if f_u < self.fitness[i]\n                if len(success_indices) > 0:\n                    self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                    self.CR = np.clip(np.random.normal(0.9, 0.2), 0.1, 1.0)\n                else:\n                    self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                    self.CR = np.clip(np.random.normal(0.9, 0.2), 0.1, 1.0)\n\n            generation += 1\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR scored 0.587 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["13a00eee-a595-457b-bdf4-47e8320568bf"], "operator": null, "metadata": {"aucs": [0.19512974470282585, 0.5267695109915811, 0.5076763846085663, 0.764267243998219, 0.6742470925101227, 0.7420717956371435, 0.44816756540481106, 0.5357878252529064, 0.6563409781415763, 0.19619369216830884, 0.681982085132991, 0.9962830466243494, 0.5520365349673182, 0.6531987736674756, 0.7902468174552538, 0.734019251955575, 0.5292398476933946, 0.8271344208626206, 0.23317991145862738, 0.4961602922623609]}}
{"id": "e67d8ac7-6f57-4445-b0d9-c27fdcf62512", "fitness": 0.6959710173757391, "name": "ADE_SR", "description": "Further simplifies ADE_SR by removing the archive and adjusting F and CR dynamically based on success rate for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, F_adapt_rate=0.1, CR_adapt_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.F_adapt_rate = F_adapt_rate\n        self.CR_adapt_rate = CR_adapt_rate\n        self.success_F = []\n        self.success_CR = []\n        self.archive = [] # Removed archive\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            successful_mutations = 0  # Count successful mutations for F/CR adaptation\n            temp_success_F = []\n            temp_success_CR = []\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                v = x_r1 + self.F * (x_r2 - x_r3) # Removed archive influence\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (self.fitness[i] <= 0 and f_u <= 0) or (self.fitness[i] > 0 and f_u > 0 and f_u < self.fitness[i]):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    successful_mutations += 1\n                    temp_success_F.append(self.F)\n                    temp_success_CR.append(self.CR)\n\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                if self.budget <= 0:\n                    break\n            # Adapt F and CR\n            if successful_mutations > 0:\n                self.success_F.extend(temp_success_F)\n                self.success_CR.extend(temp_success_CR)\n\n            if len(self.success_F) > 0:\n\n                mean_F = np.mean(self.success_F)\n                mean_CR = np.mean(self.success_CR)\n\n                self.F = self.F * (1 - self.F_adapt_rate) + mean_F * self.F_adapt_rate\n                self.CR = self.CR * (1 - self.CR_adapt_rate) + mean_CR * self.CR_adapt_rate\n\n                self.success_F = []\n                self.success_CR = []\n\n            self.F = np.clip(self.F, 0.1, 1.0) # Keep F within reasonable bounds\n            self.CR = np.clip(self.CR, 0.1, 1.0) # Keep CR within reasonable bounds\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR scored 0.696 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0f761397-9082-4e4d-9e8d-86ea104e74a4"], "operator": null, "metadata": {"aucs": [0.3016434826878033, 0.6523108751169797, 0.6818411602573433, 0.8620955940964177, 0.7591232468457764, 0.7678753445315333, 0.6446067602416538, 0.6728092955976008, 0.7330678701969975, 0.66557232616467, 0.8584820389390089, 0.9889036632415327, 0.6537391678092894, 0.7447233640071289, 0.9202484486618623, 0.7701229798145307, 0.6452276969458934, 0.8579915077591566, 0.22524446998327974, 0.5137910546163257]}}
{"id": "816766f3-65c7-4910-8cbb-6aab9c07b52d", "fitness": 0.7212924802410519, "name": "ADE_SR", "description": "Adaptive Differential Evolution with simplified archive handling and parameter adaptation based on success rate for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9, F_adapt=True, CR_adapt=True):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.F_adapt = F_adapt\n        self.CR_adapt = CR_adapt\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            successful_mutations = 0\n            temp_success_F = []\n            temp_success_CR = []\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member with probability 0.1\n                if np.random.rand() < 0.1 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (self.fitness[i] <= 0 and f_u <= 0) or (self.fitness[i] > 0 and f_u > 0 and f_u < self.fitness[i]):\n                    successful_mutations += 1\n                    temp_success_F.append(self.F)\n                    temp_success_CR.append(self.CR)\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update - simplified, just add without checking fitness\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n\n                if self.budget <= 0:\n                    break\n            \n            #Adapt F and CR parameters\n            if self.F_adapt and len(temp_success_F) > 0:\n                self.F = np.mean(temp_success_F)\n                self.F = np.clip(self.F, 0.1, 0.9)\n\n            if self.CR_adapt and len(temp_success_CR) > 0:\n                self.CR = np.mean(temp_success_CR)\n                self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            if self.budget <= 0:\n                break\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR scored 0.721 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0f761397-9082-4e4d-9e8d-86ea104e74a4"], "operator": null, "metadata": {"aucs": [0.36708832166122807, 0.6974313555563219, 0.7191578686037637, 0.8934752589093843, 0.7590772074723574, 0.7963952647541194, 0.6216046617776183, 0.689817303455347, 0.7666358951678244, 0.6777373214035426, 0.863986396055267, 1.0, 0.6932292371313986, 0.747784333774039, 0.9182965537327404, 0.8124017146315927, 0.6661490553350412, 0.8438009734041928, 0.3279115738553233, 0.5638693081399353]}}
{"id": "1810e071-34da-4305-bbf3-5253a32988bb", "fitness": 0.4158045516745174, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with stochastic ranking and adaptive parameters, focusing on core DE operations and parameter self-adaptation for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F_mu=0.5, CR_mu=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F_mu = F_mu\n        self.CR_mu = CR_mu\n        self.archive = []\n        self.F_list = np.ones(pop_size) * F_mu\n        self.CR_list = np.ones(pop_size) * CR_mu\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Parameter Adaptation\n                self.F_list[i] = np.clip(np.random.normal(self.F_mu, 0.1), 0.1, 1.0)\n                self.CR_list[i] = np.clip(np.random.normal(self.CR_mu, 0.1), 0.1, 1.0)\n                F = self.F_list[i]\n                CR = self.CR_list[i]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                \n                if idxs[0] < self.pop_size:\n                    x_r1 = self.population[idxs[0]]\n                else:\n                    x_r1 = self.archive[idxs[0] - self.pop_size]\n                    \n                if idxs[1] < self.pop_size:\n                    x_r2 = self.population[idxs[1]]\n                else:\n                    x_r2 = self.archive[idxs[1] - self.pop_size]\n                    \n                if idxs[2] < self.pop_size:\n                    x_r3 = self.population[idxs[2]]\n                else:\n                    x_r3 = self.archive[idxs[2] - self.pop_size]\n\n                v = self.population[i] + F * (x_r1 - x_r2) + F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection - comparing only objective values\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n                        \n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        # Replace random archive element\n                        self.archive[np.random.randint(self.archive_size)] = u\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR scored 0.416 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["13a00eee-a595-457b-bdf4-47e8320568bf"], "operator": null, "metadata": {"aucs": [0.1542937122105199, 0.2869090552958805, 0.3828559920557466, 0.5740048264230395, 0.3168290275931015, 0.4399192472662017, 0.2964459352162241, 0.35671809979756286, 0.3160932597059386, 0.18329614369067015, 0.5651890667263377, 0.9985326299767232, 0.39011362824421025, 0.3053250579071126, 0.789162659221596, 0.43767065336159683, 0.3249486044352923, 0.5169717823399944, 0.1905344598999147, 0.4902771921226865]}}
{"id": "ac25f071-f6e5-4590-9e94-952336c7add5", "fitness": 0.6053004044981689, "name": "ADE_SR", "description": "Adaptive Differential Evolution with Stochastic Ranking based on feasibility and objective value, using a simplified archive update and mutation strategy for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n\n                v = self.population[i] + self.F * (x_r1 - x_r2) + self.F * (x_r3 - self.population[i])\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, self.lb, self.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (f_u < self.fitness[i]):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u\n\n                    # Simplified archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    elif np.random.rand() < 0.1:  #Probabilistic archive update\n                        self.archive[np.random.randint(self.archive_size)] = u\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR scored 0.605 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["13a00eee-a595-457b-bdf4-47e8320568bf"], "operator": null, "metadata": {"aucs": [0.22480234157054135, 0.7705780545982394, 0.3872941495714366, 0.8606530489891377, 0.7755123987829854, 0.5986399673437001, 0.6242924876525779, 0.7088623189312142, 0.7969821773166046, 0.614709735159693, 0.40313447584115814, 0.9948328970841694, 0.3610330906267615, 0.6634483201094231, 0.7224092659981189, 0.34909279467360566, 0.6386681743303797, 0.8524057825607352, 0.2570334223955342, 0.5016231864273609]}}
{"id": "b711590d-d9b0-43e8-8c68-345af8cfbf72", "fitness": 0.7113786769858286, "name": "ADE_SR_AdaptiveF", "description": "Simplified Adaptive Differential Evolution with Stochastic Ranking and adaptive F, focusing on parameter adaptation for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass ADE_SR_AdaptiveF:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F_initial=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F_initial\n        self.CR = CR\n        self.archive = []\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member with probability 0.1\n                if np.random.rand() < 0.1 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking\n                if (self.fitness[i] <= 0 and f_u <= 0) or (self.fitness[i] > 0 and f_u > 0 and f_u < self.fitness[i]):\n                    delta = abs(self.fitness[i] - f_u) # Store delta f for F adaptation\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update - simplified, just add without checking fitness\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n                    \n                    # Adaptive F update based on success\n                    self.success_F.append(self.F)\n\n                if self.budget <= 0:\n                    break\n            \n            #Adapt F using successful values\n            if self.success_F:\n                 self.F = np.mean(self.success_F) \n                 self.success_F = []\n            else: # If no success, increase F to promote exploration\n                self.F = min(self.F * 1.1, 1.0)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm ADE_SR_AdaptiveF scored 0.711 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0f761397-9082-4e4d-9e8d-86ea104e74a4"], "operator": null, "metadata": {"aucs": [0.3190266422139073, 0.6939401895120019, 0.6733539479790525, 0.8818432618108236, 0.7630062053505601, 0.797429297958639, 0.6348037244602349, 0.7011946882021279, 0.7515212520216917, 0.7304215286100431, 0.8728723110848221, 0.9986805498149602, 0.699269589124971, 0.7359790432296108, 0.9193702793794469, 0.7946165672300849, 0.6349668673169897, 0.8649002764856679, 0.24380478149311513, 0.516572536437821]}}
{"id": "48bfd3f8-d752-41ae-940f-389083088a61", "fitness": 0.0, "name": "ADE_SR_Simplified", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on successful mutations and periodic population rejuvenation for enhanced exploration.", "code": "import numpy as np\n\nclass ADE_SR_Simplified:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9, F_adapt=True, CR_adapt=True, refresh_rate=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.F_adapt = F_adapt\n        self.CR_adapt = CR_adapt\n        self.refresh_rate = refresh_rate  # Added population refresh rate\n        self.generation = 0  # Track the current generation\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            self.generation += 1\n            successful_mutations = 0\n            temp_success_F = []\n            temp_success_CR = []\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                \n                # Add archive member with probability 0.1\n                if np.random.rand() < 0.1 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n                \n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection - directly replace if better\n                if f_u < self.fitness[i]:\n                    successful_mutations += 1\n                    temp_success_F.append(self.F)\n                    temp_success_CR.append(self.CR)\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update - simplified, just add without checking fitness\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR parameters using successful mutations\n            if self.F_adapt and len(temp_success_F) > 0:\n                self.F = 0.9 * self.F + 0.1 * np.mean(temp_success_F)  # Smoothed average\n                self.F = np.clip(self.F, 0.1, 0.9)\n\n            if self.CR_adapt and len(temp_success_CR) > 0:\n                self.CR = 0.9 * self.CR + 0.1 * np.mean(temp_success_CR)  # Smoothed average\n                self.CR = np.clip(self.CR, 0.1, 0.9)\n            \n            # Periodically refresh the population\n            if self.generation % self.refresh_rate == 0:\n                num_to_replace = int(0.1 * self.pop_size) # replace 10% of the population\n                indices_to_replace = np.random.choice(self.pop_size, num_to_replace, replace=False)\n                self.population[indices_to_replace] = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(num_to_replace, self.dim))\n                self.fitness[indices_to_replace] = np.array([func(x) for x in self.population[indices_to_replace]])\n\n                for i in indices_to_replace:\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n            \n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm ADE_SR_Simplified scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["816766f3-65c7-4910-8cbb-6aab9c07b52d"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "9ae47e1a-b868-4979-b616-8a8ee0d3740f", "fitness": 0.7024633933080121, "name": "Simplified_ADE_SR", "description": "Simplified Adaptive Differential Evolution with reduced parameter set, enhanced mutation and greedy selection.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm Simplified_ADE_SR scored 0.702 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6a0fb7ce-d2a0-4f78-a0e1-92c6e3947206"], "operator": null, "metadata": {"aucs": [0.311999018130411, 0.6729156772942744, 0.6682256033410302, 0.8722951091867125, 0.7404111460625469, 0.7822582472044334, 0.6529129430139684, 0.6653359829890981, 0.7290975133340343, 0.6619814905955985, 0.8430648576033792, 0.99406901004809, 0.6771765474461673, 0.7409505213734006, 0.9207096277453691, 0.7680120043984683, 0.6119907195013127, 0.8529518513447165, 0.2843733984530502, 0.5985365970941818]}}
{"id": "b0ba1e50-1f95-4249-90c8-73beae6245d9", "fitness": 0.7633770533404952, "name": "AdaptiveDE", "description": "Streamlined Differential Evolution with simplified parameter adaptation and reduced function evaluations by skipping fitness re-evaluation when offspring is identical to parent.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Check if the offspring is identical to the parent\n                if np.array_equal(u, self.population[i]):\n                    continue\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.763 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d4b99fb3-1b23-4fb0-84b4-63632ed6eb73"], "operator": null, "metadata": {"aucs": [0.40830645960965284, 0.7586053844522267, 0.7679044699300291, 0.8978994727050174, 0.7935948288571768, 0.8352835282659088, 0.7348885245757033, 0.739407039561731, 0.8098811765514892, 0.7378203435231058, 0.8915008736170397, 0.9972096780186648, 0.7110264684539362, 0.7756269472288806, 0.9365159629537659, 0.817943056099186, 0.7188495229651218, 0.8743059267073806, 0.5498672877763748, 0.5111041149575126]}}
{"id": "342b733c-f323-4672-8c67-79f8f47921fb", "fitness": 0.6992949560151398, "name": "Simplified_ADE_SR", "description": "Simplified Adaptive Differential Evolution with Archive and reduced parameter set, employing a fixed mutation factor and crossover rate for computational efficiency.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_rate=0.1, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_rate = archive_rate\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                # Add archive member with probability archive_rate\n                if np.random.rand() < self.archive_rate and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                    \n                    # Update Archive: Add replaced individuals to archive\n                    if len(self.archive) < self.pop_size * 2: #Archive size limit\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(len(self.archive))] = self.population[i].copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm Simplified_ADE_SR scored 0.699 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6a0fb7ce-d2a0-4f78-a0e1-92c6e3947206"], "operator": null, "metadata": {"aucs": [0.3443439569103618, 0.6839857895622469, 0.6916646364751249, 0.8736337002283481, 0.7272321129691446, 0.7804569012826992, 0.6185340570754385, 0.6749068948042447, 0.7521155554595347, 0.6558010576231244, 0.8574012608864399, 0.9918655131971621, 0.688808898756341, 0.7342622682546543, 0.9205378624211858, 0.7690795221783386, 0.6432642251406151, 0.8393814974178266, 0.2226919933255208, 0.5159314163344422]}}
{"id": "62f60805-a66e-43de-aef0-34d55f1408f4", "fitness": 0.4689372555904619, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive scaling factor and population size reduction over iterations for efficient exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, reduction_factor=0.95):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.reduction_factor = reduction_factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            new_population = []\n            new_fitness = []\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                \n                # Adaptive F\n                F_adaptive = self.F * (1 + np.random.normal(0, 0.1))\n                v = x_r1 + F_adaptive * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n                \n                # Greedy selection: Always replace if better\n                if f_u < self.fitness[i]:\n                    new_population.append(u)\n                    new_fitness.append(f_u)\n                else:\n                    new_population.append(self.population[i])\n                    new_fitness.append(self.fitness[i])\n                \n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n            \n            self.population = np.array(new_population)\n            self.fitness = np.array(new_fitness)\n\n            # Reduce population size\n            if self.budget > 0:\n                self.pop_size = int(self.pop_size * self.reduction_factor)\n                self.pop_size = max(10, self.pop_size)  # Minimum population size\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.469 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d4b99fb3-1b23-4fb0-84b4-63632ed6eb73"], "operator": null, "metadata": {"aucs": [0.24525180348865894, 0.3417649203551899, 0.3033905788294341, 0.5063956539958158, 0.3298452509042473, 0.45422557360113236, 0.5367931836889128, 0.5340605188172309, 0.569450693416244, 0.33246287684885834, 0.3858141157315096, 0.987448938292894, 0.3345693947510925, 0.33911830286506794, 0.682084312548301, 0.3580905753710485, 0.48055331016912384, 0.9174742191668428, 0.20279703076522815, 0.5371538582024044]}}
{"id": "89a1af46-be92-438b-8e89-3dd4a6033a49", "fitness": 0.7085070459631762, "name": "ADE_SR", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on the Lehmer mean of successful parameters and reduced archive interaction for efficiency.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=25, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            successful_F = []\n            successful_CR = []\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Archive interaction with reduced probability\n                if np.random.rand() < 0.05 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection\n                if f_u < self.fitness[i]:\n                    successful_F.append(self.F)\n                    successful_CR.append(self.CR)\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR using Lehmer mean\n            if successful_F:\n                self.F = np.sum(np.array(successful_F)**2) / np.sum(successful_F)\n                self.F = np.clip(self.F, 0.1, 0.9)\n            if successful_CR:\n                self.CR = np.sum(np.array(successful_CR)**2) / np.sum(successful_CR)\n                self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm ADE_SR scored 0.709 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["816766f3-65c7-4910-8cbb-6aab9c07b52d"], "operator": null, "metadata": {"aucs": [0.2825397737201212, 0.6991490174927297, 0.661248896603023, 0.8687218123324718, 0.7567533452766433, 0.8053643763961928, 0.6839804013877666, 0.6441933100280026, 0.7483024106073481, 0.6974348539831994, 0.8525838416419697, 0.9990873016971598, 0.6321250059569808, 0.7429241095753933, 0.906319907512466, 0.7662926815854263, 0.6378713243517293, 0.8579947098702515, 0.31374631767669703, 0.6135075215679506]}}
{"id": "1e177afd-5f17-4fae-bd61-3e6c14b62c21", "fitness": 0.4143367807796053, "name": "Simplified_ADE_SR", "description": "Simplified Adaptive Differential Evolution with archive and parameter adaptation based on population diversity, enhancing exploration-exploitation balance through dynamic control parameter adjustments.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_rate=0.1, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_rate = archive_rate\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            # Parameter adaptation based on population diversity\n            diversity = np.std(self.population)\n            self.F = 0.5 + 0.3 * diversity  # Adjust F based on diversity\n            self.CR = 0.9 - 0.2 * diversity # Adjust CR based on diversity\n            self.F = np.clip(self.F, 0.1, 0.9)\n            self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                # Add archive member with probability archive_rate\n                if np.random.rand() < self.archive_rate and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                # Update archive\n                if np.random.rand() < self.archive_rate:\n                    self.archive.append(self.population[i].copy())\n                    if len(self.archive) > self.pop_size:\n                        self.archive.pop(0)\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm Simplified_ADE_SR scored 0.414 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6a0fb7ce-d2a0-4f78-a0e1-92c6e3947206"], "operator": null, "metadata": {"aucs": [0.17289591948713878, 0.23671985531505468, 0.3935130777507515, 0.5021821399576709, 0.3745759248015421, 0.531800678467806, 0.30997909299371385, 0.3961439117117135, 0.41322136808564625, 0.2116743721275216, 0.33603765474381964, 0.9824554876210565, 0.232484680900242, 0.3243785849657901, 0.7495074129845929, 0.5303906418070776, 0.3176949028045185, 0.5916348616385625, 0.186204695367862, 0.49324035206002426]}}
{"id": "c1ac781e-55ed-4948-97e9-6846bd31e6eb", "fitness": 0.3528141762485232, "name": "ADE_SR", "description": "Adaptive Differential Evolution with a simplified stochastic ranking, archive, and parameter adaptation based on population diversity for enhanced exploration.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9, archive_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_prob = archive_prob\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index]\n\n        while self.budget > 0:\n            # Adapt F and CR based on population diversity\n            diversity = np.std(self.population)\n            self.F = 0.5 + 0.3 * diversity  # Modulate F based on diversity\n            self.CR = 0.9 - 0.2 * diversity  # Modulate CR based on diversity\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member\n                if np.random.rand() < self.archive_prob and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Simplified Stochastic Ranking: compare only if improved\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update - simplified, less frequent\n                    if np.random.rand() < 0.2:  # Reduced update frequency\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            rand_idx = np.random.randint(self.archive_size)\n                            self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm ADE_SR scored 0.353 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9501c646-166a-4ef7-ae1d-bd4f6ccb1974"], "operator": null, "metadata": {"aucs": [0.13903931674124448, 0.18145135907157783, 0.4003872902183091, 0.3046740412432619, 0.30211179117119813, 0.37699799562658254, 0.28816535943822674, 0.3679275907426214, 0.2929059842395152, 0.18798443157575406, 0.2658176378490491, 0.9849690618071714, 0.25271440925171285, 0.2769355614625735, 0.7026848353027864, 0.3902310833757895, 0.2826020821094688, 0.40136138245532016, 0.1716439111463235, 0.4856784001419774]}}
{"id": "eb844ca2-4fa2-4839-baf6-a68ddf8442ff", "fitness": 0.6780026271066157, "name": "ADE_SR", "description": "Adaptive Differential Evolution with simplified adaptation, archive handling, and population-level parameter update for faster convergence.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            # Mutation and Crossover\n            mutated_population = np.zeros_like(self.population)\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member with probability 0.1\n                if np.random.rand() < 0.1 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n                mutated_population[i] = u\n            \n            # Evaluation\n            mutated_fitness = np.array([func(x) for x in mutated_population])\n            self.budget -= self.pop_size\n            if self.budget <=0:\n                mutated_fitness = mutated_fitness[:self.pop_size + self.budget]\n                mutated_population = mutated_population[:self.pop_size + self.budget]\n                \n            # Selection\n            for i in range(len(mutated_fitness)):\n\n                if mutated_fitness[i] < self.fitness[i]:\n                    self.population[i] = mutated_population[i]\n                    self.fitness[i] = mutated_fitness[i]\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n                    \n                    # Archive update - simplified, just add without checking fitness\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        # Replace a random element in the archive\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n            #Adapt F and CR parameters - Population Level\n            success = (mutated_fitness < self.fitness[:len(mutated_fitness)])\n            if np.any(success):\n              self.F = 0.9 * self.F + 0.1 * np.mean(self.F * success)\n              self.CR = 0.9 * self.CR + 0.1 * np.mean(self.CR * success)\n              self.F = np.clip(self.F, 0.1, 0.9)\n              self.CR = np.clip(self.CR, 0.1, 0.9)\n            \n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm ADE_SR scored 0.678 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["816766f3-65c7-4910-8cbb-6aab9c07b52d"], "operator": null, "metadata": {"aucs": [0.32003449602044143, 0.6380410872741757, 0.6867473050009866, 0.8547693229905446, 0.725712402706924, 0.7516035046888193, 0.6001029395529576, 0.6440439719613946, 0.6967977262951377, 0.6029843551476415, 0.8414879357089456, 0.9979057954440621, 0.6462514952148051, 0.6981391717837524, 0.8849820101956276, 0.7538793720689061, 0.5904885123119512, 0.8234435178430006, 0.24049848586179357, 0.5621391340604474]}}
{"id": "c69370fb-2e3b-417e-a657-3382e145df48", "fitness": 0.7785775083941848, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive CR and F, employing a smaller population size and simplified stochastic acceptance for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Adaptive F and CR\n                F = np.random.normal(0.5, 0.1)\n                CR = np.random.normal(0.9, 0.1)\n                F = np.clip(F, 0.1, 1.0)\n                CR = np.clip(CR, 0.1, 1.0)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n                \n                # Stochastic Acceptance - Simplified\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.779 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d4b99fb3-1b23-4fb0-84b4-63632ed6eb73"], "operator": null, "metadata": {"aucs": [0.635067548752732, 0.8601755777133063, 0.8146746011554189, 0.9140269593486705, 0.8670886657448421, 0.8816048073264726, 0.7939784129905265, 0.8456099865846612, 0.8747274512842773, 0.8133443049555312, 0.9310395568116999, 0.9969825592706897, 0.39028175555733, 0.8418540631467504, 0.889938815987131, 0.8715993463069545, 0.3385286878265008, 0.921942552364284, 0.26423633174630345, 0.8248481830096149]}}
{"id": "ca86e21f-c2b3-45ac-9fb1-3a65f40e15ce", "fitness": 0.701738193352017, "name": "ADE_SR", "description": "Adaptive Differential Evolution with simplified mutation, archive, and parameter control using a success-history based adaptation.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.sf = []\n        self.scr = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index]\n\n        while self.budget > 0:\n            successful_F = []\n            successful_CR = []\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Simplified mutation\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection\n                if f_u < self.fitness[i]:\n                    successful_F.append(self.F)\n                    successful_CR.append(self.CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u)\n                    else:\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = u\n\n                if self.budget <= 0:\n                    break\n            #Adapt F and CR\n            if successful_F:\n                self.sf.extend(successful_F)\n                self.scr.extend(successful_CR)\n                self.F = np.mean(successful_F) if successful_F else 0.5\n                self.CR = np.mean(successful_CR) if successful_CR else 0.9\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm ADE_SR scored 0.702 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9501c646-166a-4ef7-ae1d-bd4f6ccb1974"], "operator": null, "metadata": {"aucs": [0.32629289835318154, 0.6609998443515488, 0.7239023306501984, 0.8787806369400104, 0.7227671403362235, 0.7798017776619995, 0.6161281696549228, 0.6844798510789221, 0.7399843041995284, 0.6929814783574472, 0.8585689771516214, 0.9977902631013537, 0.6723871648733359, 0.7268913509796192, 0.9267458944839281, 0.7869400822799896, 0.626188455011208, 0.8343501020430629, 0.25676197310557514, 0.522021172426663]}}
{"id": "de5a15f9-5dc9-4fa3-a8e2-0a02a21c59c4", "fitness": 0.6858235465275883, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with stochastic ranking, reduced archive updates, and simplified parameter adaptation based on population diversity.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, F=0.5, CR=0.9, archive_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_prob = archive_prob\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index]\n\n        while self.budget > 0:\n            # Parameter adaptation based on population diversity\n            std = np.std(self.population)\n            self.F = np.clip(np.random.normal(0.5, 0.3 * std, 1)[0], 0.1, 1.0)  # Adaptive F\n            self.CR = np.clip(np.random.normal(0.9, 0.2 * std, 1)[0], 0.1, 1.0)  # Adaptive CR\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Add archive member\n                if np.random.rand() < self.archive_prob and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection using stochastic ranking (simplified)\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update - simplified, less frequent\n                    if np.random.rand() < 0.1:  # Further reduced update frequency\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            rand_idx = np.random.randint(self.archive_size)\n                            self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm ADE_SR scored 0.686 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9501c646-166a-4ef7-ae1d-bd4f6ccb1974"], "operator": null, "metadata": {"aucs": [0.42862059181813794, 0.6813840104240498, 0.675589107526066, 0.8548132791238559, 0.711988601668406, 0.769785431397777, 0.6462343891353812, 0.6287140119454815, 0.7103566905517019, 0.5764309097903775, 0.8104227916631478, 0.9995014740301811, 0.5392564536762157, 0.695070772043585, 0.8813579776480329, 0.7756583952307545, 0.5601631558009146, 0.8327730630379243, 0.4416623011379477, 0.4966875229018265]}}
{"id": "60f09f6a-cadb-4292-9568-ef6033652ec9", "fitness": 0.0, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation and crossover, combined with periodic population rejuvenation to escape local optima.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, refresh_interval=500):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.refresh_interval = refresh_interval\n        self.eval_count = 0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.eval_count += self.pop_size\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Simplified Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                v = self.population[i] + self.F * (x_r1 - x_r2)\n\n                # Simplified Crossover\n                mask = np.random.rand(self.dim) < self.CR\n                v[mask] = self.population[i, mask] #Inherit from parent if crossover fails\n                v[np.random.randint(self.dim)] = self.population[i, np.random.randint(self.dim)] #Ensure that v is different to population[i]\n\n                # Boundary handling\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_v = func(v)\n                self.eval_count += 1\n                self.budget -= 1\n                \n\n                if f_v < self.fitness[i]:\n                    self.population[i] = v\n                    self.fitness[i] = f_v\n\n                    if f_v < self.f_opt:\n                        self.f_opt = f_v\n                        self.x_opt = v.copy()\n            \n            if self.eval_count // self.pop_size > 0 and self.eval_count % self.refresh_interval==0:  # Refresh population every refresh_interval evaluations\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = np.random.uniform(func.bounds.lb, func.bounds.ub)\n                self.fitness[worst_idx] = func(self.population[worst_idx])\n                self.eval_count += 1\n                self.budget -= 1\n\n                best_idx = np.argmin(self.fitness)\n                self.f_opt = self.fitness[best_idx]\n                self.x_opt = self.population[best_idx]\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b0ba1e50-1f95-4249-90c8-73beae6245d9"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "333b3425-f2bf-47c0-9060-78c132bd8b74", "fitness": 0.0, "name": "AdaptiveDE_SR", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced archive interaction, enhanced by adaptive population sizing based on success rate.", "code": "import numpy as np\n\nclass AdaptiveDE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=25, F=0.5, CR=0.9, adapt_pop_interval=500):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.adapt_pop_interval = adapt_pop_interval\n        self.success_rate = 0.0\n        self.success_history = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        evals = self.pop_size\n        generation = 0\n\n        while self.budget > 0:\n            generation += 1\n            successful_F = []\n            successful_CR = []\n            successful_mutations = 0\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Archive interaction with reduced probability\n                if np.random.rand() < 0.05 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n                evals += 1\n\n                # Selection\n                if f_u < self.fitness[i]:\n                    successful_F.append(self.F)\n                    successful_CR.append(self.CR)\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    successful_mutations += 1\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR using Lehmer mean\n            if successful_F:\n                self.F = np.sum(np.array(successful_F)**2) / np.sum(successful_F)\n                self.F = np.clip(self.F, 0.1, 0.9)\n            if successful_CR:\n                self.CR = np.sum(np.array(successful_CR)**2) / np.sum(successful_CR)\n                self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            # Adapt population size\n            self.success_rate = successful_mutations / self.pop_size\n            self.success_history.append(self.success_rate)\n\n            if generation * self.pop_size > self.adapt_pop_interval:\n                avg_success = np.mean(self.success_history[-5:]) if len(self.success_history) >= 5 else np.mean(self.success_history)\n                if avg_success > 0.25:\n                    self.pop_size = min(self.pop_size + 5, 100)\n                elif avg_success < 0.1:\n                    self.pop_size = max(self.pop_size - 5, 10)\n                \n                # Resize population\n                new_population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n                new_population[:len(self.population)] = self.population\n                self.population = new_population\n                self.fitness = np.array([func(x) for x in self.population])\n                self.budget -= (self.pop_size - len(self.population)) if (self.pop_size > len(self.population)) else 0\n\n                for i in range(self.pop_size):\n                   if self.fitness[i] < self.f_opt:\n                       self.f_opt = self.fitness[i]\n                       self.x_opt = self.population[i]\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE_SR scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["89a1af46-be92-438b-8e89-3dd4a6033a49"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "f5176931-41d6-408c-8d09-a69bda6abe3c", "fitness": 0.4259611314578485, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with adaptive F and CR, reduced population size, and vectorized operations for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            idxs = np.random.randint(0, self.pop_size, size=(self.pop_size, 3))\n            x_r1 = self.population[idxs[:, 0]]\n            x_r2 = self.population[idxs[:, 1]]\n            x_r3 = self.population[idxs[:, 2]]\n\n            v = self.population + self.F * (x_r1 - x_r2 + x_r3 - self.population) # Simplified DE mutation\n            v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n            j_rand = np.random.randint(0, self.dim, size=self.pop_size)\n            u = np.copy(self.population)\n            \n            mask = np.random.rand(self.pop_size, self.dim) < self.CR\n            for i in range(self.pop_size):\n                mask[i, j_rand[i]] = True  # Ensure at least one element changes\n\n            u[mask] = v[mask]  # Vectorized crossover\n\n            # Evaluate only changed individuals (speedup)\n            needs_evaluation = ~np.all(u == self.population, axis=1)\n            num_evaluations = np.sum(needs_evaluation)\n\n            if self.budget < num_evaluations:\n                needs_evaluation_indices = np.where(needs_evaluation)[0]\n                evaluate_indices = needs_evaluation_indices[:self.budget]\n                u_eval = u[evaluate_indices]\n                f_u = np.array([func(x) for x in u_eval])\n                needs_evaluation = np.zeros(self.pop_size, dtype=bool)\n                needs_evaluation[evaluate_indices] = True\n                f_u_full = np.full(self.pop_size, np.inf)  # Initialize with a large value\n                f_u_full[evaluate_indices] = f_u\n\n                self.budget = 0  # Break the loop\n\n            else:\n                u_eval = u[needs_evaluation]\n                f_u = np.array([func(x) for x in u_eval])\n                f_u_full = np.full(self.pop_size, np.inf)\n                f_u_full[needs_evaluation] = f_u\n\n                self.budget -= num_evaluations\n\n            improvement = f_u_full < self.fitness\n            self.population[improvement] = u[improvement]\n            self.fitness[improvement] = f_u_full[improvement]\n\n            best_idx = np.argmin(self.fitness)\n            if self.fitness[best_idx] < self.f_opt:\n                self.f_opt = self.fitness[best_idx]\n                self.x_opt = self.population[best_idx]\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.426 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b0ba1e50-1f95-4249-90c8-73beae6245d9"], "operator": null, "metadata": {"aucs": [0.40865476302759385, 0.2174599037038032, 0.39572823008475577, 0.47118690437119803, 0.22285896870004995, 0.6455897105806001, 0.3572149188954158, 0.3593786241384078, 0.4129652536167858, 0.2235667348096444, 0.1934749706917921, 0.9989080250991962, 0.3610663374879508, 0.4560779056086429, 0.5709424451857649, 0.7260129069809558, 0.33391252995218546, 0.42301376353902187, 0.23786337243392375, 0.5033463602492809]}}
{"id": "08733b49-923f-4f52-8f4e-cfbe95f58b0f", "fitness": 0.5173096362218933, "name": "SimplifiedDE", "description": "Simplified Differential Evolution with jitter-based mutation and probabilistic replacement, enhancing exploration and reducing stagnation.", "code": "import numpy as np\n\nclass SimplifiedDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation with jitter\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                jitter = np.random.uniform(-0.05, 0.05, size=self.dim)  # Add jitter\n                v = x_r1 + self.F * (x_r2 - x_r3) + jitter\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Probabilistic replacement\n                if f_u < self.fitness[i] or np.random.rand() < 0.05:  # Replace even if not better with small probability\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm SimplifiedDE scored 0.517 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b0ba1e50-1f95-4249-90c8-73beae6245d9"], "operator": null, "metadata": {"aucs": [0.2506460739057108, 0.39946315880410743, 0.4742044735737486, 0.8724350620153196, 0.4411442786523502, 0.5223407676518255, 0.35268468195299707, 0.4093146919619005, 0.424153254109774, 0.3772597237530372, 0.8315022430048427, 0.9968019428892215, 0.2632889126806348, 0.4673305920956543, 0.8966160119502795, 0.5593543812556594, 0.40504491110309726, 0.6163791876490818, 0.25941531813455077, 0.5268130572940746]}}
{"id": "e3b5d557-4088-406c-befa-e74aa89fcc26", "fitness": 0.7760707921678298, "name": "AdaptiveDEEnsemble", "description": "Adaptive Differential Evolution with simplified parameter adaptation and ensemble of mutation strategies to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDEEnsemble:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation Strategy Ensemble\n                strategy = np.random.randint(3) # 3 different mutation strategies\n                \n                if strategy == 0: # DE/rand/1\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x_r1, x_r2, x_r3 = self.population[idxs]\n                    v = self.population[i] + 0.5 * (x_r1 - self.population[i]) + 0.5 * (x_r2 - self.population[i])  + 0.5 * (x_r3 - self.population[i])\n                    \n                elif strategy == 1: # DE/current-to-best/1\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    x_r1, x_r2 = self.population[idxs]\n                    v = self.population[i] + 0.5 * (self.x_opt - self.population[i]) + 0.5 * (x_r1 - x_r2)\n                    \n                else: # DE/rand/2\n                    idxs = np.random.choice(self.pop_size, 5, replace=False)\n                    x_r1, x_r2, x_r3, x_r4, x_r5 = self.population[idxs]\n                    v = x_r1 + 0.5 * (x_r2 - x_r3) + 0.5 * (x_r4 - x_r5)\n                \n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < 0.9 or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDEEnsemble scored 0.776 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9ae47e1a-b868-4979-b616-8a8ee0d3740f"], "operator": null, "metadata": {"aucs": [0.4888320234515321, 0.7791189796650716, 0.799635994237655, 0.9060704965721597, 0.8426902145304818, 0.8595858152483781, 0.7233686221704245, 0.7912515226342907, 0.8383504947636835, 0.7927467470390381, 0.9170451614532513, 0.992332779502133, 0.7713253302630085, 0.8372477464626584, 0.9358785770807505, 0.8462240575369866, 0.7502865095679582, 0.9036911036066633, 0.2317565609985318, 0.5139771065719378]}}
{"id": "bfaad2bf-9413-4c13-a1d2-34a55e6bb0c0", "fitness": 0.5458263277495907, "name": "ADE_SR", "description": "Streamlined Adaptive Differential Evolution with self-adaptive parameters, simplified mutation, and greedy selection for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        while self.budget > 0:\n            successful_F = []\n            successful_CR = []\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size + len(self.archive), 4, replace=False)\n                \n                if indices[0] < self.pop_size:\n                    x_r0 = self.population[indices[0]]\n                else:\n                    x_r0 = self.archive[indices[0] - self.pop_size]\n                    \n                if indices[1] < self.pop_size:\n                    x_r1 = self.population[indices[1]]\n                else:\n                    x_r1 = self.archive[indices[1] - self.pop_size]\n                \n                if indices[2] < self.pop_size:\n                    x_r2 = self.population[indices[2]]\n                else:\n                    x_r2 = self.archive[indices[2] - self.pop_size]\n                    \n                if indices[3] < self.pop_size:\n                    x_r3 = self.population[indices[3]]\n                else:\n                    x_r3 = self.archive[indices[3] - self.pop_size]\n                \n                v = x_r0 + self.F * (x_r1 - x_r2) + self.F*(self.population[i]-x_r3) # Simplified mutation with archive interaction\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection\n                if f_u < self.fitness[i]:\n                    successful_F.append(self.F)\n                    successful_CR.append(self.CR)\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR using Lehmer mean\n            if successful_F:\n                self.F = np.sum(np.array(successful_F)**2) / np.sum(successful_F)\n                self.F = np.clip(self.F, 0.1, 0.9)\n            else:\n                self.F = 0.5 + 0.1 * np.random.randn()\n                self.F = np.clip(self.F, 0.1, 0.9)\n            \n            if successful_CR:\n                self.CR = np.sum(np.array(successful_CR)**2) / np.sum(successful_CR)\n                self.CR = np.clip(self.CR, 0.1, 0.9)\n            else:\n                self.CR = 0.9 + 0.1 * np.random.randn()\n                self.CR = np.clip(self.CR, 0.1, 0.9)\n\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm ADE_SR scored 0.546 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["89a1af46-be92-438b-8e89-3dd4a6033a49"], "operator": null, "metadata": {"aucs": [0.18473762209832145, 0.3655992033418356, 0.5061074476990804, 0.7613550513480969, 0.5187932729169218, 0.6643695291840754, 0.3417077737732719, 0.46536951645254854, 0.5628342886364166, 0.4391508757988889, 0.752881276264734, 0.9919090085536778, 0.49075519474298535, 0.4888838990053398, 0.8708336981723256, 0.6571416094913358, 0.42119427659525566, 0.737250337935829, 0.19630052484660665, 0.49935214813426676]}}
{"id": "3d09d79f-a218-454b-ac59-7ef5fa07eba7", "fitness": 0.71694157726267, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with dynamic F adaptation and reduced evaluations.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.5, 0.7, 0.9] # Reduced F values\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation with dynamic F\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                F = np.random.choice(self.F_list)  # Choose F from the list\n                v = x_r1 + F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation - skip if offspring is identical to parent\n                if np.array_equal(u, self.population[i]):\n                    continue\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.717 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b0ba1e50-1f95-4249-90c8-73beae6245d9"], "operator": null, "metadata": {"aucs": [0.3429512077952307, 0.7079595113521485, 0.683037988789146, 0.8862596367061107, 0.7430334170258314, 0.813540030331095, 0.6451859364485255, 0.6930707577525146, 0.736916569911248, 0.7038301310165265, 0.8698322608085355, 0.9990634325227566, 0.6763185073355398, 0.7280378601812354, 0.9379919009832642, 0.8230874269463782, 0.6398698664429823, 0.8587883296161867, 0.32530854285295285, 0.5247482304351908]}}
{"id": "52edb390-a664-4f59-9aec-d6b8956f3e6b", "fitness": 0.7216221396562155, "name": "Simplified_ADE_SR", "description": "Adaptive Differential Evolution with simplified parameter adaptation, greedy selection and a mirrored boundary handling strategy.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling - mirrored boundary handling\n                for j in range(self.dim):\n                    if u[j] < func.bounds.lb[j]:\n                        u[j] = func.bounds.lb[j] + (func.bounds.lb[j] - u[j])\n                    elif u[j] > func.bounds.ub[j]:\n                        u[j] = func.bounds.ub[j] - (u[j] - func.bounds.ub[j])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n                        \n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm Simplified_ADE_SR scored 0.722 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9ae47e1a-b868-4979-b616-8a8ee0d3740f"], "operator": null, "metadata": {"aucs": [0.3673152261250968, 0.6987303911436324, 0.6618931151371191, 0.8711895098543903, 0.7411373868802229, 0.7887153380861996, 0.666893979119767, 0.6765113435562953, 0.7652049709565846, 0.6630411688568301, 0.8647654871298888, 0.998443343338137, 0.686337413217176, 0.7327268239807784, 0.9223983413289188, 0.7869591412770089, 0.645987929493977, 0.8079323409596152, 0.5592487219265363, 0.5270108207561346]}}
{"id": "8d404a43-47d1-426e-8323-0f62058c3f48", "fitness": 0.4103989008430838, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced population size for faster convergence and budget utilization, employing best-member guided mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Adaptive F and CR\n                F = np.random.normal(0.5, 0.1)\n                CR = np.random.normal(0.9, 0.1)\n                F = np.clip(F, 0.1, 1.0)\n                CR = np.clip(CR, 0.1, 1.0)\n\n                # Mutation: Best-member guided\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                v = self.population[best_idx] + F * (x_r1 - x_r2)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n                \n                # Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        best_idx = np.argmin(self.fitness)\n\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.410 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c69370fb-2e3b-417e-a657-3382e145df48"], "operator": null, "metadata": {"aucs": [0.1559073366050503, 0.1796458256501079, 0.8474851737206477, 0.20808625667946135, 0.23563424711162717, 0.4393402289311572, 0.34010190225590775, 0.31318018281116367, 0.22289051847297547, 0.18588629267419554, 0.918522703325475, 0.9991502294809425, 0.4332464636789586, 0.3468514215644548, 0.747309149687379, 0.3354131682521959, 0.2849388885711617, 0.38266450391031015, 0.16380542158883837, 0.4679181018896643]}}
{"id": "ed16ea17-6641-461c-81c9-740e851af073", "fitness": 0.2810716020652578, "name": "Simplified_ADE_SR", "description": "Simplified Adaptive Differential Evolution with a memory-based adaptation of F and CR, a population size proportional to the dimension, and greedy selection.", "code": "import numpy as np\n\nclass Simplified_ADE_SR:\n    def __init__(self, budget=10000, dim=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = int(4 + 3 * np.log(dim)) # Population size scales with dimension\n        self.F = 0.5\n        self.CR = 0.9\n        self.memory_F = []\n        self.memory_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Adaptation of F and CR from memory\n                if self.memory_F:\n                    self.F = np.random.choice(self.memory_F)\n                if self.memory_CR:\n                    self.CR = np.random.choice(self.memory_CR)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    # Store successful F and CR values in memory\n                    self.memory_F.append(self.F)\n                    self.memory_CR.append(self.CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm Simplified_ADE_SR scored 0.281 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9ae47e1a-b868-4979-b616-8a8ee0d3740f"], "operator": null, "metadata": {"aucs": [0.1467280693026738, 0.21716554885511608, 0.2363298472358698, 0.17440304026573616, 0.29738278438404164, 0.27181338604519956, 0.23907991236144277, 0.30133636596981683, 0.1981387956413686, 0.17293943682115565, 0.258078102146028, 0.9998248692366298, 0.2644853927901316, 0.2628459975107922, 0.15972319146175362, 0.2764909125976984, 0.2702048382608566, 0.23928972191584985, 0.20066779287304748, 0.43450403562994633]}}
{"id": "5bbc219a-d477-4ca2-9fcb-f679686900b9", "fitness": 0.6481547260866645, "name": "ADE_SR", "description": "Simplified Adaptive Differential Evolution with reduced parameter adaptation frequency and enhanced exploitation via adjusted F and CR update.", "code": "import numpy as np\n\nclass ADE_SR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=25, F=0.5, CR=0.9, adapt_freq=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.adapt_freq = adapt_freq\n        self.func_evals = 0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.func_evals += self.pop_size\n        self.budget -= self.pop_size\n\n        for i in range(self.pop_size):\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.population[i]\n\n        generation = 0\n        while self.budget > 0:\n            successful_F = []\n            successful_CR = []\n\n            for i in range(self.pop_size):\n                # Mutation\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n\n                # Archive interaction with reduced probability\n                if np.random.rand() < 0.05 and len(self.archive) > 0:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = self.population[i] + self.F * (self.archive[arch_idx] - self.population[i]) + self.F * (x_r2 - x_r3)\n                else:\n                    v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.func_evals += 1\n                self.budget -= 1\n\n                # Selection\n                if f_u < self.fitness[i]:\n                    successful_F.append(self.F)\n                    successful_CR.append(self.CR)\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if self.fitness[i] < self.f_opt:\n                        self.f_opt = self.fitness[i]\n                        self.x_opt = self.population[i]\n\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        rand_idx = np.random.randint(self.archive_size)\n                        self.archive[rand_idx] = self.population[i]\n\n                if self.budget <= 0:\n                    break\n\n            # Adapt F and CR using Lehmer mean, less frequently\n            if generation % self.adapt_freq == 0:\n                if successful_F:\n                    self.F = np.sum(np.array(successful_F)**2) / np.sum(successful_F)\n                    self.F = np.clip(self.F, 0.3, 0.7) # Adjusted F range\n                if successful_CR:\n                    self.CR = np.sum(np.array(successful_CR)**2) / np.sum(successful_CR)\n                    self.CR = np.clip(self.CR, 0.3, 0.7) # Adjusted CR range\n\n            if self.budget <= 0:\n                break\n            generation += 1\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm ADE_SR scored 0.648 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["89a1af46-be92-438b-8e89-3dd4a6033a49"], "operator": null, "metadata": {"aucs": [0.2352811953862265, 0.5267180098051815, 0.6002657982934528, 0.8673044216042671, 0.7188821757145099, 0.7913282787963403, 0.6322827123071058, 0.6093713270212741, 0.7140419692124991, 0.609395596258655, 0.8027364666009821, 0.9927110734432212, 0.37244408155219355, 0.6780803337112424, 0.8960309147435344, 0.7705584631514275, 0.5548292350554282, 0.827653354341515, 0.2526262963656931, 0.5105528183685382]}}
{"id": "46e5c945-5bd5-483c-bd54-0d1f3e08cb69", "fitness": 0.7453230560506876, "name": "AdaptiveDE", "description": "Streamlined Differential Evolution with simplified parameter adaptation and reduced population size for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                u[crossover_mask] = v[crossover_mask]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.745 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b0ba1e50-1f95-4249-90c8-73beae6245d9"], "operator": null, "metadata": {"aucs": [0.5478763670460152, 0.23665457826118785, 0.5730673817963505, 0.9490003361233962, 0.8926635365151567, 0.9100031210559415, 0.8697360185225964, 0.45309413333982784, 0.6238852438829245, 0.8807909927748716, 0.9395279731876656, 0.999656527076191, 0.75637498344167, 0.8684643213467482, 0.8785841148089967, 0.9076440592407323, 0.3594155137035153, 0.9387868657328886, 0.8134270427276589, 0.5078080104294176]}}
{"id": "f2a86309-493d-46ab-a876-de590c0b3ae3", "fitness": 0.7745466218483266, "name": "AdaptiveDEEnsemble", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation and reduced parameter tuning for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDEEnsemble:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Fixed scaling factor\n        self.CR = 0.9 # Fixed crossover rate\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-best/1\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                v = self.population[i] + self.F * (self.x_opt - self.population[i]) + self.F * (x_r1 - x_r2)\n\n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDEEnsemble scored 0.775 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e3b5d557-4088-406c-befa-e74aa89fcc26"], "operator": null, "metadata": {"aucs": [0.452593686150929, 0.876495153605218, 0.8932494210029313, 0.9428601246147976, 0.8816838532956551, 0.9238961573023022, 0.3697803106492308, 0.8843352355747562, 0.9035481072290023, 0.8575211686762049, 0.9528170834503001, 0.9962334295414088, 0.48171638574222875, 0.894579211222233, 0.7612793295774958, 0.9143275858320866, 0.8392893175826242, 0.9401327646909203, 0.21481827003259113, 0.5097758411936149]}}
{"id": "a29b0a28-465d-42ff-ab07-16c64b7a31b4", "fitness": 0.7413391429684165, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a single mutation strategy and dynamic parameter adjustment for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F # Mutation factor\n        self.CR = CR # Crossover rate\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/rand/1 - Simplified\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)  # Adapt F\n                        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0) # Adapt CR\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.741 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e3b5d557-4088-406c-befa-e74aa89fcc26"], "operator": null, "metadata": {"aucs": [0.3705781500346358, 0.7248013219710785, 0.7282455768918314, 0.8865630094504103, 0.8092786742379465, 0.8217099606722154, 0.7156638149694166, 0.7234013572408263, 0.8003670246869288, 0.7844506551849302, 0.9071526295529322, 0.9946299691550088, 0.6901480118140191, 0.778469795289812, 0.8783829294290466, 0.7957629790408108, 0.6904645694669704, 0.8558140139332823, 0.266138991424689, 0.6047594249215398]}}
{"id": "91ba2643-ce9d-4bd8-a1d0-63bca84fd4ad", "fitness": 0.7919009392072717, "name": "SimplifiedAdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation and dynamic scaling factor.", "code": "import numpy as np\n\nclass SimplifiedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.scaling_factor = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-best/1 with adaptive scaling factor\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Adaptive scaling factor\n                self.scaling_factor = 0.2 + 0.7 * np.random.rand()\n\n                v = self.population[i] + self.scaling_factor * (self.x_opt - self.population[i]) + self.scaling_factor * (x_r1 - x_r2)\n                \n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < 0.9 or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm SimplifiedAdaptiveDE scored 0.792 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e3b5d557-4088-406c-befa-e74aa89fcc26"], "operator": null, "metadata": {"aucs": [0.37437495995889347, 0.8463263488947763, 0.858440865029928, 0.9348516664036954, 0.7522180586040424, 0.9066792650728744, 0.8160003631910865, 0.836800726370476, 0.882171326363614, 0.8149757552612766, 0.9447347497398888, 0.9961713756586664, 0.8521004950119054, 0.8724911560874048, 0.5876766265055435, 0.8955838259129416, 0.8445352450234815, 0.9313757611622118, 0.3512576744099267, 0.5392525394827985]}}
{"id": "755def7b-2f9d-47a1-988a-d79908bb0cad", "fitness": 0.4390534005998824, "name": "SimplifiedAdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a single mutation strategy and dynamic scaling factor, focusing on exploration and reducing complexity.", "code": "import numpy as np\n\nclass SimplifiedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        scaling_factor = 0.5  # Initialize scaling factor\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/rand/1 - Simplified\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = self.population[i] + scaling_factor * (x_r1 - x_r2)\n\n                # Crossover: Binomial\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < 0.7 or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Greedy\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                # Adapt scaling factor (simple adaptation)\n                if np.random.rand() < 0.1:  # Adapt with a probability\n                    scaling_factor = np.random.uniform(0.3, 0.7)\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm SimplifiedAdaptiveDE scored 0.439 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e3b5d557-4088-406c-befa-e74aa89fcc26"], "operator": null, "metadata": {"aucs": [0.1578383994719943, 0.3103339078614614, 0.40626618643366375, 0.6008869194033168, 0.33901310139389884, 0.5208059557779808, 0.30126779582362617, 0.37243807854773003, 0.3858743771098915, 0.18744573381651364, 0.647980894541377, 0.9800369327045232, 0.31160892815226393, 0.33588310064308213, 0.8101573321734472, 0.47163552557244226, 0.34573632471952276, 0.591957308130629, 0.2142631219519039, 0.4896380877683808]}}
{"id": "612832dc-8620-42c5-8ac8-7ea24caff9c4", "fitness": 0.69660858440167, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with adaptive F, CR, and population size reduction over time to focus on exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.min_pop_size = 10  # Minimum population size\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        generation = 0\n        while self.budget > 0 and self.pop_size > self.min_pop_size:\n            generation += 1\n\n            # Adaptive F and CR\n            self.F = 0.5 + 0.3 * np.random.rand()\n            self.CR = 0.7 + 0.2 * np.random.rand()\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                u[crossover_mask] = v[crossover_mask]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n            \n            # Reduce population size gradually\n            if generation % 10 == 0:  # Reduce every 10 generations\n                self.pop_size = max(self.min_pop_size, int(self.pop_size * 0.9))\n                # Re-sort population and fitness based on fitness values. Keep only the best.\n                sorted_indices = np.argsort(self.fitness)\n                self.population = self.population[sorted_indices[:self.pop_size]]\n                self.fitness = self.fitness[sorted_indices[:self.pop_size]]\n                \n\n        # Final refinement with the minimum population\n        while self.budget > 0:\n             # Adaptive F and CR\n            self.F = 0.5 + 0.3 * np.random.rand()\n            self.CR = 0.7 + 0.2 * np.random.rand()\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                u[crossover_mask] = v[crossover_mask]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.697 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46e5c945-5bd5-483c-bd54-0d1f3e08cb69"], "operator": null, "metadata": {"aucs": [0.3601691319154885, 0.4105916234039809, 0.7682762483033034, 0.8440936701742084, 0.7863802666215653, 0.814011801418228, 0.738395046602605, 0.6641814696101949, 0.7804696771447744, 0.7249830426917262, 0.8317684581587337, 0.9877468527298674, 0.3621540094463319, 0.7678962496555244, 0.908951886746936, 0.8052449653379774, 0.6041051640254959, 0.838864363383863, 0.32846215211014973, 0.6054256085524445]}}
{"id": "4b74b77e-172a-45db-a465-210872eb2c05", "fitness": 0.7838767284896232, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with adaptive F selection, clipped mutation, and reduced conditionals for faster execution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.4, 0.6, 0.8] # Narrowed F values\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                F = np.random.choice(self.F_list)\n                \n                # Clipped mutation\n                v = x_r1 + F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element changes\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.784 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d09d79f-a218-454b-ac59-7ef5fa07eba7"], "operator": null, "metadata": {"aucs": [0.5848367231091387, 0.7606838457691448, 0.8157328620748376, 0.932004334782871, 0.8406742965031894, 0.877761581741599, 0.7957204217050611, 0.794485399349524, 0.8620295336899095, 0.8513490137565745, 0.9201624593828142, 0.9990039374389674, 0.749221056896028, 0.8096850802615589, 0.7350472654237624, 0.8809866962853097, 0.7949941967625916, 0.9062191622301686, 0.25934181715374915, 0.5075948854756612]}}
{"id": "00c6cb74-9cd7-4bd1-98cf-9790bc3a6813", "fitness": 0.7112776930901601, "name": "AdaptiveDE_SR_CR", "description": "Adaptive Differential Evolution with simplified parameter adaptation, mirrored boundary handling, and a dynamically adjusted CR parameter based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveDE_SR_CR:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, cr_adapt_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.cr_adapt_prob = cr_adapt_prob\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            # Calculate population diversity (standard deviation of fitness values)\n            diversity = np.std(self.fitness)\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover with adaptive CR\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                \n                # Dynamically adjust CR based on population diversity\n                current_cr = self.CR\n                if np.random.rand() < self.cr_adapt_prob:\n                    current_cr = self.CR * (1 + np.random.normal(0, diversity))\n                    current_cr = np.clip(current_cr, 0.1, 0.9)\n                \n                for j in range(self.dim):\n                    if np.random.rand() < current_cr or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling - mirrored boundary handling\n                for j in range(self.dim):\n                    if u[j] < func.bounds.lb[j]:\n                        u[j] = func.bounds.lb[j] + (func.bounds.lb[j] - u[j])\n                    elif u[j] > func.bounds.ub[j]:\n                        u[j] = func.bounds.ub[j] - (u[j] - func.bounds.ub[j])\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n                        \n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE_SR_CR scored 0.711 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["52edb390-a664-4f59-9aec-d6b8956f3e6b"], "operator": null, "metadata": {"aucs": [0.2958239018025659, 0.6751384228128282, 0.6889790894578773, 0.8867064794463543, 0.7218104241936898, 0.7924796791056922, 0.6481538659397774, 0.6597184191579544, 0.7512966784956481, 0.6529452080278162, 0.8718145829888749, 0.9973640877530907, 0.7131228576277384, 0.7097369476392215, 0.9118729249877982, 0.7734249832612885, 0.6383814493280995, 0.8602607732472348, 0.2852083283767993, 0.6913147581528503]}}
{"id": "3e1116b6-7cdc-4c46-884b-9b8f49a5476f", "fitness": 0.7654629880085251, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with dynamic F adaptation, reduced evaluations, and enhanced boundary handling for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.5, 0.7, 0.9]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                F = np.random.choice(self.F_list)\n                v = x_r1 + F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling using mirroring\n                for j in range(self.dim):\n                    if u[j] < func.bounds.lb[j]:\n                        u[j] = 2 * func.bounds.lb[j] - u[j]\n                    elif u[j] > func.bounds.ub[j]:\n                        u[j] = 2 * func.bounds.ub[j] - u[j]\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.765 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d09d79f-a218-454b-ac59-7ef5fa07eba7"], "operator": null, "metadata": {"aucs": [0.3606707244711128, 0.7446169152572919, 0.7407664443141486, 0.9298505784436161, 0.8211773153974468, 0.8420193831128809, 0.7270366754117472, 0.737327359486596, 0.811464655723721, 0.7641386318416323, 0.9087057944628185, 0.9955870178467182, 0.727167931237457, 0.7944571937685835, 0.9508261126687908, 0.8525368255412281, 0.7002065849070267, 0.8819110618952001, 0.4875868086259898, 0.5312057457564927]}}
{"id": "602805bf-1abf-44ce-801b-f15a386bfc31", "fitness": 0.44541471293962315, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with a dynamically adjusted F parameter based on population diversity and reduced evaluations.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            # Calculate diversity (variance of fitness values)\n            diversity = np.var(self.fitness)\n            \n            for i in range(self.pop_size):\n                # Dynamic F adaptation:  Higher diversity, higher F (more exploration)\n                F = 0.3 + 0.7 * (diversity / (np.max(self.fitness) - np.min(self.fitness) + 1e-8)) if np.max(self.fitness) != np.min(self.fitness) else 0.5 # avoid division by zero\n                F = np.clip(F, 0.1, 1.0)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                u[crossover_mask] = v[crossover_mask]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.445 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46e5c945-5bd5-483c-bd54-0d1f3e08cb69"], "operator": null, "metadata": {"aucs": [0.29940877862605497, 0.3811578630125966, 0.2990399183452671, 0.19859563392489576, 0.45997879281214493, 0.3326294422482914, 0.5151468986405884, 0.33398823045416615, 0.2750992946373325, 0.30950899782015073, 0.389518032227236, 0.986683205520778, 0.3934801864239953, 0.5540123615283301, 0.6999211961381653, 0.6398453739693872, 0.3213805786157137, 0.7488105289926403, 0.2624199110929526, 0.5076690337617753]}}
{"id": "359334ee-6a14-4d7e-9419-5dad4b6cb5e5", "fitness": 0.3934065326755679, "name": "AdaptiveDE", "description": "Streamlined Differential Evolution with adaptive CR, simplified mutation and a mirroring boundary handling strategy to improve exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = self.population[i] + self.F * (x_r1 - x_r2 + x_r3 - self.population[i])\n\n                # Adaptive Crossover\n                CR_i = np.random.normal(self.CR, 0.1, size=self.dim)\n                CR_i = np.clip(CR_i, 0, 1)\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                crossover_mask = (np.random.rand(self.dim) < CR_i) | (np.arange(self.dim) == j_rand)\n                u[crossover_mask] = v[crossover_mask]\n\n                # Boundary handling (mirroring)\n                lower_bound = func.bounds.lb\n                upper_bound = func.bounds.ub\n                \n                u = np.where(u < lower_bound, 2 * lower_bound - u, u)\n                u = np.where(u > upper_bound, 2 * upper_bound - u, u)\n                \n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.393 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46e5c945-5bd5-483c-bd54-0d1f3e08cb69"], "operator": null, "metadata": {"aucs": [0.37034752108875, 0.39475270184213573, 0.35082285739726127, 0.44246755094355905, 0.5097978115224471, 0.24210065370035372, 0.35839138631838763, 0.28064493934834334, 0.22380584332005848, 0.2126573500609742, 0.5238298304541382, 0.9987497585694554, 0.2665738360009715, 0.20827353561376372, 0.6806183303523239, 0.34194328119302286, 0.2612472404961341, 0.442632058267866, 0.2625175949258979, 0.4959565720955147]}}
{"id": "8fd8377f-778e-4af6-afe3-c388779c167f", "fitness": 0.44913033402308056, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, smaller population size, and adaptive F and CR based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=15):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            # Adaptive F and CR\n            if self.pop_size > 1:\n                diversity = np.std(self.fitness)\n                self.F = np.clip(np.random.normal(0.5, 0.3 * diversity), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(0.9, 0.1 * diversity), 0.1, 1.0)\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                u[crossover_mask] = v[crossover_mask]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.449 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46e5c945-5bd5-483c-bd54-0d1f3e08cb69"], "operator": null, "metadata": {"aucs": [0.25319796611070056, 0.18100721807639852, 0.6056325326296801, 0.41759519293657477, 0.5989760336301421, 0.24801108045897458, 0.30086934139225363, 0.5229992037124285, 0.8057481362771372, 0.200360848570448, 0.30270063208718945, 0.9990130479989072, 0.33858783408227744, 0.3236149183791929, 0.7049522716579381, 0.9353490190992072, 0.26638760695344077, 0.2552920041326161, 0.22077899179400962, 0.5015328004820945]}}
{"id": "82255c6f-4761-4a34-9b39-58a7ada69b31", "fitness": 0.34002004927140045, "name": "AdaptiveDEEnsemble", "description": "Simplified Adaptive Differential Evolution with dynamic scaling factor and reduced ensemble size for enhanced efficiency.", "code": "import numpy as np\n\nclass AdaptiveDEEnsemble:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        scaling_factor = 0.5  # Initial scaling factor\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation Strategy Ensemble (reduced to 2 strategies)\n                strategy = np.random.randint(2) \n                \n                if strategy == 0: # DE/rand/1\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x_r1, x_r2, x_r3 = self.population[idxs]\n                    v = self.population[i] + scaling_factor * (x_r1 - x_r2) + scaling_factor * (x_r3 - self.population[i])\n                    \n                else: # DE/current-to-best/1\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    x_r1, x_r2 = self.population[idxs]\n                    v = self.population[i] + scaling_factor * (self.x_opt - self.population[i]) + scaling_factor * (x_r1 - x_r2)\n                \n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < 0.7 or j == j_rand: #reduced crossover rate\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        scaling_factor = np.clip(scaling_factor * 1.05, 0.1, 0.9) # Adapt scaling factor if improvement is found\n                else:\n                    scaling_factor = np.clip(scaling_factor * 0.95, 0.1, 0.9) # Adapt scaling factor if no improvement\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDEEnsemble scored 0.340 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e3b5d557-4088-406c-befa-e74aa89fcc26"], "operator": null, "metadata": {"aucs": [0.11668425123181592, 0.27648390539984147, 0.37325377100843316, 0.37610753189123347, 0.239612263091456, 0.6941382601305521, 0.28189066848642397, 0.2748933192375743, 0.2802192404534233, 0.19796653771024264, 0.3541786111524571, 0.9964856196401556, 0.3117232547840393, 0.2530276331912409, 0.1758970066337051, 0.2895922451796613, 0.31329952054810917, 0.3294141206743484, 0.19333835540208155, 0.47219486958121315]}}
{"id": "31742d38-18cb-45aa-8c65-ae2cd6f8b033", "fitness": 0.3123664373092434, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with dynamic F adaptation and reduced population updates for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.4, 0.6, 0.8]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            idxs = np.random.choice(self.pop_size, self.pop_size, replace=True) # Sample with replacement for simplicity\n            for i in range(self.pop_size):\n                x_r1 = population[idxs[i % self.pop_size]]\n                x_r2 = population[idxs[(i + 1) % self.pop_size]]\n                x_r3 = population[idxs[(i + 2) % self.pop_size]]\n                F = np.random.choice(self.F_list)\n                \n                # Mutation\n                v = x_r1 + F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                # Reduced population update: only update if better than best\n                if f_u < self.f_opt:\n                    population[i] = u\n                    fitness[i] = f_u\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.312 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4b74b77e-172a-45db-a465-210872eb2c05"], "operator": null, "metadata": {"aucs": [0.12153038849447495, 0.1865564706019417, 0.2839723069220278, 0.22947168902064718, 0.2669247950492041, 0.29776317322687396, 0.25409804361290467, 0.2510242966789282, 0.2251809321730036, 0.16888131246965443, 0.26808821897637625, 0.9937597954288769, 0.28243327781568095, 0.24489630750261926, 0.6438730372153451, 0.2955608787610966, 0.24765239076502055, 0.3297100533387026, 0.18310859361040033, 0.4728427845210884]}}
{"id": "0c0158df-47fd-4c76-ace8-a240ae7dd8d1", "fitness": 0.7666892130009598, "name": "SimplifiedAdaptiveDE", "description": "Simplified Adaptive DE with reduced crossover rate and a simplified scaling factor adaptation for faster convergence.", "code": "import numpy as np\n\nclass SimplifiedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, crossover_rate=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.crossover_rate = crossover_rate\n        self.scaling_factor = 0.5  # Initial scaling factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-best/1\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n\n                v = self.population[i] + self.scaling_factor * (self.x_opt - self.population[i]) + self.scaling_factor * (x_r1 - x_r2)\n\n                # Crossover\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        self.scaling_factor = np.clip(self.scaling_factor + 0.01 * np.random.randn(), 0.1, 0.9) # simple adaptation\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm SimplifiedAdaptiveDE scored 0.767 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["91ba2643-ce9d-4bd8-a1d0-63bca84fd4ad"], "operator": null, "metadata": {"aucs": [0.33341323890637486, 0.7774433477565903, 0.828114346235673, 0.9409611789459099, 0.8688828003963952, 0.8939478999021188, 0.7637893552450883, 0.8154032943560849, 0.8613191952590825, 0.2245296216654893, 0.919681254272382, 0.9994161283390285, 0.5970563873999204, 0.8453956682855304, 0.9494095545064956, 0.8815949337252094, 0.7692650515923931, 0.9224956795559773, 0.647450008156325, 0.49421531551712694]}}
{"id": "dfdd3aa0-3241-4bb8-9e69-299dca5bd43e", "fitness": 0.7344737192876594, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, crossover, and parameter adaptation for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, CR=0.9, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F = F # Single F value\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                \n                # Simplified mutation\n                v = x_r1 + self.F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Simplified Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.where(np.random.rand(self.dim) < self.CR, v, population[i])\n                u[j_rand] = v[j_rand] # Ensure at least one element changes\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.734 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4b74b77e-172a-45db-a465-210872eb2c05"], "operator": null, "metadata": {"aucs": [0.21503890255831704, 0.30061695702884883, 0.5666438894126993, 0.9303337912263768, 0.8876097082201442, 0.9130419891133587, 0.8690543405020443, 0.8637919830857588, 0.9009515807830678, 0.49363520258356886, 0.9443405661977103, 0.9947180218856504, 0.3816801641408101, 0.8686405721944411, 0.7662254120582765, 0.8854336518356609, 0.6770699981368579, 0.9386341390990718, 0.7869227796855292, 0.5050907360049934]}}
{"id": "6acec84d-9c7e-4fcb-8c0b-41d9b09bcbcf", "fitness": 0.7681823375437256, "name": "SimplifiedAdaptiveDE", "description": "Simplified Adaptive DE with per-dimension scaling factor adaptation and reduced parameter tuning.", "code": "import numpy as np\n\nclass SimplifiedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.scaling_factor = np.full(dim, 0.5)  # Initialize scaling factor per dimension\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-best/1 with adaptive scaling factor per dimension\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Adaptive scaling factor\n                self.scaling_factor = 0.2 + 0.7 * np.random.rand(self.dim) # Per-dimension adaptation\n\n                v = self.population[i] + self.scaling_factor * (self.x_opt - self.population[i]) + self.scaling_factor * (x_r1 - x_r2)\n                \n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm SimplifiedAdaptiveDE scored 0.768 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["91ba2643-ce9d-4bd8-a1d0-63bca84fd4ad"], "operator": null, "metadata": {"aucs": [0.38066981494214047, 0.7985022263242684, 0.8548496152198531, 0.9404470720731354, 0.877018849149762, 0.9000354687018723, 0.7372832527463611, 0.8366041154765957, 0.8668392297049841, 0.8117032092775671, 0.9253323549614649, 0.9957614274888278, 0.2889444313707842, 0.8598039824518985, 0.9413570505085935, 0.8894037078626217, 0.8016997003208761, 0.9196339361330998, 0.2274073072872802, 0.5103499988725284]}}
{"id": "c240275d-8ab1-4e2c-8451-774c1bd0cd55", "fitness": 0.7690485398944278, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with adaptive F selection, optimized mutation, and dynamic population scaling for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)  # Dynamic population size\n        self.CR = CR\n        self.F_list = [0.4, 0.6, 0.8]  # Narrowed F values\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                F = np.random.choice(self.F_list)\n                \n                # Optimized mutation (simplified clipping)\n                v = x_r1 + F * (x_r2 - x_r3)\n                v = np.minimum(np.maximum(v, func.bounds.lb), func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element changes\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.769 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4b74b77e-172a-45db-a465-210872eb2c05"], "operator": null, "metadata": {"aucs": [0.49784768380246847, 0.7933760711168044, 0.8232858253923081, 0.9092994917999173, 0.8467571233937523, 0.8683731394687054, 0.7812707233915932, 0.8038452913034191, 0.8330592427247525, 0.4270899041802221, 0.9171106796293215, 0.9956219690328897, 0.7945360035079757, 0.8235287148420684, 0.9477322022674667, 0.8656981990139512, 0.7414791503301346, 0.9115514818324032, 0.27062666400122803, 0.528881236857174]}}
{"id": "a7287ec4-4402-4e11-8de5-4200547c6f60", "fitness": 0.8019616886941948, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, adaptive scaling factor, and improved boundary handling for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.5, 0.7, 0.9]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Simplified mutation: uses current individual and best individual\n                F = np.random.choice(self.F_list)\n                v = self.population[i] + F * (self.x_opt - self.population[i]) + F*(x_r1 - x_r2) # current-to-best with exploration\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.802 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3e1116b6-7cdc-4c46-884b-9b8f49a5476f"], "operator": null, "metadata": {"aucs": [0.23940170357164392, 0.8745341552267332, 0.9055847810084936, 0.9592393562327899, 0.9172083303656847, 0.922706714641746, 0.37688772802800774, 0.9029805743646488, 0.9042856913234756, 0.2210597590135982, 0.9506043876768202, 0.9957655609506568, 0.8797874679287329, 0.9160162518428628, 0.9748084897847684, 0.9026622302922517, 0.8843074025155444, 0.9479203246439388, 0.8486473471820122, 0.5148255172894877]}}
{"id": "faca16f7-7a4a-471f-8122-04931c3bae99", "fitness": 0.6902104244961981, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified current-to-best mutation and parameter adaptation using a success-history based adaptive mutation parameter.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, memory_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.memory_size = memory_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.archive = []\n        self.archive_fitness = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-best/1\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                v = self.population[i] + self.F * (self.x_opt - self.population[i]) + self.F * (x_r1 - x_r2)\n\n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.archive.append(self.population[i].copy())\n                    self.archive_fitness.append(self.fitness[i])\n                    if len(self.archive) > self.memory_size:\n                        self.archive.pop(0)\n                        self.archive_fitness.pop(0)\n                        \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        \n                    self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                    self.CR = np.random.rand()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.690 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f2a86309-493d-46ab-a876-de590c0b3ae3"], "operator": null, "metadata": {"aucs": [0.2765009063020232, 0.4844860956792766, 0.765270936220461, 0.8941402668901975, 0.762701269105622, 0.8307340634398723, 0.6001637714883252, 0.713510796660298, 0.7771486885916641, 0.6579157097546406, 0.876212846875579, 0.9957144710309926, 0.3489019487521411, 0.746356903922729, 0.9364380415959762, 0.8213554678101301, 0.6600497944869582, 0.8772316226918788, 0.2501968606611574, 0.5291780279640399]}}
{"id": "ef8ab80d-6001-4c0f-aead-0f73205bbfe7", "fitness": 0.7436344049548699, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-pbest mutation and dynamic scaling factor adaptation based on success.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, pbest_ratio=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pbest_ratio = pbest_ratio\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        \n        num_pbest = max(1, int(self.pop_size * self.pbest_ratio))\n\n        while self.budget > 0:\n            # Adaptive F\n            success_indices = []\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-pbest/1\n                \n                pbest_indices = np.argsort(self.fitness)[:num_pbest]\n                idx_pbest = np.random.choice(pbest_indices)\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                v = self.population[i] + self.F * (self.population[idx_pbest] - self.population[i]) + self.F * (x_r1 - x_r2)\n\n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    success_indices.append(i)\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        \n                if self.budget <= 0:\n                    break\n            \n            #Adapt F\n            if success_indices:\n                self.F = np.clip(np.mean(np.random.normal(0.5, 0.3, len(success_indices))), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.744 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f2a86309-493d-46ab-a876-de590c0b3ae3"], "operator": null, "metadata": {"aucs": [0.6570024105236408, 0.8794334940381356, 0.4755530257462198, 0.9531689042055399, 0.891920825326878, 0.913964269310398, 0.322607136207711, 0.8772932115947687, 0.9040795013520603, 0.478799077060001, 0.9529484000181788, 0.9915980561837641, 0.3262985690330976, 0.8658420406820444, 0.8403802320637173, 0.9093094445969032, 0.8515447490339514, 0.9343625378917468, 0.33218463334923165, 0.5143975808794061]}}
{"id": "9c0b7088-cdd7-4976-b7f9-c0d9eebe77cf", "fitness": 0.5407564901249092, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with a simplified mutation strategy and adaptive scaling factor selection based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.5, 0.7, 0.9]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            # Calculate population diversity (standard deviation along each dimension)\n            diversity = np.std(self.population, axis=0)\n            \n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Adapt F based on diversity; higher diversity -> higher F (exploration)\n                F = self.F_list[np.argmin(np.abs(np.mean(diversity) - self.F_list))]\n                \n                v = self.population[i] + F * (x_r1 - x_r2) # Simplified mutation\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.541 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3e1116b6-7cdc-4c46-884b-9b8f49a5476f"], "operator": null, "metadata": {"aucs": [0.16638038534031951, 0.4242334716477618, 0.5011335070908043, 0.7763075130554666, 0.48131101140444066, 0.6833017774611988, 0.32934560061089246, 0.46590050811182715, 0.4985142426903636, 0.31795528409195994, 0.7912364021094981, 0.9988552227824747, 0.5114014169622747, 0.46678913883513873, 0.905109707888487, 0.6219474229715256, 0.419479665282642, 0.7726510569766468, 0.1951471855526573, 0.4881292816318039]}}
{"id": "4d91f521-60d7-41c1-8b15-0261fb15aff1", "fitness": 0.7283896968431531, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with adaptive F and CR, using a current-to-pbest mutation strategy and mirroring boundary handling for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, p=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.p = p # percentage of best individuals to select from\n        self.CRm = 0.5\n        self.Fm = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            # find p-best individuals\n            sorted_indices = np.argsort(self.fitness)\n            p_best_indices = sorted_indices[:int(self.p * self.pop_size)]\n\n            for i in range(self.pop_size):\n                # current-to-pbest mutation\n                x_pbest = self.population[np.random.choice(p_best_indices)]\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n\n                F = np.random.normal(self.Fm, 0.1)\n                F = np.clip(F, 0.1, 1.0)\n                v = self.population[i] + F * (x_pbest - self.population[i]) + F * (x_r1 - x_r2)\n\n\n                # Crossover\n                CR = np.random.normal(self.CRm, 0.1)\n                CR = np.clip(CR, 0.1, 1.0)\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling using mirroring\n                for j in range(self.dim):\n                    if u[j] < func.bounds.lb[j]:\n                        u[j] = 2 * func.bounds.lb[j] - u[j]\n                    elif u[j] > func.bounds.ub[j]:\n                        u[j] = 2 * func.bounds.ub[j] - u[j]\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.728 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3e1116b6-7cdc-4c46-884b-9b8f49a5476f"], "operator": null, "metadata": {"aucs": [0.3353329367506298, 0.7581979217215792, 0.8305783173159352, 0.19817581355709368, 0.8531229037422292, 0.9004899812664591, 0.8103513761540628, 0.8331170160829934, 0.8634286888230633, 0.7384686869408732, 0.9034054607819186, 0.9954898629928304, 0.4205385018295521, 0.8234608771067725, 0.9531050422633011, 0.8934107919288221, 0.7404100856882723, 0.9274942648688305, 0.2552025070191426, 0.5340129000287043]}}
{"id": "d38b310f-ba6d-4559-bfce-456df78381fc", "fitness": 0.7042699783053118, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with self-adaptive F, clipped mutation, and reduced conditionals for faster execution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                \n                # Self-adaptive F\n                F = np.random.normal(0.5, 0.3)\n                F = np.clip(F, 0.1, 1.0)\n                \n                # Clipped mutation\n                v = x_r1 + F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element changes\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.704 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4b74b77e-172a-45db-a465-210872eb2c05"], "operator": null, "metadata": {"aucs": [0.39729161416140946, 0.8489272689531999, 0.7212224600624824, 0.9000614195483141, 0.8886174148551061, 0.8769127846581953, 0.8407058938935067, 0.7039988524185778, 0.8612365163300827, 0.23331235102552317, 0.916477287493868, 0.9878946109055708, 0.3104673682194746, 0.383475509654011, 0.9613572497381901, 0.8569128513304439, 0.72656465193337, 0.9119097620817394, 0.22471889093767727, 0.5333348079054947]}}
{"id": "26a10313-7a71-4993-978b-c8c360c5d010", "fitness": 0.5352509366225824, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with improved mutation strategy and simplified parameter adaptation for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F = F  # Single scaling factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: current-to-rand with single F\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                v = self.population[i] + self.F * (x_r1 - x_r2)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling (clip)\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        \n                        # Adaptive F: Reduce F if improvement found\n                        self.F = max(0.1, self.F * 0.9) \n\n                else:\n                    # Adapt F: Increase F if no improvement\n                    self.F = min(0.9, self.F * 1.1)\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.535 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3e1116b6-7cdc-4c46-884b-9b8f49a5476f"], "operator": null, "metadata": {"aucs": [0.18918618992807867, 0.3674040217560267, 0.48976733171514375, 0.7395555217933392, 0.5415319787042225, 0.6185319722532487, 0.3407208615101185, 0.4253301059924064, 0.4935019176694513, 0.3966525788816564, 0.7747865771045087, 0.9943112666553017, 0.5189122895599221, 0.455857355477979, 0.879390471078975, 0.575380196159181, 0.4395627964110683, 0.7242758892083572, 0.2522687925999537, 0.48809061799270825]}}
{"id": "7b6a9529-e8c1-4efb-851d-8713fd345e39", "fitness": 0.5996713309568803, "name": "SimplifiedAdaptiveDE", "description": "Simplified Adaptive DE with self-adaptive scaling factor and enhanced exploration via orthogonal crossover.", "code": "import numpy as np\n\nclass SimplifiedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, crossover_rate=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.crossover_rate = crossover_rate\n        self.scaling_factor = 0.5  # Initial scaling factor\n        self.scaling_factor_learning_rate = 0.1\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-best/1\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n\n                # Scaling factor adaptation\n                self.scaling_factor = np.clip(self.scaling_factor + self.scaling_factor_learning_rate * np.random.randn(), 0.1, 0.9)\n                \n                v = self.population[i] + self.scaling_factor * (self.x_opt - self.population[i]) + self.scaling_factor * (x_r1 - x_r2)\n\n                # Orthogonal Crossover: Generate multiple trial vectors and choose the best\n                num_trials = 3  # Number of trial vectors to generate\n                trial_vectors = np.zeros((num_trials, self.dim))\n                trial_fitnesses = np.zeros(num_trials)\n\n                for trial in range(num_trials):\n                    u = np.copy(self.population[i])\n                    for j in range(self.dim):\n                        if np.random.rand() < self.crossover_rate:\n                            u[j] = v[j]\n\n                    # Boundary handling\n                    u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                    # Evaluation\n                    f_u = func(u)\n                    self.budget -= 1\n                    trial_vectors[trial, :] = u\n                    trial_fitnesses[trial] = f_u\n                    if self.budget <= 0:\n                        break\n                \n                if self.budget <= 0:\n                    break\n\n                best_trial_idx = np.argmin(trial_fitnesses)\n                best_trial_vector = trial_vectors[best_trial_idx, :]\n                best_trial_fitness = trial_fitnesses[best_trial_idx]\n\n\n                # Selection: Replace only if better\n                if best_trial_fitness < self.fitness[i]:\n                    self.population[i] = best_trial_vector\n                    self.fitness[i] = best_trial_fitness\n\n                    if best_trial_fitness < self.f_opt:\n                        self.f_opt = best_trial_fitness\n                        self.x_opt = best_trial_vector.copy()\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm SimplifiedAdaptiveDE scored 0.600 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0c0158df-47fd-4c76-ace8-a240ae7dd8d1"], "operator": null, "metadata": {"aucs": [0.22161490322098765, 0.5305144173721028, 0.61158716728553, 0.813316600760549, 0.7168188353623487, 0.7636107287994448, 0.3558455271728873, 0.5724640952186909, 0.6726535024548501, 0.2181153376906817, 0.820722893578782, 0.9866100032473675, 0.46920964561273526, 0.5938743446397371, 0.9174720168298495, 0.7214902714953055, 0.4766557919966663, 0.8176043144644666, 0.20705822008282648, 0.5061880018517979]}}
{"id": "df7d3dd0-29ce-4cc5-9034-0ccd0e9cf4d0", "fitness": 0.7664932141341474, "name": "AdaptiveDE", "description": "Further simplified Differential Evolution with a single scaling factor and adjusted crossover for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR  # Reduced CR for exploration\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                F = 0.5  # Single scaling factor\n                \n                # Mutation\n                v = x_r1 + F * (x_r2 - x_r3)\n                v = np.minimum(np.maximum(v, func.bounds.lb), func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.766 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c240275d-8ab1-4e2c-8451-774c1bd0cd55"], "operator": null, "metadata": {"aucs": [0.37290463571129817, 0.711336473870213, 0.7854089068712313, 0.8980973051306471, 0.8669007561255382, 0.8992426939165699, 0.7935247756501681, 0.8193824848024913, 0.8525094561901825, 0.8322698617167553, 0.8893480344152576, 0.9981680396795436, 0.42411673583162, 0.8289583734416306, 0.9440338319382572, 0.8805149470271975, 0.7620489538440898, 0.899448087457366, 0.3503789865164806, 0.5212709425464102]}}
{"id": "36d0e07d-f3bf-4b65-b013-47930ca9e078", "fitness": 0.7661952024945647, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and mutation strategy for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=4, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR\n        self.F = 0.5  # Single F value\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n\n                # Simplified mutation\n                v = x_r1 + self.F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.766 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c240275d-8ab1-4e2c-8451-774c1bd0cd55"], "operator": null, "metadata": {"aucs": [0.3905046391640986, 0.656627184328695, 0.6764616991841993, 0.9184566713820255, 0.8790073900709352, 0.9079455207652193, 0.8312703278000765, 0.8418918747427372, 0.86752608866412, 0.851489311103403, 0.9132966787810557, 0.9954823654827608, 0.43936790058201514, 0.8465536139256323, 0.9515862140129672, 0.8986502894374754, 0.8048060869775834, 0.908141501566923, 0.23972677558701538, 0.5051119163323564]}}
{"id": "f90c2243-bb07-47eb-8031-60cb5d555df6", "fitness": 0.46363327866836024, "name": "SimplifiedAdaptiveDE", "description": "Simplified Adaptive DE with reduced parameter tuning, simplified scaling factor adaptation and a population-based archive for enhanced exploration.", "code": "import numpy as np\n\nclass SimplifiedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.scaling_factor = 0.5\n        self.crossover_rate = 0.9\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-rand/1 with simplified scaling factor\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                # Scaling factor adaptation (simplified)\n                scaling_factor = 0.2 + 0.3 * np.random.rand()\n\n                v = self.population[i] + scaling_factor * (x_r1 - x_r2) + scaling_factor * (self.x_opt - x_r3)\n                \n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better - Greedy selection\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        idx_to_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_to_replace] = self.population[i].copy()\n\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm SimplifiedAdaptiveDE scored 0.464 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6acec84d-9c7e-4fcb-8c0b-41d9b09bcbcf"], "operator": null, "metadata": {"aucs": [0.17297673310874084, 0.3201706688045959, 0.4419338369753557, 0.6701050377141302, 0.34497328134587535, 0.5142517076441888, 0.3119534786255743, 0.3828172932192899, 0.3331643090367501, 0.21060142523523695, 0.7280107095721713, 0.9962131063734029, 0.46153536348508484, 0.33465267511072516, 0.8566694706607318, 0.5056194713871391, 0.36329627681502497, 0.6435059764552317, 0.187000484090314, 0.4932142677076403]}}
{"id": "3f632eea-7e71-4e02-b143-9ba16def2266", "fitness": 0.2522949194483079, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with a focused current-to-best mutation and simplified parameter adaptation, enhanced by a probabilistic selection of the scaling factor F.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.3, 0.5, 0.7]  # Reduced F values for faster convergence\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Simplified mutation: focused current-to-best\n                F = np.random.choice(self.F_list)\n                v = self.population[i] + F * (self.x_opt - self.population[i])  # Simplified current-to-best\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.252 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a7287ec4-4402-4e11-8de5-4200547c6f60"], "operator": null, "metadata": {"aucs": [0.11707207438451006, 0.1811346067168047, 0.31158533999237337, 0.1704327246878221, 0.16183359700186262, 0.19642465756095284, 0.22466179477847792, 0.21633715401709608, 0.20031753772587313, 0.18690476742236461, 0.22244459864296573, 0.9981035808063277, 0.2399896404242472, 0.18146815730820953, 0.1692960241414626, 0.2599523308809413, 0.23251167973830766, 0.1609300198186192, 0.16886614866256056, 0.4456319542543795]}}
{"id": "12ec18f8-be57-442d-bfac-1f3ca4516382", "fitness": 0.4422383423352557, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, adaptive scaling factor, improved boundary handling, and reduced crossover operations for faster convergence and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.5, 0.7, 0.9]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Simplified mutation: uses current individual and best individual\n                F = np.random.choice(self.F_list)\n                v = self.population[i] + F * (self.x_opt - self.population[i]) + F*(x_r1 - x_r2) # current-to-best with exploration\n\n                # Crossover - Reduced Crossover Operations\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                \n                if np.random.rand() < self.CR:\n                    u[j_rand] = v[j_rand] # Only one dimension is changed.\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.442 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a7287ec4-4402-4e11-8de5-4200547c6f60"], "operator": null, "metadata": {"aucs": [0.1731993703019722, 0.2449631200114577, 0.4565741506325992, 0.4759687883300917, 0.3676821606725459, 0.6323147893460098, 0.3209730211641668, 0.43985053777237404, 0.4006114013798633, 0.2146916929993543, 0.3615512600405014, 0.9829278649806797, 0.26394518131510236, 0.37479471776479667, 0.805775435441159, 0.694578923456393, 0.33295360338989954, 0.5542540635902407, 0.23339703720469274, 0.5137597269112146]}}
{"id": "71425379-496a-4b27-99a6-84c506290b48", "fitness": 0.7654380683319596, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, adaptive scaling factor, and improved boundary handling using a binomial crossover.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F_list = [0.5, 0.7, 0.9]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Simplified mutation: uses current individual and best individual\n                F = np.random.choice(self.F_list)\n                v = self.population[i] + F * (self.x_opt - self.population[i]) + F*(x_r1 - x_r2) # current-to-best with exploration\n\n                # Binomial Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element is taken from v\n                u[mask] = v[mask]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.765 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a7287ec4-4402-4e11-8de5-4200547c6f60"], "operator": null, "metadata": {"aucs": [0.5362161540081996, 0.23524761413819717, 0.8916632207778384, 0.9655388159829985, 0.921136628118404, 0.9240133824657226, 0.36536685031984995, 0.8838407420346786, 0.9212145591614815, 0.898996481828191, 0.9448588780329094, 0.9957695167670155, 0.42059995471649003, 0.9025995531954708, 0.9681426165121103, 0.9281154881722898, 0.8797178055941497, 0.9528666726751598, 0.24502700820092094, 0.5278294239371147]}}
{"id": "f4764ea0-12f3-4ec3-9fb3-160847ed87c6", "fitness": 0.4772055896591425, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation and per-dimension learning rate adaptation, reducing parameter tuning and improving exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F = np.full(dim, 0.5)  # Per-dimension F values\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n\n                # Simplified mutation with per-dimension F\n                v = self.population[i] + self.F * (self.x_opt - self.population[i]) + self.F * (x_r1 - x_r2)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update per-dimension F if improvement\n                    self.F[j] = np.clip(self.F[j] * np.random.uniform(0.8, 1.2), 0.1, 0.9) # Adjust F based on success\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                else:\n                    # Reduce per-dimension F if no improvement\n                    self.F[j] = np.clip(self.F[j] * np.random.uniform(0.8, 1.0), 0.1, 0.9)\n\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.477 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a7287ec4-4402-4e11-8de5-4200547c6f60"], "operator": null, "metadata": {"aucs": [0.18757357463615676, 0.3393839133943277, 0.34195466167850375, 0.9495576831083405, 0.4602506906806001, 0.8023991318425158, 0.2984840521986286, 0.6256582198633118, 0.6365039743168928, 0.2272335934045, 0.37434362638062724, 0.9976831784956819, 0.2606331085179411, 0.38045355255334457, 0.8420688458548852, 0.3171441217916451, 0.34269763358858474, 0.43864016181827015, 0.23532947621543931, 0.48611859284265213]}}
{"id": "d9fb63d3-4236-4366-825b-005497888786", "fitness": 0.498553887854411, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation and scaling factor adaptation based on successful updates for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, crossover_rate=0.7, initial_scaling_factor=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.crossover_rate = crossover_rate\n        self.scaling_factor = initial_scaling_factor\n        self.archive_rate = 0.1\n        self.archive = None\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n        self.archive = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(int(self.pop_size*self.archive_rate), self.dim))\n\n        success_count = 0\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/rand/1 with archive\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                if np.random.rand() < self.archive_rate:\n                  x_r3 = self.archive[np.random.choice(len(self.archive))]\n                else:\n                  x_r3 = self.population[np.random.choice(self.pop_size)]\n\n                v = self.population[i] + self.scaling_factor * (x_r1 - x_r2) + self.scaling_factor * (x_r3 - self.population[i])\n\n                # Crossover\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    success_count += 1\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n\n                if self.budget <= 0:\n                    break\n\n            # Scaling factor adaptation: Increase if successful, decrease otherwise\n            if success_count > 0:\n                self.scaling_factor = np.clip(self.scaling_factor * (1 + 0.1 * np.random.randn()), 0.1, 0.9)\n            else:\n                self.scaling_factor = np.clip(self.scaling_factor * (1 + 0.05 * np.random.randn()), 0.1, 0.9)\n\n            success_count = 0\n            \n            # Update Archive\n            archive_indices = np.argsort(self.fitness)[-int(self.pop_size*self.archive_rate):]\n            self.archive = self.population[archive_indices]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.499 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0c0158df-47fd-4c76-ace8-a240ae7dd8d1"], "operator": null, "metadata": {"aucs": [0.1483263132076198, 0.4116448991140218, 0.46585457851843526, 0.8368412637686442, 0.4735539842904546, 0.7818842648595208, 0.4016831029624649, 0.577977137604081, 0.47933361236003325, 0.26557396400929023, 0.42238924668357036, 0.9994130360400544, 0.3988576095179053, 0.6484639463663342, 0.7512715266127334, 0.3468421578038202, 0.43723497857940563, 0.41513323023714577, 0.1992677952233094, 0.5095311093293742]}}
{"id": "2199620e-48d7-48a5-8075-dc471fd76e56", "fitness": 0.47876225412131246, "name": "SimplifiedAdaptiveDE", "description": "Simplified Adaptive DE with dynamic scaling factor adaptation based on population diversity and a reduced crossover rate.", "code": "import numpy as np\n\nclass SimplifiedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.scaling_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: DE/current-to-best/1\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n\n                # Dynamic scaling factor adaptation based on population diversity\n                diversity = np.std(self.fitness)\n                self.scaling_factor = 0.2 + 0.7 * diversity / (np.max(self.fitness) - np.min(self.fitness) + 1e-8)\n\n                v = self.population[i] + self.scaling_factor * (self.x_opt - self.population[i]) + self.scaling_factor * (x_r1 - x_r2)\n\n                # Crossover\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f_u = func(u)\n                self.budget -= 1\n\n                # Selection: Replace only if better\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm SimplifiedAdaptiveDE scored 0.479 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6acec84d-9c7e-4fcb-8c0b-41d9b09bcbcf"], "operator": null, "metadata": {"aucs": [0.13370730412616316, 0.5866274417243436, 0.4826432560253987, 0.1993583513903434, 0.8767499216208497, 0.9164417486935407, 0.3259204232816838, 0.42279407456756535, 0.6450525467193282, 0.35466326411015414, 0.1917431924263312, 0.9932623056263632, 0.3795860776103177, 0.3398844456656126, 0.8174325626725806, 0.3282805598274453, 0.44955689736014504, 0.2897326347361914, 0.31681839286206537, 0.5249896813798247]}}
{"id": "ce21a0d4-6d07-490f-a710-3fabf45b336a", "fitness": 0.7511571114746642, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with reduced parameter tuning and simplified mutation strategy for efficiency and faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = 0.7  # Fixed crossover rate\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)  # Sample 3 distinct indices\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                # Simplified mutation: uses only random individuals\n                F = 0.5 # Fixed scaling factor\n                v = x_r1 + F * (x_r2 - x_r3)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.751 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a7287ec4-4402-4e11-8de5-4200547c6f60"], "operator": null, "metadata": {"aucs": [0.4322739646224498, 0.23223047281868658, 0.854018123942208, 0.9362633701268066, 0.8760795300875711, 0.9069266816108487, 0.8531662520127066, 0.8429338469416545, 0.8779754409572625, 0.8020627109065371, 0.8966904136656828, 0.995992656925137, 0.46081160787457476, 0.8610836916709284, 0.8189649874254243, 0.856704872493284, 0.7660184449255192, 0.9225706955359035, 0.3118082413992621, 0.5185662235508368]}}
{"id": "dbef4cbe-a47a-4a4a-bbfb-fbece2e0948e", "fitness": 0.8057121074271896, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with reduced memory footprint, focused exploration, and adaptive bounds handling for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=4, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR\n        self.F = 0.5  # Fixed F for simplicity\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                \n                # Simplified mutation\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Adaptive bounds handling\n                v = np.where(v < func.bounds.lb, 2 * func.bounds.lb - v, v)\n                v = np.where(v > func.bounds.ub, 2 * func.bounds.ub - v, v)\n                \n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.806 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c240275d-8ab1-4e2c-8451-774c1bd0cd55"], "operator": null, "metadata": {"aucs": [0.3853117135119376, 0.6710827040259603, 0.8583445673308748, 0.9218506899011232, 0.9000352955370547, 0.9001386932356925, 0.8066349366334192, 0.8428456481130434, 0.8725257691992097, 0.8487218547616723, 0.9090610291161072, 0.9962384607102368, 0.46562000951077676, 0.8799960085295784, 0.9446373574045911, 0.8972227366816694, 0.8038058782482929, 0.929537392126919, 0.7402544454191997, 0.5403769585464313]}}
{"id": "fc61b0d5-bb23-44cb-a671-67f36d05f5aa", "fitness": 0.6410260347548824, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with a fixed mutation factor and a reduced crossover rate to promote exploration while maintaining simplicity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=5, CR=0.3, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR  # Reduced CR for exploration\n        self.F = F # Fixed mutation factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                \n                # Mutation\n                v = x_r1 + self.F * (x_r2 - x_r3)\n                v = np.minimum(np.maximum(v, func.bounds.lb), func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.641 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["df7d3dd0-29ce-4cc5-9034-0ccd0e9cf4d0"], "operator": null, "metadata": {"aucs": [0.19503725803104266, 0.32170010326394505, 0.7291502306114073, 0.8582668821892312, 0.7310988957688799, 0.8376655833734272, 0.6196628578706551, 0.6369069343897411, 0.7926001621776493, 0.4669680007736502, 0.7749305950542438, 0.9998220043369745, 0.28430741897710265, 0.6798237256503795, 0.9120420507064437, 0.8516093808851255, 0.5100706662085333, 0.8641472606895915, 0.2444329574984988, 0.5102777266411275]}}
{"id": "a56d4890-b4c6-4fee-bd02-5d9abf8169b5", "fitness": 0.6470976372091494, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a reduced parameter set and direct exploitation of the best solution for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F = 0.5 # Single scaling factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                \n                # Simplified mutation using current-to-best and difference vector\n                v = self.x_opt + self.F * (x_r1 - x_r2)\n\n                # Binomial Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element is taken from v\n                u[mask] = v[mask]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.647 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["71425379-496a-4b27-99a6-84c506290b48"], "operator": null, "metadata": {"aucs": [0.12644640067360124, 0.19483372754680883, 0.9354928607888954, 0.949707816802442, 0.37618434766837516, 0.9621690986437117, 0.2832189002561134, 0.7817409564882649, 0.9523553949682931, 0.24026440362666202, 0.9765566165744074, 0.9970975497523727, 0.374899212201778, 0.4168761588047074, 0.981762047443908, 0.9018474112941575, 0.8101159906706017, 0.9690027659181744, 0.2237680307758908, 0.48761305328382254]}}
{"id": "3c840980-085c-43f2-a71e-3a0f86fd34cf", "fitness": 0.4727828556276877, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with population-based scaling factor adaptation and reduced crossover probability for focused search.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=5, CR=0.3):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR  # Reduced CR for exploration\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            # Calculate scaling factors based on population fitness\n            fitness_diff = np.max(fitness) - fitness\n            if np.sum(fitness_diff) == 0:\n              F = 0.5 * np.ones(self.pop_size)\n            else:\n              F = 0.1 + 0.9 * (fitness_diff / np.sum(fitness_diff)) # Population-based scaling factor\n              \n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                #F = 0.5  # Single scaling factor\n                \n                # Mutation\n                v = x_r1 + F[i] * (x_r2 - x_r3)\n                v = np.minimum(np.maximum(v, func.bounds.lb), func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.473 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["df7d3dd0-29ce-4cc5-9034-0ccd0e9cf4d0"], "operator": null, "metadata": {"aucs": [0.3082584416514703, 0.3815132076959872, 0.3407418224190355, 0.3463941321168502, 0.3512358101869646, 0.3220504896727817, 0.5786701050790624, 0.40137465500297564, 0.27776085356408575, 0.8044884292708092, 0.3623543497178947, 0.9945090702744125, 0.29014735761356447, 0.6989667598858789, 0.7661983968082019, 0.3591960937591684, 0.3358965866023301, 0.6137960798142738, 0.28124752080347504, 0.6408569506145301]}}
{"id": "3a13649b-b630-43de-91e2-fdd8c0cd654a", "fitness": 0.4688144626741978, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with a fixed scaling factor, adaptive bounds handling, and reduced population size for faster convergence and lower memory usage.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=2, CR=0.7, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR\n        self.F = F\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                \n                # Simplified mutation\n                v = x_r1 + self.F * (x_r2 - x_r3)\n\n                # Adaptive bounds handling\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n                \n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.469 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["dbef4cbe-a47a-4a4a-bbfb-fbece2e0948e"], "operator": null, "metadata": {"aucs": [0.17034704674489398, 0.379481407524762, 0.3555209341779245, 0.5194147876904753, 0.2759847492035379, 0.5471437052928685, 0.6276427253388681, 0.3567806817886884, 0.6565812264788771, 0.3171756379282351, 0.48022626833228943, 0.9977397361637113, 0.2541648569595414, 0.30945452328326895, 0.6062530741574201, 0.3860877345448116, 0.4107984774405279, 0.9589311999195935, 0.25974220701464823, 0.5068182734990104]}}
{"id": "cf6a764f-27df-4fac-b0e1-18933fea7505", "fitness": 0.7866933269193284, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation and parameter adaptation based on population diversity for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=4, CR=0.7, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR\n        self.F = F\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            # Calculate population diversity (standard deviation of fitness values)\n            diversity = np.std(fitness)\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n\n                # Simplified mutation with adaptive F\n                # Adjust F based on population diversity. Smaller diversity -> smaller F (exploitation)\n                adaptive_F = self.F * (1 + 0.1 * diversity)\n                v = x_r1 + adaptive_F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.787 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["36d0e07d-f3bf-4b65-b013-47930ca9e078"], "operator": null, "metadata": {"aucs": [0.39784632814930887, 0.7612486469047179, 0.8478600996385938, 0.8461130081556218, 0.8724993361120483, 0.8934523617852725, 0.8200597458538932, 0.8378643240563115, 0.8630790729717398, 0.8387773886740231, 0.9065419394709354, 0.9928750963653792, 0.30401178272859297, 0.8686746457797697, 0.8416713755160856, 0.8665643925389083, 0.8020606065780466, 0.9280469935397968, 0.7076334953458487, 0.5369858982216713]}}
{"id": "bed50d49-0982-44a4-8a29-4b499a68352d", "fitness": 0.5192712347730976, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a single scaling factor, binomial crossover, and boundary clipping for efficient exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.9, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F = F\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False) # Increased sample size\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                \n                # Simplified mutation: uses current individual and best individual\n                v = self.population[i] + self.F * (self.x_opt - self.population[i]) + self.F * (x_r1 - x_r2) # current-to-best with exploration\n\n                # Binomial Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element is taken from v\n                u[mask] = v[mask]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.519 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["71425379-496a-4b27-99a6-84c506290b48"], "operator": null, "metadata": {"aucs": [0.5811440757388843, 0.892534534663205, 0.4617343303840926, 0.17486960985246192, 0.2476952722199941, 0.5126226920176036, 0.3450809976069368, 0.5009531695437098, 0.9458511223106769, 0.21580558700963215, 0.9653464489521915, 0.9960685118660058, 0.26848850359192333, 0.2894621992836066, 0.8147973966001097, 0.5098833282814907, 0.33750045560163155, 0.5801454983685828, 0.23757385458713243, 0.5078671069820804]}}
{"id": "db9c96a4-a60b-4e59-b8db-f732a417b870", "fitness": 0.6160763122594298, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with reduced parameter set, focusing on enhancing exploitation around the best solution with simplified parameter choices for improved efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F = 0.5  # Single scaling factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Simplified mutation: current-to-best\n                v = self.population[i] + self.F * (self.x_opt - self.population[i]) + self.F*(x_r1 - x_r2) # current-to-best with exploration\n\n                # Binomial Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element is taken from v\n                u[mask] = v[mask]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.616 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["71425379-496a-4b27-99a6-84c506290b48"], "operator": null, "metadata": {"aucs": [0.15919060052984113, 0.3106748813589617, 0.41279065331525255, 0.9625517941124121, 0.9465053235765328, 0.8458585389505451, 0.2904787187257569, 0.9165463847030132, 0.9402545164025141, 0.24872678198743292, 0.3752062586924859, 0.9988507684226414, 0.31305955014394315, 0.39224712681232665, 0.8252405733061637, 0.7055732169703646, 0.9151131102163139, 0.962987983449143, 0.29463961452851484, 0.5050298489844364]}}
{"id": "b757f41e-28e3-45e1-ac5b-3a7cfe1def3a", "fitness": 0.6594146576930321, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with a single scaling factor, adaptive population size, and adjusted crossover for efficiency and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_factor = pop_factor\n        self.CR = CR\n        self.F = 0.5  # Single scaling factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Adaptive population size based on dimension\n        self.pop_size = int(self.pop_factor * self.dim)\n        self.pop_size = max(4, min(self.pop_size, self.budget))  # Ensure pop_size is at least 4 and within budget\n\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False) # 3 distinct indices\n                x_r1, x_r2, x_r3 = self.population[idxs] # include a third random individual\n                \n                # Simplified mutation: uses current individual and best individual, plus difference vector\n                v = self.population[i] + self.F * (self.x_opt - self.population[i]) + self.F * (x_r1 - x_r2) # current-to-best/rand with diff\n                \n                # Binomial Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element is taken from v\n                u[mask] = v[mask]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.659 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["71425379-496a-4b27-99a6-84c506290b48"], "operator": null, "metadata": {"aucs": [0.15267397014863238, 0.23089276953622906, 0.4930871634153384, 0.9656655994916198, 0.9134747571270849, 0.5857394852123754, 0.28199436016543244, 0.9012317888603949, 0.7082499191668566, 0.48720393723740496, 0.9599430043953302, 0.9986002941938683, 0.2864319806341963, 0.8690258591478868, 0.9406456405373572, 0.9282273099937148, 0.693547094156307, 0.9482895612679099, 0.32148696379121133, 0.5218816953814918]}}
{"id": "fb29c874-6f4b-4649-a397-2849efb9eb4b", "fitness": 0.7764476603743625, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with reduced parameter tuning and enhanced exploration using a modified mutation strategy and adaptive F.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=4, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR\n        self.F_base = 0.5  # Base F value\n        self.F_adapt = 0.1\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n\n                # Mutation with adaptive F\n                F = self.F_base + self.F_adapt * np.random.randn()\n                F = np.clip(F, 0.1, 1.0)\n\n                v = x_r1 + F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.776 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["36d0e07d-f3bf-4b65-b013-47930ca9e078"], "operator": null, "metadata": {"aucs": [0.24151948735873352, 0.8225042640344173, 0.8275267913427949, 0.9387948097289702, 0.8869308705175689, 0.9114323330401519, 0.7888333801644577, 0.8464407438923247, 0.8597431642945691, 0.8395929794159831, 0.9274937955978246, 0.9948299718515371, 0.6708899126432987, 0.8758072100230732, 0.8799855604468022, 0.8956242991359075, 0.7965768492198405, 0.5847674069796587, 0.4044731205805293, 0.5351862572188061]}}
{"id": "8f3816ab-9585-4509-b2fb-23f2617ca55d", "fitness": 0.7204135758785395, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with a population-based archive for improved exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=4, CR=0.7, archive_factor=1.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR\n        self.F = 0.5  # Single F value\n        self.archive_size = int(self.pop_size * archive_factor)\n        self.archive = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Archive update (simplified)\n                if len(self.archive) < self.archive_size:\n                    self.archive.append(population[i].copy())\n                else:\n                    idx_to_replace = np.random.randint(0, self.archive_size)\n                    self.archive[idx_to_replace] = population[i].copy()\n                    \n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = population[idxs]\n\n                if np.random.rand() < 0.1 and len(self.archive) > 0:  # Use archive occasionally\n                     x_r3 = self.archive[np.random.randint(len(self.archive))]\n                else:\n                     x_r3 = population[np.random.choice(self.pop_size)]\n                \n                v = x_r1 + self.F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.720 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["36d0e07d-f3bf-4b65-b013-47930ca9e078"], "operator": null, "metadata": {"aucs": [0.309479982571205, 0.7325345000215099, 0.6252687549607759, 0.9452521407751269, 0.8970210418395606, 0.9202645948899472, 0.8330726990513899, 0.6859560420740747, 0.8701661906202816, 0.23776250624972328, 0.9272359547158111, 0.989745364843718, 0.33201180836196686, 0.871516504438343, 0.834601026489937, 0.9023646364233248, 0.26019651518336173, 0.9403115776600837, 0.787576339655907, 0.5059333367447392]}}
{"id": "bfa39420-ba27-49da-851d-50a053246b40", "fitness": 0.18078850161929413, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a self-adaptive scaling factor and dynamic population size reduction for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_factor=4, CR=0.7, initial_F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(budget, dim * pop_factor)\n        self.CR = CR\n        self.F = initial_F  # Initial scaling factor\n        self.F_decay = 0.995 # Decay rate for F\n        self.min_pop_size = 4 # Minimal pop size\n        self.pop_reduction_factor = 0.95 # Pop size reduction\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx].copy()\n\n        while self.budget > 0 and self.pop_size > self.min_pop_size:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n\n                # Simplified mutation with self-adaptive F\n                v = x_r1 + self.F * (x_r2 - x_r3)\n                v = np.clip(v, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                u = population[i].copy()\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                u[mask] = v[mask]\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < fitness[i]:\n                    population[i] = u\n                    fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n            \n            # Reduce population size gradually if budget allows\n            if self.budget > self.pop_size * 2 and self.pop_size > self.min_pop_size:\n                num_to_remove = int(self.pop_size * (1-self.pop_reduction_factor))\n                idxs_to_remove = np.argsort(fitness)[-num_to_remove:] # Remove the worst individuals\n                population = np.delete(population, idxs_to_remove, axis=0)\n                fitness = np.delete(fitness, idxs_to_remove)\n                self.pop_size = len(population)\n                \n            self.F *= self.F_decay # Decay the scaling factor\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.181 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["36d0e07d-f3bf-4b65-b013-47930ca9e078"], "operator": null, "metadata": {"aucs": [0.0802751065141607, 0.1111028972252952, 0.25451858000667904, 0.20642947371802434, 0.13649739935410998, 0.19386980162182121, 0.17584089120982516, 0.22737284126247526, 0.15269828572725308, 0.13334661933190473, 0.1487063953854596, 0.2185207413453759, 0.13096119176434096, 0.11956039397663354, 0.22068908021073952, 0.21223387353356815, 0.17725157643390832, 0.16782520963162129, 0.11990747222806708, 0.4281622019046194]}}
{"id": "18a722f1-23f2-4a17-a23d-c260b0ce8763", "fitness": 0.5685098845857792, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with adaptive scaling and binomial crossover, focusing on exploration around the best solution and reducing parameter choices for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR\n        self.F = 0.5  # Single scaling factor\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n                \n                # Mutation: current-to-best with exploration\n                v = self.population[i] + self.F * (self.x_opt - self.population[i]) + self.F * (x_r1 - x_r2)\n\n                # Binomial Crossover\n                j_rand = np.random.randint(self.dim)\n                u = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True  # Ensure at least one element is taken from v\n                u[mask] = v[mask]\n\n                # Boundary handling using clipping\n                u = np.clip(u, func.bounds.lb, func.bounds.ub)\n\n\n                f_u = func(u)\n                self.budget -= 1\n\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.569 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["71425379-496a-4b27-99a6-84c506290b48"], "operator": null, "metadata": {"aucs": [0.3657106950326118, 0.8798667134856584, 0.5018087721741529, 0.9593497280977981, 0.24676501826541564, 0.9398915366618166, 0.37704863059864624, 0.3797116523487347, 0.34017339600158925, 0.25902227373082287, 0.35081335999319063, 0.9997632464448744, 0.39740412493209765, 0.3805992717037975, 0.9635167026234686, 0.4672873189869865, 0.8639737283130573, 0.9441960129103322, 0.24592625074108987, 0.5073692586694438]}}
