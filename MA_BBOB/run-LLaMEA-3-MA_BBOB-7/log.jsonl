{"id": "4f0f6d85-de08-4472-9842-210f7e063e5a", "fitness": -Infinity, "name": "CMAES", "description": "Covariance matrix adaptation evolution strategy with orthogonal sampling and adaptive step size control.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.m = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.chiN = np.sqrt(self.dim) * (1 - (1 / (4 * self.dim)) + (1 / (21 * self.dim**2)))\n        self.c_sigma = (self.mu / (self.dim + self.mu))**0.5\n        self.d_sigma = 1 + 2 * max(0, np.sqrt((self.mu / (self.dim + self.mu))) - 1) + 0.2 * max(0, 1 - (self.budget / (self.dim * self.popsize)))\n        self.c_c = (4 + (self.mu / self.dim)) / (self.dim + 4 + (2 * self.mu / self.dim))\n        self.c_1 = 2 / ((self.dim + 1.3)**2 + self.mu)\n        self.c_mu = min(1 - self.c_1, 2 * (self.mu - 2 + (1/self.mu)) / ((self.dim + 2)**2 + (2 * self.mu / 3)))\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            B = np.linalg.cholesky(self.C)\n            x = self.m[:, np.newaxis] + self.sigma * B @ z\n            x = np.clip(x, func.bounds.lb, func.bounds.ub)\n            f = np.array([func(xi) for xi in x.T])\n            evals += self.popsize\n\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_mu = x[:, idx[:self.mu]]\n            z_mu = z[:, idx[:self.mu]]\n            self.m = np.sum(x_mu * self.weights, axis=1)\n            zmean = np.sum(z_mu * self.weights, axis=1)\n\n            self.ps = (1 - self.c_sigma) * self.ps + np.sqrt(self.c_sigma * (2 - self.c_sigma)) * (B @ zmean)\n            self.pc = (1 - self.c_c) * self.pc + np.sqrt(self.c_c * (2 - self.c_c)) * (self.ps / self.sigma)\n            \n            hsig = np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.c_sigma)**(2 * (evals // self.popsize))) < (1.4 + (2 / (self.dim + 1))) * self.chiN\n            \n            dhsig = (1 - hsig) * self.c_c * (2 - self.c_c)\n\n            self.C = (1 - self.c_1 - self.c_mu + self.c_1 * dhsig) * self.C + self.c_1 * np.outer(self.pc, self.pc)\n            for i in range(self.mu):\n                self.C += self.c_mu * self.weights[i] * np.outer(B @ z_mu[:, i], B @ z_mu[:, i])\n\n            self.sigma = self.sigma * np.exp((self.c_sigma / self.d_sigma) * ((np.linalg.norm(self.ps) / self.chiN) - 1))\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            self.C = (self.C + self.C.T) / 2\n            self.C = np.linalg.qr(self.C)[0] @ np.diag(np.where(np.linalg.eigvalsh(self.C) > 1e-10, 1, 1e-10)) @ np.linalg.qr(self.C)[0].T\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,6) (2,) (2,) .", "error": "", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "4877f9cb-876b-4338-80b1-14ae9ef76dd9", "fitness": -Infinity, "name": "CMAES", "description": "Covariance Matrix Adaptation Evolution Strategy with orthogonal search directions and adaptive step size control.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov_mean=None, c_cov_sigma=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.damps = damp if damp is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff - 1) + (2/self.cs))\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / ( (self.dim + 2)**2 + self.mueff)\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.xmean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.sigma = 0.3\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.C = np.eye(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.pc = np.zeros(self.dim)\n        \n        used_budget = 0\n        while used_budget < self.budget:\n            arz = np.random.randn(self.dim, self.popsize)\n            arx = self.xmean[:,None] + self.sigma * (self.B @ (self.D * arz))\n            arfitness = np.zeros(self.popsize)\n            \n            for k in range(self.popsize):\n                x = arx[:, k]\n                \n                if np.any(x < func.bounds.lb) or np.any(x > func.bounds.ub):\n                    arfitness[k] = np.Inf\n                else:\n                  f = func(x)\n                  arfitness[k] = f\n                  used_budget +=1\n                  if f < self.f_opt:\n                      self.f_opt = f\n                      self.x_opt = x\n                  \n                  if used_budget >= self.budget:\n                      break\n                      \n            if used_budget >= self.budget:\n                break\n\n            arindex = np.argsort(arfitness)\n            arfitness = arfitness[arindex]\n            xold = self.xmean.copy()\n            self.xmean = arx[:, arindex[:self.mu]] @ self.weights\n            \n            self.pc = (1 - self.cs) * self.pc + np.sqrt(self.c_cov_mean * self.mueff) * (self.xmean - xold) / self.sigma\n            self.ps = (1 - self.damps) * self.ps + np.sqrt(self.c_cov_sigma * self.mueff) * (self.B @ (self.D @ ((self.xmean - xold) / self.sigma)))\n            \n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.damps)**(2*used_budget/self.popsize))/self.chiN) < (1.4 + 2/(self.dim+1))\n            \n            self.C = (1- self.c_cov_sigma) * self.C + self.c_cov_sigma * (1/self.mueff) * (self.pc[:,None] @ self.pc[None,:]) \\\n                     + self.c_cov_sigma * (1 - (1/self.mueff)) * np.sum([w * ((self.B @ (self.D * arz[:,i:i+1])) @ (self.B @ (self.D * arz[:,i:i+1])).T) for i, w in enumerate(self.weights)], axis=0)\n            \n            self.sigma = self.sigma * np.exp((self.cs/self.damps) * (np.linalg.norm(self.ps)/self.chiN - 1))\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(np.maximum(self.D, 1e-16))\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "3c516fa3-e11f-4216-9832-85014b1cc1f8", "fitness": 0.3479273380691323, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Archive and Stochastic Ranking for Constraints.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The mutation factor.\n            CR (float): The crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_size = pop_size  # Archive size equal to population size\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    else:\n                         # Replace a random element in the archive\n                        replace_idx = np.random.randint(self.archive_size)\n                        self.archive[replace_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                elif len(self.archive) > 0 and np.random.rand() < 0.1:  # 10% chance to learn from archive\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b = np.random.choice(idxs, 2, replace=False)\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                        else:\n                            replace_idx = np.random.randint(self.archive_size)\n                            self.archive[replace_idx] = self.population[i].copy()\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.348 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.3146224051005231, 0.7291596091068737, 0]}}
{"id": "c3dcca4c-345f-42ba-849d-3c344b3555ec", "fitness": 0.4156493818230791, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Archive and stochastic ranking.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, Cr=0.9, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.archive_size = archive_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.archive = []\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                if idxs[0] < self.pop_size:\n                    a = self.pop[idxs[0]]\n                else:\n                    a = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    b = self.pop[idxs[1]]\n                else:\n                    b = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    c = self.pop[idxs[2]]\n                else:\n                    c = self.archive[idxs[2] - self.pop_size]\n\n                mutant = self.pop[i] + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.copy(self.pop[i])\n                trial[cross_mask] = mutant[cross_mask]\n\n                # Selection\n                f_trial = func(trial)\n                self.evals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.archive.append(self.pop[i].copy())\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    self.pop[i] = trial\n                    self.fitness[i] = f_trial\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                \n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.416 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.14849338721115324, 0.2729999307605593, 0.38213664939680314, 0.5264421117600524, 0.312133465068018, 0.4476238519171798, 0.3136988102073831, 0.34491502908796867, 0.3278956558298459, 0.21657741058592106, 0.5592783981091991, 0.9919150656485259, 0.38430427450447535, 0.31990414987445814, 0.7676659854166433, 0.4536589527027466, 0.3370646256607236, 0.5413756632567255, 0.18179099892298944, 0.4831132205402099]}}
{"id": "93f52931-f4a7-4a0b-a474-0b7078aaf175", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with jitter and adaptive F and Cr.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.archive = []\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptive F and Cr\n                F = np.random.uniform(0.3, 0.9)\n                Cr = np.random.uniform(0.1, 0.9)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                a = self.pop[idxs[0] % self.pop_size] if idxs[0] < self.pop_size else self.archive[idxs[0] - self.pop_size]\n                b = self.pop[idxs[1] % self.pop_size] if idxs[1] < self.pop_size else self.archive[idxs[1] - self.pop_size]\n                c = self.pop[idxs[2] % self.pop_size] if idxs[2] < self.pop_size else self.archive[idxs[2] - self.pop_size]\n                \n                mutant = self.pop[i] + F * (b - c)\n\n                # Jitter\n                jitter_mask = np.random.rand(self.dim) < 0.05\n                mutant[jitter_mask] = np.random.uniform(lb, ub, size=np.sum(jitter_mask))\n\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial = np.copy(self.pop[i])\n                trial[cross_mask] = mutant[cross_mask]\n\n                # Selection\n                f_trial = func(trial)\n                self.evals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.archive.append(self.pop[i].copy())\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    self.pop[i] = trial\n                    self.fitness[i] = f_trial\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                \n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (0,) and arg 1 with shape (2,)..", "error": "", "parent_ids": ["c3dcca4c-345f-42ba-849d-3c344b3555ec"], "operator": null, "metadata": {}}
{"id": "c4e86b5e-0f44-4e9f-ac7a-3778018dc19e", "fitness": -Infinity, "name": "CMAES", "description": "Simplified CMA-ES with rank-one update and clipping of eigenvalues for covariance matrix adaptation.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.m = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.c_sigma = (self.mu / (self.dim + self.mu))**0.5\n        self.c_c = (4 + (self.mu / self.dim)) / (self.dim + 4 + (2 * self.mu / self.dim))\n        self.c_1 = 2 / ((self.dim + 1.3)**2 + self.mu)\n        self.c_mu = min(1 - self.c_1, 2 * (self.mu - 2 + (1/self.mu)) / ((self.dim + 2)**2 + (2 * self.mu / 3)))\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            C_sqrt = np.linalg.cholesky(self.C)\n            x = self.m[:, np.newaxis] + self.sigma * C_sqrt @ z\n            x = np.clip(x, func.bounds.lb, func.bounds.ub)\n            f = np.array([func(xi) for xi in x.T])\n            evals += self.popsize\n\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_mu = x[:, idx[:self.mu]]\n            z_mu = z[:, idx[:self.mu]]\n            self.m = np.sum(x_mu * self.weights, axis=1)\n            zmean = np.sum(z_mu * self.weights, axis=1)\n\n            self.pc = (1 - self.c_c) * self.pc + np.sqrt(self.c_c * (2 - self.c_c)) * zmean\n            self.C = (1 - self.c_1 - self.c_mu) * self.C + self.c_1 * np.outer(self.pc, self.pc)\n            for i in range(self.mu):\n                self.C += self.c_mu * self.weights[i] * np.outer(z_mu[:, i], z_mu[:, i])\n\n            self.sigma = self.sigma * np.exp((self.c_sigma / 0.5) * ((np.linalg.norm(self.pc) / np.sqrt(self.dim)) - 1))\n\n            eigenvalues = np.linalg.eigvalsh(self.C)\n            min_eig = np.min(eigenvalues)\n            if min_eig < 1e-10:\n                self.C += (1e-10 - min_eig) * np.eye(self.dim)\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,6) (2,) (2,) .", "error": "", "parent_ids": ["4f0f6d85-de08-4472-9842-210f7e063e5a"], "operator": null, "metadata": {}}
{"id": "826faa26-cd0f-42af-8f20-6da62411c26c", "fitness": -Infinity, "name": "CMAES", "description": "CMA-ES with rank-one update simplification and bound constraints handling.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.m = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.chiN = np.sqrt(self.dim) * (1 - (1 / (4 * self.dim)) + (1 / (21 * self.dim**2)))\n        self.c_sigma = (self.mu / (self.dim + self.mu))**0.5\n        self.d_sigma = 1 + 2 * max(0, np.sqrt((self.mu / (self.dim + self.mu))) - 1) + 0.2 * max(0, 1 - (self.budget / (self.dim * self.popsize)))\n        self.c_c = (4 + (self.mu / self.dim)) / (self.dim + 4 + (2 * self.mu / self.dim))\n        self.c_1 = 2 / ((self.dim + 1.3)**2 + self.mu)\n        self.c_mu = min(1 - self.c_1, 2 * (self.mu - 2 + (1/self.mu)) / ((self.dim + 2)**2 + (2 * self.mu / 3)))\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        evals = 0\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        while evals < self.budget:\n            z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            B = np.linalg.cholesky(self.C)\n            x = self.m[:, np.newaxis] + self.sigma * B @ z\n            x = np.clip(x, lb, ub)\n            f = np.array([func(xi) for xi in x.T])\n            evals += self.popsize\n\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_mu = x[:, idx[:self.mu]]\n            z_mu = z[:, idx[:self.mu]]\n            self.m = np.sum(x_mu * self.weights, axis=1)\n            zmean = np.sum(z_mu * self.weights, axis=1)\n\n            self.ps = (1 - self.c_sigma) * self.ps + np.sqrt(self.c_sigma * (2 - self.c_sigma)) * (B @ zmean)\n            self.pc = (1 - self.c_c) * self.pc + np.sqrt(self.c_c * (2 - self.c_c)) * self.ps\n\n            hsig = np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.c_sigma)**(2 * (evals // self.popsize))) < (1.4 + (2 / (self.dim + 1))) * self.chiN\n            dhsig = (1 - hsig) * self.c_c * (2 - self.c_c)\n\n            self.C = (1 - self.c_1 - self.c_mu + self.c_1 * dhsig) * self.C + self.c_1 * np.outer(self.pc, self.pc)\n            self.sigma = self.sigma * np.exp((self.c_sigma / self.d_sigma) * ((np.linalg.norm(self.ps) / self.chiN) - 1))\n\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            self.C = (self.C + self.C.T) / 2\n            try:\n                np.linalg.cholesky(self.C)\n            except np.linalg.LinAlgError:\n                self.C = self.C + 1e-6 * np.eye(self.dim)\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,6) (2,) (2,) .", "error": "", "parent_ids": ["4f0f6d85-de08-4472-9842-210f7e063e5a"], "operator": null, "metadata": {}}
{"id": "91be5e77-86b0-46e2-a637-b943a1251d8f", "fitness": -Infinity, "name": "CMAES", "description": "Simplified CMA-ES implementation with corrected broadcasting and eigenvalue handling for improved stability and efficiency.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.m = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.chiN = np.sqrt(self.dim) * (1 - (1 / (4 * self.dim)) + (1 / (21 * self.dim**2)))\n        self.c_sigma = (self.mu / (self.dim + self.mu))**0.5\n        self.d_sigma = 1 + 2 * max(0, np.sqrt((self.mu / (self.dim + self.mu))) - 1) + 0.2 * max(0, 1 - (self.budget / (self.dim * self.popsize)))\n        self.c_c = (4 + (self.mu / self.dim)) / (self.dim + 4 + (2 * self.mu / self.dim))\n        self.c_1 = 2 / ((self.dim + 1.3)**2 + self.mu)\n        self.c_mu = min(1 - self.c_1, 2 * (self.mu - 2 + (1/self.mu)) / ((self.dim + 2)**2 + (2 * self.mu / 3)))\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            z = np.random.normal(0, 1, size=(self.dim, self.popsize))\n            C_sqrt = np.linalg.cholesky(self.C)\n            x = self.m + self.sigma * C_sqrt @ z\n            x = np.clip(x, func.bounds.lb, func.bounds.ub)\n            f = np.array([func(xi) for xi in x.T])\n            evals += self.popsize\n\n            if np.min(f) < self.f_opt:\n                self.f_opt = np.min(f)\n                self.x_opt = x[:, np.argmin(f)]\n\n            idx = np.argsort(f)\n            x_mu = x[:, idx[:self.mu]]\n            z_mu = z[:, idx[:self.mu]]\n            self.m = np.sum(x_mu * self.weights, axis=1)\n            zmean = np.sum(z_mu * self.weights, axis=1)\n\n            self.ps = (1 - self.c_sigma) * self.ps + np.sqrt(self.c_sigma * (2 - self.c_sigma)) * (C_sqrt @ zmean)\n            self.pc = (1 - self.c_c) * self.pc + np.sqrt(self.c_c * (2 - self.c_c)) * (self.ps / self.sigma)\n            \n            hsig = np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.c_sigma)**(2 * (evals // self.popsize))) < (1.4 + (2 / (self.dim + 1))) * self.chiN\n            dhsig = (1 - hsig) * self.c_c * (2 - self.c_c)\n\n            self.C = (1 - self.c_1 - self.c_mu + self.c_1 * dhsig) * self.C + self.c_1 * np.outer(self.pc, self.pc)\n            for i in range(self.mu):\n                self.C += self.c_mu * self.weights[i] * np.outer(C_sqrt @ z_mu[:, i], C_sqrt @ z_mu[:, i])\n\n            self.sigma = self.sigma * np.exp((self.c_sigma / self.d_sigma) * ((np.linalg.norm(self.ps) / self.chiN) - 1))\n\n            self.C = (self.C + self.C.T) / 2\n            \n            # Ensure C is positive definite\n            eigval, eigvec = np.linalg.eigh(self.C)\n            eigval = np.where(eigval > 1e-10, eigval, 1e-10)\n            self.C = eigvec @ np.diag(eigval) @ eigvec.T\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["4f0f6d85-de08-4472-9842-210f7e063e5a"], "operator": null, "metadata": {}}
{"id": "3ddb5e49-5198-429f-b4fa-ccd53459126a", "fitness": -Infinity, "name": "CMAES", "description": "Covariance Matrix Adaptation Evolution Strategy with adaptive step size and simplified covariance update to avoid broadcasting errors.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov_mean=None, c_cov_sigma=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.damps = damp if damp is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff - 1) + (2/self.cs))\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / ( (self.dim + 2)**2 + self.mueff)\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.xmean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.sigma = 0.3\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.C = np.eye(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.pc = np.zeros(self.dim)\n        \n        used_budget = 0\n        while used_budget < self.budget:\n            arz = np.random.randn(self.dim, self.popsize)\n            arx = self.xmean[:,None] + self.sigma * (self.B @ (self.D * arz))\n            arfitness = np.zeros(self.popsize)\n            \n            for k in range(self.popsize):\n                x = arx[:, k]\n                \n                if np.any(x < func.bounds.lb) or np.any(x > func.bounds.ub):\n                    arfitness[k] = np.Inf\n                else:\n                  f = func(x)\n                  arfitness[k] = f\n                  used_budget +=1\n                  if f < self.f_opt:\n                      self.f_opt = f\n                      self.x_opt = x\n                  \n                  if used_budget >= self.budget:\n                      break\n                      \n            if used_budget >= self.budget:\n                break\n\n            arindex = np.argsort(arfitness)\n            arfitness = arfitness[arindex]\n            xold = self.xmean.copy()\n            self.xmean = arx[:, arindex[:self.mu]] @ self.weights\n\n            self.pc = (1 - self.cs) * self.pc + np.sqrt(self.c_cov_mean * self.mueff) * (self.xmean - xold) / self.sigma\n            self.ps = (1 - self.damps) * self.ps + np.sqrt(self.c_cov_sigma * self.mueff) * (self.B @ (self.D @ ((self.xmean - xold) / self.sigma)))\n            \n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.damps)**(2*used_budget/self.popsize))/self.chiN) < (1.4 + 2/(self.dim+1))\n            \n            self.C = (1- self.c_cov_sigma) * self.C + self.c_cov_sigma * (1/self.mueff) * np.outer(self.pc, self.pc) \\\n                     + self.c_cov_sigma * (1 - (1/self.mueff)) * np.sum([w * np.outer(self.B @ (self.D * arz[:,i]), self.B @ (self.D * arz[:,i])) for i, w in enumerate(self.weights)], axis=0)\n            \n            self.sigma = self.sigma * np.exp((self.cs/self.damps) * (np.linalg.norm(self.ps)/self.chiN - 1))\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            try:\n                self.D, self.B = np.linalg.eigh(self.C)\n                self.D = np.sqrt(np.maximum(self.D, 1e-16))\n            except np.linalg.LinAlgError:\n                self.C = self.C + 1e-6 * np.eye(self.dim)\n                self.D, self.B = np.linalg.eigh(self.C)\n                self.D = np.sqrt(np.maximum(self.D, 1e-16))\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["4877f9cb-876b-4338-80b1-14ae9ef76dd9"], "operator": null, "metadata": {}}
{"id": "bff9d5e8-eb9d-4923-acfc-5c56db88249c", "fitness": 0.41227624101744575, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with adaptive F and Cr values based on success and archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = 0.5\n        self.Cr = 0.9\n        self.F_memory = [0.5] * 10\n        self.Cr_memory = [0.9] * 10\n        self.memory_index = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.archive = []\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                a = self.pop[idxs[0] % self.pop_size] if idxs[0] < self.pop_size else self.archive[idxs[0] - self.pop_size]\n                b = self.pop[idxs[1] % self.pop_size] if idxs[1] < self.pop_size else self.archive[idxs[1] - self.pop_size]\n                c = self.pop[idxs[2] % self.pop_size] if idxs[2] < self.pop_size else self.archive[idxs[2] - self.pop_size]\n\n                mutant = self.pop[i] + self.F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.copy(self.pop[i])\n                trial[cross_mask] = mutant[cross_mask]\n\n                # Selection\n                f_trial = func(trial)\n                self.evals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.archive.append(self.pop[i].copy())\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    \n                    delta_f = abs(self.fitness[i] - f_trial)\n\n                    # Update F and Cr adaptively\n                    self.F_memory[self.memory_index] = self.F\n                    self.Cr_memory[self.memory_index] = self.Cr\n                    self.memory_index = (self.memory_index + 1) % len(self.F_memory)\n                    \n                    self.F = 0.5 * (1 + np.random.normal(0, 0.1))\n                    self.F = np.clip(self.F, 0.1, 1.0)\n                    self.Cr = 0.9 * (1 + np.random.normal(0, 0.1))\n                    self.Cr = np.clip(self.Cr, 0.1, 1.0)\n\n                    self.pop[i] = trial\n                    self.fitness[i] = f_trial\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.412 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c3dcca4c-345f-42ba-849d-3c344b3555ec"], "operator": null, "metadata": {"aucs": [0.16104015476580513, 0.2924391682391133, 0.3833824030882015, 0.5345164993752074, 0.3056900284356353, 0.453975152724159, 0.29569672803772307, 0.3570204872082986, 0.3432278884526866, 0.19410765014698195, 0.5585391144872917, 0.9696069610923204, 0.37345697914719644, 0.31662167896915583, 0.7428622938795602, 0.4120232949731879, 0.3385947040248578, 0.530804563546202, 0.19415709518496638, 0.48776197457036496]}}
{"id": "6b1920b5-3939-4925-af94-2a0bad14effc", "fitness": 0.4163822015700929, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with improved parameter adaptation and a combined population for mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptive F and Cr\n                F = np.random.normal(self.F, 0.1, 1)[0]\n                Cr = np.random.normal(self.Cr, 0.1, 1)[0]\n                F = np.clip(F, 0.1, 1.0)\n                Cr = np.clip(Cr, 0.1, 1.0)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs[0]], self.pop[idxs[1]], self.pop[idxs[2]]\n\n                mutant = self.pop[i] + F * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial = np.copy(self.pop[i])\n                trial[cross_mask] = mutant[cross_mask]\n\n                # Selection\n                f_trial = func(trial)\n                self.evals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.pop[i] = trial\n                    self.fitness[i] = f_trial\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                \n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.416 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c3dcca4c-345f-42ba-849d-3c344b3555ec"], "operator": null, "metadata": {"aucs": [0.15341076146014787, 0.3044408599580415, 0.390668866402924, 0.5243578052151762, 0.30932483064916727, 0.4665415855122037, 0.2941953645574428, 0.34911009447674357, 0.3169053872728226, 0.19564169161335798, 0.6027742272945343, 0.9982122606643304, 0.39367482167216594, 0.32028556275830755, 0.7542930451700509, 0.4327704798458061, 0.3299322098841435, 0.5251262545804768, 0.18452731098053332, 0.4814506114334829]}}
{"id": "3ab9f159-5f59-41ae-b924-f984068ecb6a", "fitness": 0.7458048702952947, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified archive update and parameter adaptation using a success-based learning strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, archive_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            archive_size (int): The size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_size = archive_size\n        self.success_F = []\n        self.success_CR = []\n        self.memory_F = [F] * 10\n        self.memory_CR = [CR] * 10\n        self.memory_idx = 0\n        self.sf_prob = 0.1\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation\n                self.F = self.memory_F[self.memory_idx]\n                self.CR = self.memory_CR[self.memory_idx]\n                self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n                \n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    delta = abs(self.fitness[i] - f)\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n                    \n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                \n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b = np.random.choice(idxs, 2, replace=False)\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        delta = abs(self.fitness[i] - f)\n                        self.success_F.append(self.F)\n                        self.success_CR.append(self.CR)\n\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n                    \n                if self.evals >= self.budget:\n                    break\n            \n            # Update memory every generation\n            if self.success_F:\n                self.memory_F[self.memory_idx] = np.mean(self.success_F)\n                self.memory_CR[self.memory_idx] = np.mean(self.success_CR)\n            self.success_F = []\n            self.success_CR = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.746 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3c516fa3-e11f-4216-9832-85014b1cc1f8"], "operator": null, "metadata": {"aucs": [0.42957360650686705, 0.7443545225153002, 0.7409343641382997, 0.9053587620220186, 0.7823204061098086, 0.8330303564058208, 0.7560867759902584, 0.7325231556074154, 0.8236041396109326, 0.7466161222490063, 0.892179914405854, 0.9963800781856557, 0.6358688155281387, 0.7941886763013316, 0.9357680654120952, 0.8336001890753952, 0.7231302422592742, 0.8647743432871268, 0]}}
{"id": "e3566cfe-ab6a-403e-bc5d-3ac1ede57f95", "fitness": 0.735886947886443, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive parameters and reduced archive usage for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_size = pop_size // 2  # Reduced archive size\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptive F and CR\n                F = np.random.normal(self.F, 0.1)\n                CR = np.random.normal(self.CR, 0.1)\n                F = np.clip(F, 0.1, 1.0)\n                CR = np.clip(CR, 0.1, 1.0)\n                \n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    elif len(self.archive) > 0:\n                        replace_idx = np.random.randint(len(self.archive))\n                        self.archive[replace_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.736 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3c516fa3-e11f-4216-9832-85014b1cc1f8"], "operator": null, "metadata": {"aucs": [0.47673532535372465, 0.7124959392701149, 0.7142489201397936, 0.8998924359425251, 0.8102470434352207, 0.8198392467262023, 0.7467271285607997, 0.7354532842822867, 0.7891370909236044, 0.7491276032090892, 0.8853367453214748, 0.9909341441321542, 0.4479964422320696, 0.7984534587773058, 0.9260318498072435, 0.8360959807743664, 0.6631915318474327, 0.8780518284316793, 0.3122888763117174, 0.5254540822500557]}}
{"id": "cbe35048-4984-487e-a453-1426eb7edaf8", "fitness": 0.727136564650604, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, archiving, and parameter adaptation based on success.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.Cr = Cr\n        self.archive = []\n        self.sf = []\n        self.scr = []\n        self.memory_cr = [0.9] * 10\n        self.memory_f = [0.5] * 10\n        self.memory_idx = 0\n        self.p_best = 0.11 # select top p_best individuals\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.evals = self.pop_size\n        \n        while self.evals < self.budget:\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:max(1, int(self.p_best * self.pop_size))]  # at least select one\n            for i in range(self.pop_size):\n                # Adaptation of F and CR\n                self.Cr = np.random.choice(self.memory_cr)\n                self.F = np.random.choice(self.memory_f)\n\n                # Mutation: pbest individual\n                p_best_idx = np.random.choice(top_indices)\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                a, b = self.pop[idxs[0]], self.pop[idxs[1]]\n                mutant = self.pop[i] + self.F * (self.pop[p_best_idx] - self.pop[i]) + self.F * (a - b)\n\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial = np.copy(self.pop[i])\n                trial[cross_mask] = mutant[cross_mask]\n\n                # Selection\n                f_trial = func(trial)\n                self.evals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.archive.append(self.pop[i].copy())\n                    if len(self.archive) > self.archive_size:\n                        self.archive.pop(0)\n                    self.pop[i] = trial\n                    self.fitness[i] = f_trial\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                    self.sf.append(self.F)\n                    self.scr.append(self.Cr)\n\n                    self.memory_cr[self.memory_idx] = self.Cr\n                    self.memory_f[self.memory_idx] = self.F\n                    self.memory_idx = (self.memory_idx + 1) % len(self.memory_cr)\n\n                if self.evals >= self.budget:\n                    break\n\n            if self.sf:\n                self.F = np.mean(self.sf)\n                self.Cr = np.mean(self.scr)\n\n            self.sf = []\n            self.scr = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.727 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c3dcca4c-345f-42ba-849d-3c344b3555ec"], "operator": null, "metadata": {"aucs": [0.482348994800031, 0.23460654458267505, 0.8397225235699908, 0.9381457693058683, 0.8676930815848876, 0.8879298446664944, 0.36173023714439867, 0.8200644390187319, 0.8748798760076228, 0.7943071342382086, 0.9279791338791196, 0.9910077296032278, 0.36334112135504837, 0.8557944488684042, 0.9375082670330351, 0.8895577736921614, 0.7823320511464764, 0.9225593284530392, 0.2543027820491789, 0.5169202120134806]}}
{"id": "06114b7f-55bc-4eba-8f7d-d0997cc1d59b", "fitness": -Infinity, "name": "CMAES", "description": "Covariance matrix adaptation evolution strategy with clipping to handle out-of-bounds individuals and simplified rank-one update.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov_mean=None, c_cov_sigma=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 1/2) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n        self.cs = cs\n        self.damps = damp if damp is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff - 1) + (2/self.cs))\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / ( (self.dim + 2)**2 + self.mueff)\n        self.chiN = self.dim**0.5 * (1 - 1/(4*self.dim) + 1/(21*self.dim**2))\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.xmean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n        self.sigma = 0.3\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.C = np.eye(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.pc = np.zeros(self.dim)\n        \n        used_budget = 0\n        while used_budget < self.budget:\n            arz = np.random.randn(self.dim, self.popsize)\n            arx = self.xmean[:,None] + self.sigma * (self.B @ (self.D * arz))\n\n            # Clip individuals to remain within bounds\n            for k in range(self.popsize):\n                arx[:, k] = np.clip(arx[:, k], func.bounds.lb, func.bounds.ub)\n                \n            arfitness = np.zeros(self.popsize)\n            \n            for k in range(self.popsize):\n                x = arx[:, k]\n                f = func(x)\n                arfitness[k] = f\n                used_budget +=1\n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = x\n                \n                if used_budget >= self.budget:\n                    break\n                      \n            if used_budget >= self.budget:\n                break\n\n            arindex = np.argsort(arfitness)\n            arfitness = arfitness[arindex]\n            xold = self.xmean.copy()\n            self.xmean = arx[:, arindex[:self.mu]] @ self.weights\n\n            # Rank-one update\n            delta_x = self.xmean - xold\n            self.pc = (1 - self.cs) * self.pc + np.sqrt(self.c_cov_mean * self.mueff) * delta_x / self.sigma\n            self.ps = (1 - self.damps) * self.ps + np.sqrt(self.c_cov_sigma * self.mueff) * (self.B @ (self.D @ (delta_x / self.sigma)))\n            \n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.damps)**(2*used_budget/self.popsize))/self.chiN) < (1.4 + 2/(self.dim+1))\n            \n            self.C = (1- self.c_cov_sigma) * self.C + self.c_cov_sigma * (self.pc[:,None] @ self.pc[None,:]) # simplified rank-one\n            \n            self.sigma = self.sigma * np.exp((self.cs/self.damps) * (np.linalg.norm(self.ps)/self.chiN - 1))\n            self.C = np.triu(self.C) + np.triu(self.C, 1).T\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(np.maximum(self.D, 1e-16))\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["4877f9cb-876b-4338-80b1-14ae9ef76dd9"], "operator": null, "metadata": {}}
{"id": "e6fca405-981d-4d44-a9a6-db894fcf4a43", "fitness": 0.6150774591699685, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified archive usage and parameter adaptation based on success rate.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, archive_size_factor=2):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            archive_size_factor (int): determines archive size relative to pop size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_size = pop_size * archive_size_factor  # Archive size related to population size\n        self.success_rate = 0.0\n        self.success_history = []\n        self.F_history = []\n        self.CR_history = []\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            successful_mutations = 0\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    successful_mutations += 1\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    else:\n                         # Replace a random element in the archive\n                        replace_idx = np.random.randint(len(self.archive))\n                        self.archive[replace_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            #Adapt F and CR based on success rate\n            self.success_rate = successful_mutations / self.pop_size if self.pop_size > 0 else 0.0\n            self.success_history.append(self.success_rate)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n            self.F = np.clip(self.F + 0.1 * (self.success_rate - 0.5), 0.1, 0.9) # Adjust F\n            self.CR = np.clip(self.CR + 0.1 * (self.success_rate - 0.5), 0.1, 0.9) # Adjust CR\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.615 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3c516fa3-e11f-4216-9832-85014b1cc1f8"], "operator": null, "metadata": {"aucs": [0.21921497336922835, 0.3041559475265244, 0.5296026037912807, 0.9158641924165365, 0.632341277046739, 0.8416501980789428, 0.6943368508432592, 0.6161783035798434, 0.6085698724669174, 0.5042874504513737, 0.8530445535076885, 0.9917569013702491, 0.2472305116180129, 0.6561568002414693, 0.7368963996329629, 0.8594121939320861, 0.45348213151782757, 0.7615541375259052, 0.34804244006481133, 0.5277714444177117]}}
{"id": "209b19b1-9999-43c0-9e6e-d7be47a03bff", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with periodic restart and adaptive population size for improved exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, restart_interval=2000):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): Initial population size. Dynamically adjusted.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            restart_interval (int): Number of evaluations before population restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.restart_interval = restart_interval\n        self.evals = 0\n        self.generation = 0\n        self.lb = -5.0\n        self.ub = 5.0\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = None\n        self.fitness = None\n        self.min_pop_size = 10\n        self.max_pop_size = 100\n\n    def initialize_population(self):\n        \"\"\"Initialize or re-initialize the population.\"\"\"\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([self.func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        if np.min(self.fitness) < self.f_opt:\n            self.f_opt = np.min(self.fitness)\n            self.x_opt = self.population[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.initialize_population()\n\n        while self.evals < self.budget:\n            self.generation += 1\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n            \n            # Population size adaptation (simplified)\n            if self.generation % 10 == 0:  # Adjust population size every 10 generations\n                if np.std(self.fitness) < 1e-3:  # Convergence detected, increase exploration\n                    self.pop_size = min(self.pop_size * 2, self.max_pop_size)\n                    \n                else:  # Reduce population size if not converging to save budget\n                    self.pop_size = max(int(self.pop_size * 0.9), self.min_pop_size)\n            \n            # Periodic restart\n            if self.evals % self.restart_interval == 0:\n                self.initialize_population()\n\n            if self.evals >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "An exception occurred: index 16 is out of bounds for axis 0 with size 10.", "error": "", "parent_ids": ["3ab9f159-5f59-41ae-b924-f984068ecb6a"], "operator": null, "metadata": {}}
{"id": "57a5e7cd-8192-42d5-81b1-bab89ec67488", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution using a single F and CR value for the entire population, archive only worse solutions, and adaptive update based on population fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_size = pop_size // 2  # Reduced archive size\n        self.success_history_F = []\n        self.success_history_CR = []\n        self.H = 5 # history size\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        \n        mean_fitness = np.mean(self.fitness)\n\n\n        while self.evals < self.budget:\n            \n            if len(self.success_history_F) > self.H:\n                self.success_history_F.pop(0)\n                self.success_history_CR.pop(0)\n            \n            # Mutation and Crossover\n            new_population = np.copy(self.population)\n            new_fitness = np.copy(self.fitness)\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual (only worse ones)\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    elif len(self.archive) > 0:\n                        archive_fitnesses = [func(x) for x in self.archive]\n                        if self.fitness[i] > min(archive_fitnesses):\n                            replace_idx = np.argmin(archive_fitnesses)\n                            self.archive[replace_idx] = self.population[i].copy()\n\n                    new_population[i] = trial\n                    new_fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        \n                    self.success_history_F.append(self.F)\n                    self.success_history_CR.append(self.CR)\n                    \n\n                if self.evals >= self.budget:\n                    break\n            \n            #Adaptive F and CR\n            if len(self.success_history_F) > 0:\n                self.F = np.mean(self.success_history_F)\n                self.CR = np.mean(self.success_history_CR)\n            self.F = np.clip(np.random.normal(self.F, 0.1), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 1.0)\n            \n            self.population = new_population\n            self.fitness = new_fitness\n            \n            if np.mean(self.fitness) < mean_fitness:\n                self.F = np.clip(self.F*1.05, 0.1, 1.0)\n                self.CR = np.clip(self.CR*1.05, 0.1, 1.0)\n            else:\n                self.F = np.clip(self.F*0.95, 0.1, 1.0)\n                self.CR = np.clip(self.CR*0.95, 0.1, 1.0)\n            \n            mean_fitness = np.mean(self.fitness)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e3566cfe-ab6a-403e-bc5d-3ac1ede57f95"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "a14f12e7-37ac-4912-894e-422c07ff5372", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with enhanced parameter adaptation based on historical success and a tournament-based archive selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size_factor=2):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size_factor (int): determines archive size relative to pop size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = int(pop_size * archive_size_factor)  # Archive size related to population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            successful_mutations = 0\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                if len(self.archive) > 0 and np.random.rand() < 0.1:  # Use archive occasionally\n                    c = self.archive[np.random.randint(len(self.archive))]\n                else:\n                    idxs = [idx for idx in range(self.pop_size) if idx != i and idx != a and idx != b]\n                    if len(idxs) == 0:\n                        c = self.population[a]\n                    else:\n                        c_idx = np.random.choice(idxs, 1)[0]\n                        c = self.population[c_idx]\n\n                mutant = self.population[a] + self.F * (self.population[b] - c)\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    successful_mutations += 1\n                    # Tournament-based archive selection\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        # Tournament selection: compare the new candidate with a random archive member\n                        archive_idx = np.random.randint(len(self.archive))\n                        if func(self.population[i]) < func(self.archive[archive_idx]):\n                            self.archive[archive_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F and CR based on success history\n            if self.pop_size > 0:\n                success_rate = successful_mutations / self.pop_size\n            else:\n                success_rate = 0.0\n            self.success_history.append(success_rate)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n            # Enhanced adaptation using historical success\n            if len(self.success_history) > 5:\n                recent_successes = self.success_history[-5:]\n                avg_success = np.mean(recent_successes)\n                self.F = np.clip(self.F + 0.2 * (avg_success - 0.3), 0.1, 0.9)\n                self.CR = np.clip(self.CR + 0.2 * (avg_success - 0.3), 0.1, 0.9)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6fca405-981d-4d44-a9a6-db894fcf4a43"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "8a534e88-1dbb-4f2c-8686-265cc1cbacbf", "fitness": 0.734295283118019, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and archive interaction.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, archive_size=40, memory_size=10):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            archive_size (int): The size of the archive.\n            memory_size (int): The size of the memory for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.memory_F = [F] * memory_size\n        self.memory_CR = [CR] * memory_size\n        self.memory_idx = 0\n        self.sf_prob = 0.1\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation: Select F and CR from memory\n                self.F = self.memory_F[self.memory_idx]\n                self.CR = self.memory_CR[self.memory_idx]\n\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Update memory: Use successful F and CR values\n                    self.memory_F[self.memory_idx] = self.F  # Store the used F\n                    self.memory_CR[self.memory_idx] = self.CR  # Store the used CR\n                    self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n                \n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b = np.random.choice(idxs, 2, replace=False)\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n                             # Update memory: Use successful F and CR values\n                            self.memory_F[self.memory_idx] = self.F  # Store the used F\n                            self.memory_CR[self.memory_idx] = self.CR  # Store the used CR\n                            self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.734 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3ab9f159-5f59-41ae-b924-f984068ecb6a"], "operator": null, "metadata": {"aucs": [0.3661110085787952, 0.7338512366993523, 0.7391342234248924, 0.9176787918825555, 0.8032070850255277, 0.835156855777441, 0.7223064428183736, 0.7153402632558773, 0.8123507370617967, 0.7470901366675136, 0.8964293346778004, 0.9869933749721609, 0.740541408545861, 0.794687311671451, 0.9378463188289032, 0]}}
{"id": "1306d8e0-0a4f-4900-9d5a-5ceafc2c9295", "fitness": 0.7787255882946624, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on successful mutations and reduced archive interaction for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.success_F = []\n        self.success_CR = []\n        self.memory_F = [F] * 5  # Reduced memory size\n        self.memory_CR = [CR] * 5  # Reduced memory size\n        self.memory_idx = 0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation\n                self.F = self.memory_F[self.memory_idx]\n                self.CR = self.memory_CR[self.memory_idx]\n                self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n                \n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                \n                if self.evals >= self.budget:\n                    break\n            \n            # Update memory every generation\n            if self.success_F:\n                self.memory_F[self.memory_idx] = np.mean(self.success_F)\n                self.memory_CR[self.memory_idx] = np.mean(self.success_CR)\n            self.success_F = []\n            self.success_CR = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.779 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3ab9f159-5f59-41ae-b924-f984068ecb6a"], "operator": null, "metadata": {"aucs": [0.4494643195251765, 0.7181805881632426, 0.7733353192826684, 0.8990523409028137, 0.7821541252334072, 0.8430618778390486, 0.7287291880152416, 0.7416235062320444, 0.7871974456002246, 0.7678880281792277, 0.9095693195911586, 0.9951886660064904, 0.7416211853813772, 0.7888670245062991, 0.9105089345421318, 0.8275172576531689, 0.71383991529995, 0.8867449989936232, 0.6741283161157174, 0.635839408830235]}}
{"id": "52964411-b93d-470d-807c-7f79ecfedc23", "fitness": 0.6069413349776313, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a focus on parameter adaptation based on recent success and reduced archive management.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, adaptation_rate=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            adaptation_rate (float): Rate at which F and CR are adapted.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.adaptation_rate = adaptation_rate\n        self.archive = []  # Archive is not used, removing it simplifies the code\n        self.success_history = []\n        self.F_history = []\n        self.CR_history = []\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            successful_mutations = 0\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    successful_mutations += 1\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            #Adapt F and CR based on success rate\n            success_rate = successful_mutations / self.pop_size if self.pop_size > 0 else 0.0\n            self.success_history.append(success_rate)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n            self.F = np.clip(self.F + self.adaptation_rate * (success_rate - 0.5), 0.1, 0.9) # Adjust F\n            self.CR = np.clip(self.CR + self.adaptation_rate * (success_rate - 0.5), 0.1, 0.9) # Adjust CR\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.607 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6fca405-981d-4d44-a9a6-db894fcf4a43"], "operator": null, "metadata": {"aucs": [0.22350370246269635, 0.25477100440252465, 0.5618035399263392, 0.885674883938407, 0.5767483353332405, 0.7251900604066923, 0.7549024293958073, 0.7187425037026851, 0.6777236465955665, 0.7103364659678102, 0.5752561750324693, 0.9999111550642737, 0.2865289548952442, 0.5028985864098939, 0.69704338365336, 0.8439128429540836, 0.4843878193743768, 0.8914877012295571, 0.263094726610394, 0.5049087821972028]}}
{"id": "5050570a-3880-48fc-bc76-a3441e0d1e9f", "fitness": 0.5734169323617656, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on recent success and population diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.success_history = []\n        self.F_history = []\n        self.CR_history = []\n        self.diversity_history = []\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            successful_mutations = 0\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    successful_mutations += 1\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            #Adapt F and CR based on recent success\n            success_rate = successful_mutations / self.pop_size if self.pop_size > 0 else 0.0\n            self.success_history.append(success_rate)\n\n            # Calculate population diversity (variance of each dimension)\n            diversity = np.mean(np.var(self.population, axis=0))\n            self.diversity_history.append(diversity)\n\n            # Adjust F and CR based on recent success and diversity\n            if len(self.success_history) > 5:\n                recent_success = np.mean(self.success_history[-5:])\n                diversity_factor = np.clip(diversity, 0.0, 1.0) # Normalize diversity\n\n                self.F = np.clip(self.F + 0.1 * (recent_success - 0.5) + 0.05 * (0.5 - diversity_factor), 0.1, 0.9)\n                self.CR = np.clip(self.CR + 0.1 * (recent_success - 0.5) + 0.05 * (diversity_factor - 0.5), 0.1, 0.9)\n\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.573 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6fca405-981d-4d44-a9a6-db894fcf4a43"], "operator": null, "metadata": {"aucs": [0.26979625387712647, 0.24338923418751668, 0.545115074721197, 0.6800848257497949, 0.673004137303566, 0.7189052509668519, 0.6579409997546362, 0.5360481209076728, 0.6866308495598203, 0.21874313032957426, 0.8237457163849317, 0.9971096056394954, 0.2879209248307555, 0.5758435222954719, 0.6976636626232988, 0.7774041242019295, 0.5722152360914599, 0.8027794729731379, 0.21182885779788507, 0.4921696470391923]}}
{"id": "04e23c31-40e8-40a2-8f35-a6a839cc88b4", "fitness": 0.5974127967129034, "name": "AdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with simplified parameter adaptation and probabilistic archive usage for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, archive_size_factor=2, archive_prob=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            archive_size_factor (int): determines archive size relative to pop size.\n            archive_prob (float): Probability of using an archived vector in mutation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.archive = []\n        self.archive_size = int(pop_size * archive_size_factor)  # Archive size related to population size\n        self.archive_prob = archive_prob\n        self.success_rate = 0.0\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            successful_mutations = 0\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                \n                if np.random.rand() < self.archive_prob and len(self.archive) > 0:\n                    arc_idx = np.random.randint(len(self.archive))\n                    mutant = self.population[a] + self.F * (self.population[b] - self.archive[arc_idx])\n                else:\n                    mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    successful_mutations += 1\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    else:\n                         # Replace a random element in the archive\n                        replace_idx = np.random.randint(len(self.archive))\n                        self.archive[replace_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            #Adapt F and CR based on success rate\n            self.success_rate = successful_mutations / self.pop_size if self.pop_size > 0 else 0.0\n            self.F = np.clip(self.F + 0.2 * (self.success_rate - 0.5), 0.1, 0.9) # Adjust F\n            self.CR = np.clip(self.CR + 0.2 * (self.success_rate - 0.5), 0.1, 0.9) # Adjust CR\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.597 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6fca405-981d-4d44-a9a6-db894fcf4a43"], "operator": null, "metadata": {"aucs": [0.2071410363792412, 0.35364826181577946, 0.5853615495282738, 0.8705147081399195, 0.6797520747714475, 0.8449815923147489, 0.5758517048908104, 0.4551551689765111, 0.5649935756977842, 0.508994394731846, 0.7600891720157924, 0.9918010454083057, 0.2846593672516783, 0.5323974192564878, 0.7443349880098125, 0.8641101590210657, 0.537407017624929, 0.8079864933109622, 0.2540990531327034, 0.5249771519799675]}}
{"id": "1bf6bd89-7d14-466d-be5b-d5af2c15e64c", "fitness": 0.7260471024077602, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with separate F and CR adaptation based on individual success.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size_factor=2):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size_factor (int): determines archive size relative to pop size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = pop_size * archive_size_factor  # Archive size related to population size\n        self.F = np.full(pop_size, 0.5)  # Individual F values\n        self.CR = np.full(pop_size, 0.9)  # Individual CR values\n        self.success_F = np.zeros(pop_size)\n        self.success_CR = np.zeros(pop_size)\n        self.success_count = np.zeros(pop_size)\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR[i] or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    else:\n                         # Replace a random element in the archive\n                        replace_idx = np.random.randint(len(self.archive))\n                        self.archive[replace_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n                    # Update successful F/CR values\n                    self.success_F[i] = self.F[i]\n                    self.success_CR[i] = self.CR[i]\n                    self.success_count[i] += 1\n\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F and CR values\n            for i in range(self.pop_size):\n                if self.success_count[i] > 0:\n                    #Leaning rate parameters\n                    alpha_F = 0.1\n                    alpha_CR = 0.1\n\n                    self.F[i] = np.clip(self.F[i] + alpha_F * (self.success_F[i] - self.F[i]), 0.1, 0.9)\n                    self.CR[i] = np.clip(self.CR[i] + alpha_CR * (self.success_CR[i] - self.CR[i]), 0.1, 0.9)\n                    self.success_count[i] = 0 #reset counter\n                else:\n                     # If no success, randomly adjust F/CR\n                    self.F[i] = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                    self.CR[i] = np.clip(np.random.normal(0.9, 0.1), 0.1, 0.9)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.726 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6fca405-981d-4d44-a9a6-db894fcf4a43"], "operator": null, "metadata": {"aucs": [0.3981266267388831, 0.7458038449354198, 0.7423609911698885, 0.8980854255561476, 0.7961273094498978, 0.8425919047709282, 0.6933457781561603, 0.7270541925329832, 0.7819930549810477, 0.4142295620988007, 0.8977207696364018, 0.9984877482571163, 0.671146663354035, 0.7986674430491847, 0.9353906646221964, 0.8118970813097778, 0.6713179676740544, 0.8603591160535744, 0.30859929740419334, 0.5276366064045127]}}
{"id": "efeef808-4a9b-4034-8e05-211a39953e72", "fitness": 0.7594544275168169, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with memory-based parameter adaptation and p-best selection for improved exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, p_best=0.11, memory_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.p_best = p_best\n        self.memory_size = memory_size\n        self.memory_cr = [0.9] * memory_size\n        self.memory_f = [0.5] * memory_size\n        self.memory_idx = 0\n        self.archive = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:max(1, int(self.p_best * self.pop_size))]\n\n            for i in range(self.pop_size):\n                # Parameter adaptation from memory\n                Cr = np.random.choice(self.memory_cr)\n                F = np.random.choice(self.memory_f)\n\n                # Mutation using p-best\n                p_best_idx = np.random.choice(top_indices)\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                a, b = self.pop[idxs[0]], self.pop[idxs[1]]\n                mutant = self.pop[i] + F * (self.pop[p_best_idx] - self.pop[i]) + F * (a - b)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial = np.copy(self.pop[i])\n                trial[cross_mask] = mutant[cross_mask]\n\n                # Selection\n                f_trial = func(trial)\n                self.evals += 1\n\n                if f_trial < self.fitness[i]:\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.pop[i].copy() # Replace random archive member\n                        \n                    self.pop[i] = trial\n                    self.fitness[i] = f_trial\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n\n                    # Update memory\n                    self.memory_cr[self.memory_idx] = Cr\n                    self.memory_f[self.memory_idx] = F\n                    self.memory_idx = (self.memory_idx + 1) % self.memory_size\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.759 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cbe35048-4984-487e-a453-1426eb7edaf8"], "operator": null, "metadata": {"aucs": [0.4591474954255569, 0.846934212320868, 0.4404335896414897, 0.9358282688395809, 0.8670111385098762, 0.8942665952119999, 0.7909224986726326, 0.8296068323899295, 0.8722213718861486, 0.7921582351740952, 0.9374019847537647, 0.9910400868045361, 0.4186340068084592, 0.8520545211427957, 0.8266776074821895, 0.8675900082627857, 0.7961018501772813, 0.9143524594792675, 0.33851760181018165, 0.518188185542898]}}
{"id": "e09b718f-8ef1-48dc-a107-9f71f1b6a564", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with parameter randomization and periodic population rejuvenation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.archive_rate = 0.2\n        self.rejuvenation_rate = 0.05\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter randomization\n                F = np.clip(np.random.normal(self.F, 0.1), 0.1, 1.0)\n                CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 1.0)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutant = a + F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, self.population[i])\n                trial = np.clip(trial, self.lb, self.ub)\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n            # Periodic population rejuvenation\n            if np.random.rand() < self.rejuvenation_rate:\n                worst_idx = np.argmax(self.fitness)\n                self.population[worst_idx] = np.random.uniform(self.lb, self.ub)\n                self.fitness[worst_idx] = func(self.population[worst_idx])\n                self.evals += 1\n                if self.fitness[worst_idx] < self.f_opt:\n                    self.f_opt = self.fitness[worst_idx]\n                    self.x_opt = self.population[worst_idx]\n\n            if self.evals >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e3566cfe-ab6a-403e-bc5d-3ac1ede57f95"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "bc2b6983-2425-4274-981d-61f00fcaed4e", "fitness": 0.5285827449550574, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters using a decaying average of past success rates for better adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.success_rate = 0.0\n        self.decay_rate = 0.9  # Decay rate for the moving average\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            successful_mutations = 0\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    successful_mutations += 1\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            # Adapt F and CR based on a decaying average of the success rate\n            current_success_rate = successful_mutations / self.pop_size if self.pop_size > 0 else 0.0\n            self.success_rate = self.decay_rate * self.success_rate + (1 - self.decay_rate) * current_success_rate  # Decaying average\n\n            self.F = np.clip(self.F + 0.1 * (self.success_rate - 0.5), 0.1, 0.9)  # Adjust F\n            self.CR = np.clip(self.CR + 0.1 * (self.success_rate - 0.5), 0.1, 0.9)  # Adjust CR\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.529 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6fca405-981d-4d44-a9a6-db894fcf4a43"], "operator": null, "metadata": {"aucs": [0.2177403528559717, 0.32551236535996464, 0.3895873024838704, 0.8639722813189229, 0.6780648915816534, 0.40594220203181663, 0.34694814106126115, 0.4684248221912344, 0.6274011371654498, 0.6683517711418784, 0.3308253894736177, 0.9876397447080043, 0.3276499669228813, 0.6909957859722653, 0.690570649534221, 0.8502914625349451, 0.4617636606373562, 0.48538428092657215, 0.26774253567576145, 0.48684615552349886]}}
{"id": "931de7e5-1126-4cc9-9c06-0de3ce092ec6", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on successful mutations, reduced archive interaction, and enhanced exploration via a diversity maintenance strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=40, memory_size=10, exploration_prob=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n            memory_size (int): The size of the memory for F and CR adaptation.\n            exploration_prob (float): Probability of exploring new solutions outside the current population range.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.memory_F = [0.5] * memory_size  # Initialize F to 0.5\n        self.memory_CR = [0.9] * memory_size  # Initialize CR to 0.9\n        self.memory_idx = 0\n        self.exploration_prob = exploration_prob\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation: Select F and CR from memory\n                F = self.memory_F[self.memory_idx]\n                CR = self.memory_CR[self.memory_idx]\n\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Exploration: Random replacement of components\n                if np.random.rand() < self.exploration_prob:\n                    num_components = np.random.randint(1, self.dim + 1)\n                    indices = np.random.choice(self.dim, num_components, replace=False)\n                    mutant[indices] = np.random.uniform(self.lb, self.ub, size=num_components)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Update memory: Heuristic for updating F and CR (simplified)\n                    self.memory_F[self.memory_idx] = 0.9 * self.memory_F[self.memory_idx] + 0.1 * F # Exponential smoothing\n                    self.memory_CR[self.memory_idx] = 0.9 * self.memory_CR[self.memory_idx] + 0.1 * CR # Exponential smoothing\n\n                    self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "An exception occurred: Output size (1,) is not compatible with broadcast dimensions of inputs (2,)..", "error": "", "parent_ids": ["8a534e88-1dbb-4f2c-8686-265cc1cbacbf"], "operator": null, "metadata": {}}
{"id": "5c35cd62-0645-4b83-923d-a890abd4d50f", "fitness": 0.3159698135794947, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, p-best crossover, and reduced archive interaction for enhanced exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, archive_size=40, memory_size=10, p_best=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            archive_size (int): The size of the archive.\n            memory_size (int): The size of the memory for F and CR adaptation.\n            p_best (float): Percentage of best individuals to select p-best from.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.memory_F = [F] * memory_size\n        self.memory_CR = [CR] * memory_size\n        self.memory_idx = 0\n        self.sf_prob = 0.05  # Reduced archive interaction\n        self.F = F\n        self.CR = CR\n        self.p_best = p_best\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation: Select F and CR from memory\n                self.F = self.memory_F[self.memory_idx]\n                self.CR = self.memory_CR[self.memory_idx]\n\n                # Mutation - p-best crossover\n                num_elites = max(1, int(self.p_best * self.pop_size))\n                elite_indices = np.argsort(self.fitness)[:num_elites]\n                p_best_idx = np.random.choice(elite_indices)\n\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[p_best_idx] + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Update memory: Use successful F and CR values\n                    self.memory_F[self.memory_idx] = self.F  # Store the used F\n                    self.memory_CR[self.memory_idx] = self.CR  # Store the used CR\n                    self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n                \n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b = np.random.choice(idxs, 2, replace=False)\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n                             # Update memory: Use successful F and CR values\n                            self.memory_F[self.memory_idx] = self.F  # Store the used F\n                            self.memory_CR[self.memory_idx] = self.CR  # Store the used CR\n                            self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.316 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8a534e88-1dbb-4f2c-8686-265cc1cbacbf"], "operator": null, "metadata": {"aucs": [0.6319396271589894, 0]}}
{"id": "3f0cfc93-9cb9-4eff-acb4-fa66285a6129", "fitness": 0.3981323100946607, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, archive interaction and a tournament-based selection to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, archive_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            archive_size (int): The size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.sf_prob = 0.1\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = [idx for idx in range(self.pop_size) if idx != i]\n                    a, b = np.random.choice(idxs, 2, replace=False)\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n                else:\n                    # Tournament selection: Randomly select another individual and compare\n                    opponent_idx = np.random.choice(idxs, 1)[0]\n                    if self.fitness[opponent_idx] < self.fitness[i]:\n                        # Replace current individual with a slightly mutated version of the opponent\n                        mutant = self.population[opponent_idx] + 0.1 * np.random.normal(0, 1, self.dim)\n                        mutant = np.clip(mutant, self.lb, self.ub)\n                        f_mutant = func(mutant)\n                        self.evals += 1\n\n                        if f_mutant < self.fitness[i]:\n                            if len(self.archive) < self.archive_size:\n                                self.archive.append(self.population[i])\n                            else:\n                                self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                            self.population[i] = mutant\n                            self.fitness[i] = f_mutant\n\n                            if f_mutant < self.f_opt:\n                                self.f_opt = f_mutant\n                                self.x_opt = mutant\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.398 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8a534e88-1dbb-4f2c-8686-265cc1cbacbf"], "operator": null, "metadata": {"aucs": [0.3888271973620976, 0.8055697329218845, 0]}}
{"id": "32afdad5-db16-4c27-a130-0c91c8eaf0f3", "fitness": 0.7287047210717622, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with reduced memory, adaptive parameters based on successful mutations, and vectorized operations for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.memory_F = np.full(5, F)\n        self.memory_CR = np.full(5, CR)\n        self.memory_idx = 0\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            F = self.memory_F[self.memory_idx]\n            CR = self.memory_CR[self.memory_idx]\n            self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n\n            # Mutation and Crossover\n            idxs = np.random.randint(0, self.pop_size, size=(self.pop_size, 3))\n            idxs = np.where(idxs == np.arange(self.pop_size)[:, None], (idxs + 1) % self.pop_size, idxs)  # Ensure i not in idxs\n            a, b, c = idxs[:, 0], idxs[:, 1], idxs[:, 2]\n            mutant = self.population[a] + F * (self.population[b] - self.population[c])\n            mutant = np.clip(mutant, self.lb, self.ub)\n\n            j_rand = np.random.randint(0, self.dim, size=self.pop_size)\n            trial = np.copy(self.population)\n            mask = (np.random.rand(self.pop_size, self.dim) < CR) | (np.arange(self.dim) == j_rand[:, None])\n            trial[mask] = mutant[mask]\n\n            # Evaluation\n            fitness_trial = np.array([func(x) for x in trial])\n            self.evals += self.pop_size\n\n            # Selection\n            success = fitness_trial < self.fitness\n            self.success_F.extend([F] * np.sum(success))\n            self.success_CR.extend([CR] * np.sum(success))\n\n            self.population[success] = trial[success]\n            self.fitness[success] = fitness_trial[success]\n\n            # Update best solution\n            best_idx = np.argmin(self.fitness)\n            if self.fitness[best_idx] < self.f_opt:\n                self.f_opt = self.fitness[best_idx]\n                self.x_opt = self.population[best_idx]\n\n            if self.evals >= self.budget:\n                break\n                \n            # Update memory\n            if self.success_F:\n                self.memory_F[self.memory_idx] = np.mean(self.success_F)\n                self.memory_CR[self.memory_idx] = np.mean(self.success_CR)\n            self.success_F = []\n            self.success_CR = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.729 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1306d8e0-0a4f-4900-9d5a-5ceafc2c9295"], "operator": null, "metadata": {"aucs": [0.407114728311991, 0.6996066548067186, 0.7509225154834778, 0.8686053551238657, 0.7687692844106505, 0.8114045335371799, 0.6838819873512911, 0.7078705369764369, 0.7700800857111341, 0.7290553589505736, 0.8979105980322959, 0.9893453093288103, 0.6987998809777384, 0.7373393077453074, 0.9339551346495439, 0.789415496633382, 0.6582646083030478, 0.8599331217572108, 0.2975836757992585, 0.5142362475453319]}}
{"id": "61ae512c-6361-49ff-92fc-16e4818b1455", "fitness": 0.6143434587462667, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with self-adaptive parameters, p-best mutation, and a compact archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, p_best=0.11):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.p_best = p_best\n        self.archive = []\n        self.cr = 0.5\n        self.f = 0.7\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:max(1, int(self.p_best * self.pop_size))]\n\n            for i in range(self.pop_size):\n                # Mutation using p-best\n                p_best_idx = np.random.choice(top_indices)\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                a, b = self.pop[idxs[0]], self.pop[idxs[1]]\n                mutant = self.pop[i] + self.f * (self.pop[p_best_idx] - self.pop[i]) + self.f * (a - b)\n                mutant = np.clip(mutant, lb, ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < self.cr\n                trial = np.copy(self.pop[i])\n                trial[cross_mask] = mutant[cross_mask]\n\n                # Selection\n                f_trial = func(trial)\n                self.evals += 1\n\n                if f_trial < self.fitness[i]:\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.pop[i].copy() # Replace random archive member\n                        \n                    self.pop[i] = trial\n                    self.fitness[i] = f_trial\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                    \n                    # Self-adapt parameters\n                    self.cr = 0.9 * self.cr + 0.1 * np.random.rand()\n                    self.f = 0.9 * self.f + 0.1 * np.random.rand()\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.614 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["efeef808-4a9b-4034-8e05-211a39953e72"], "operator": null, "metadata": {"aucs": [0.221806844569436, 0.39066172181837344, 0.6570512446118132, 0.8281553923763106, 0.7347857707087282, 0.8057368172407438, 0.48935720430104024, 0.6332622086397918, 0.7430588953180323, 0.1989176698669003, 0.8290045194127309, 0.9922491541994568, 0.33463403409543, 0.5898832813629773, 0.9047950763245194, 0.7948799120009739, 0.5392938726277369, 0.8518262361995885, 0.23381350675136747, 0.513695812499386]}}
{"id": "4cf821d5-0305-40c9-a027-8fcf90a62a0e", "fitness": 0.7121723107462131, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified F/CR adaptation based on success history and a global best-guided mutation strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = np.full(pop_size, 0.5)  # Individual F values\n        self.CR = np.full(pop_size, 0.9)  # Individual CR values\n        self.memory_F = np.full(pop_size, 0.5)\n        self.memory_CR = np.full(pop_size, 0.9)\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation: Global best-guided mutation\n                best_idx = np.argmin(self.fitness)\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F[i] * (self.population[best_idx] - self.population[i]) + self.F[i] * (self.population[a] - self.population[b])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR[i] or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    self.memory_F[i] = self.F[i]\n                    self.memory_CR[i] = self.CR[i]\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F and CR values: Simplified adaptation\n            self.F = 0.9 * self.F + 0.1 * np.random.rand(self.pop_size)\n            self.CR = 0.9 * self.CR + 0.1 * np.random.rand(self.pop_size)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.712 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1bf6bd89-7d14-466d-be5b-d5af2c15e64c"], "operator": null, "metadata": {"aucs": [0.29376016977708463, 0.5273130594389865, 0.830819046792534, 0.9402538062656022, 0.848780752776463, 0.8879972293952775, 0.6687237868688385, 0.7858220606366237, 0.8512069698320397, 0.22922481389411553, 0.9212111407018279, 0.9968269808898226, 0.4213452903796413, 0.8114393536316656, 0.9600776526196677, 0.8506849411238098, 0.7533945609545, 0.9144541421736418, 0.22857271170140792, 0.5215377450707118]}}
{"id": "68342c0b-6370-4bdd-ae97-35ab37908f7e", "fitness": 0.669937745428263, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with mean-based F/CR adaptation and archive interaction for enhanced exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size_factor=2):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size_factor (int): determines archive size relative to pop size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = pop_size * archive_size_factor  # Archive size related to population size\n        self.F = np.full(pop_size, 0.5)  # Individual F values\n        self.CR = np.full(pop_size, 0.9)  # Individual CR values\n        self.success_F = []\n        self.success_CR = []\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR[i] or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    else:\n                         # Replace a random element in the archive\n                        replace_idx = np.random.randint(len(self.archive))\n                        self.archive[replace_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n                    self.success_F.append(self.F[i])\n                    self.success_CR.append(self.CR[i])\n\n\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F and CR values\n            if self.success_F:\n                mean_F = np.mean(self.success_F)\n                mean_CR = np.mean(self.success_CR)\n                self.F = np.clip(np.random.normal(mean_F, 0.1, self.pop_size), 0.1, 0.9)\n                self.CR = np.clip(np.random.normal(mean_CR, 0.1, self.pop_size), 0.1, 0.9)\n\n            self.success_F = [] # Reset\n            self.success_CR = []\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.670 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1bf6bd89-7d14-466d-be5b-d5af2c15e64c"], "operator": null, "metadata": {"aucs": [0.23740195017072396, 0.4160792935404083, 0.4685891204019772, 0.9000251394146178, 0.8224856086171274, 0.8552948946408208, 0.7693259641053266, 0.7747451569782063, 0.5878524915483867, 0.5429760735927325, 0.8778961989491668, 0.9994854019172116, 0.35779255829132517, 0.6597044213024562, 0.8245895985486449, 0.8517225270678306, 0.43912541648759973, 0.8680345666759457, 0.6406762411400337, 0.5049522851747199]}}
{"id": "4036bb10-c2d2-41d0-9bc3-52deb4fd2639", "fitness": 0.7637955438600913, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with memory-based parameter adaptation, reduced archive interaction, and improved parameter update scheme focusing on beneficial moves for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, archive_size=20, memory_size=5):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            archive_size (int): The size of the archive.\n            memory_size (int): The size of the memory for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.memory_F = np.full(memory_size, F)\n        self.memory_CR = np.full(memory_size, CR)\n        self.memory_idx = 0\n        self.F = F\n        self.CR = CR\n        self.success_F = []\n        self.success_CR = []\n        self.p = 0.05 # percentage of best vectors\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Sort population based on fitness\n            ranked_population = np.argsort(self.fitness)\n            \n            for i in range(self.pop_size):\n                # Parameter Adaptation: Select F and CR from memory (no selection scheme)\n                self.F = self.memory_F[self.memory_idx]\n                self.CR = self.memory_CR[self.memory_idx]\n\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        if len(self.archive) > 0:\n                            self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                    # Store successful F and CR\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Update memory: Use successful F and CR values\n\n                if self.evals >= self.budget:\n                    break\n            # Update memory every generation\n            if self.success_F:\n                self.memory_F[self.memory_idx] = np.mean(self.success_F)\n                self.memory_CR[self.memory_idx] = np.mean(self.success_CR)\n            self.memory_idx = (self.memory_idx + 1) % self.memory_size\n            self.success_F = []\n            self.success_CR = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.764 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8a534e88-1dbb-4f2c-8686-265cc1cbacbf"], "operator": null, "metadata": {"aucs": [0.3334074998342774, 0.7483810132640898, 0.7384953446883051, 0.9093951158220176, 0.8121790372045332, 0.8341382020169184, 0.7076500176887925, 0.727129279081107, 0.8060550987162942, 0.7735947263725365, 0.9000319072684021, 0.9973939812369154, 0.74633043071142, 0.7993016262761232, 0.9382085703449072, 0.8309734234149438, 0.6994893425218975, 0.8667384407613674, 0.492178010109105, 0.6148398098678743]}}
{"id": "c45a8766-e6c4-4aeb-8edf-a4b0c1dee76a", "fitness": 0.7746171773704811, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with population-wide F and CR adaptation based on successful mutations, utilizing a memory of past successful parameters and a learning rate for faster adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size_factor=2, learning_rate=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size_factor (int): determines archive size relative to pop size.\n            learning_rate (float): Learning rate for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = pop_size * archive_size_factor  # Archive size related to population size\n        self.F = 0.5  # Single F value for all individuals\n        self.CR = 0.9  # Single CR value for all individuals\n        self.memory_F = [self.F]  # Memory for successful F values\n        self.memory_CR = [self.CR]  # Memory for successful CR values\n        self.learning_rate = learning_rate\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())  # Store a copy to avoid modification\n                    else:\n                         # Replace a random element in the archive\n                        replace_idx = np.random.randint(len(self.archive))\n                        self.archive[replace_idx] = self.population[i].copy()\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n                    # Update memory with successful F/CR values\n                    self.memory_F.append(self.F)\n                    self.memory_CR.append(self.CR)\n\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F and CR values - Population-wide adaptation\n            if len(self.memory_F) > 1:\n                self.F = np.clip(self.F + self.learning_rate * (np.mean(self.memory_F[1:]) - self.F), 0.1, 0.9)\n            else:\n                self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9) #randomize if no successful F recorded\n            if len(self.memory_CR) > 1:\n                self.CR = np.clip(self.CR + self.learning_rate * (np.mean(self.memory_CR[1:]) - self.CR), 0.1, 0.9)\n            else:\n                self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 0.9) #randomize if no successful CR recorded\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.775 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1bf6bd89-7d14-466d-be5b-d5af2c15e64c"], "operator": null, "metadata": {"aucs": [0.40563884617599166, 0.7776263557432114, 0.7465532486820519, 0.9075273858730115, 0.817030310414441, 0.837194997483259, 0.7357759230679498, 0.7394647943039896, 0.8230033335376175, 0.6819432701409889, 0.8734848302424961, 0.9963136429142033, 0.7597687640999994, 0.7923429322957638, 0.9423788584130114, 0.8354720283255047, 0.7044462329604905, 0.8748887889735248, 0.6190953289290843, 0.6223936748330307]}}
{"id": "afea093a-66fe-4114-9e8b-06fa45f17732", "fitness": 0.5302162670074064, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and jittering to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = np.full(pop_size, 0.5)  # Individual F values\n        self.CR = np.full(pop_size, 0.9)  # Individual CR values\n        self.success_F = np.zeros(pop_size)\n        self.success_CR = np.zeros(pop_size)\n        self.success_count = np.zeros(pop_size)\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                # Jittering: Add small random perturbation to mutant\n                jitter = np.random.uniform(-0.05, 0.05, size=self.dim)\n                mutant = mutant + jitter\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR[i] or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n                    # Update successful F/CR values\n                    self.success_F[i] = self.F[i]\n                    self.success_CR[i] = self.CR[i]\n                    self.success_count[i] += 1\n\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F and CR values\n            for i in range(self.pop_size):\n                if self.success_count[i] > 0:\n                    #Leaning rate parameters\n                    alpha_F = 0.1\n                    alpha_CR = 0.1\n\n                    self.F[i] = np.clip(self.F[i] + alpha_F * (self.success_F[i] - self.F[i]), 0.1, 0.9)\n                    self.CR[i] = np.clip(self.CR[i] + alpha_CR * (self.success_CR[i] - self.CR[i]), 0.1, 0.9)\n                    self.success_count[i] = 0 #reset counter\n                else:\n                     # If no success, randomly adjust F/CR\n                    self.F[i] = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                    self.CR[i] = np.clip(np.random.normal(0.9, 0.1), 0.1, 0.9)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.530 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1bf6bd89-7d14-466d-be5b-d5af2c15e64c"], "operator": null, "metadata": {"aucs": [0.24042743648683407, 0.47194612522256363, 0.47446666168950813, 0.893949461147578, 0.44669329385003176, 0.5239289852156455, 0.3324063639970336, 0.4165516897489061, 0.4346401650713938, 0.3998712191137128, 0.8317711771997065, 0.9983579819942865, 0.3276188053858732, 0.4578246346994449, 0.9271689459542727, 0.5543360149019325, 0.4076863205116963, 0.6530437725156897, 0.2954024352899465, 0.5162338501520747]}}
{"id": "ccc1cc9b-8e26-492e-9260-2c316cdaf671", "fitness": 0.7334626411067391, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and stochastic universal sampling for parent selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=40, memory_size=10, sf_prob = 0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n            memory_size (int): The size of the memory for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.memory_F = np.ones(memory_size) * 0.5\n        self.memory_CR = np.ones(memory_size) * 0.9\n        self.memory_idx = 0\n        self.sf_prob = sf_prob\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation: Select F and CR from memory\n                F = self.memory_F[self.memory_idx]\n                CR = self.memory_CR[self.memory_idx]\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Update memory: Use successful F and CR values\n                    self.memory_F[self.memory_idx] = F  # Store the used F\n                    self.memory_CR[self.memory_idx] = CR  # Store the used CR\n                    self.memory_idx = (self.memory_idx + 1) % self.memory_size\n                \n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    a, b = idxs[0], idxs[1]\n                    mutant = self.population[a] + F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n                             # Update memory: Use successful F and CR values\n                            self.memory_F[self.memory_idx] = F  # Store the used F\n                            self.memory_CR[self.memory_idx] = CR  # Store the used CR\n                            self.memory_idx = (self.memory_idx + 1) % self.memory_size\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.733 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8a534e88-1dbb-4f2c-8686-265cc1cbacbf"], "operator": null, "metadata": {"aucs": [0.38626609717684224, 0.7395116486522794, 0.7190002672173115, 0.9018300075610408, 0.7974790745883689, 0.8256304002517606, 0.688115504867406, 0.7399072966245714, 0.7956478692577313, 0.7913399098358523, 0.8909523854273473, 0.9987588016052709, 0.6895296244698573, 0.7726788103328355, 0.9303290413936148, 0.8348822256355234, 0.7004685750236904, 0]}}
{"id": "b592aeed-1847-49b4-a5f7-213f27115442", "fitness": 0.7450976640562951, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and stochastic ranking for constraint handling, enhancing exploration around promising regions.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.memory_F = [F] * 3  # Further reduced memory size\n        self.memory_CR = [CR] * 3  # Further reduced memory size\n        self.memory_idx = 0\n        self.archive_size = int(pop_size / 2)\n        self.archive = []\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation\n                F = self.memory_F[self.memory_idx]\n                CR = self.memory_CR[self.memory_idx]\n                self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n                \n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update memory with successful parameters - simplified\n                    self.memory_F[self.memory_idx - 1] = F # Assign the F value\n                    self.memory_CR[self.memory_idx - 1] = CR # Assign the CR value\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                else:\n                     if len(self.archive) < self.archive_size:\n                         self.archive.append(self.population[i])\n                     else:\n                         self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                \n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.745 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1306d8e0-0a4f-4900-9d5a-5ceafc2c9295"], "operator": null, "metadata": {"aucs": [0.3963830254126527, 0.7850445202553548, 0.7656416688980677, 0.8981201782838287, 0.7973257078884886, 0.8310749618458637, 0.7157348184472473, 0.7428147686181464, 0.7975265440579935, 0.2709026131532698, 0.8902226468889697, 0.9972777996161991, 0.7009067844433838, 0.7779634793332464, 0.93726437615323, 0.8282118175805666, 0.7021281091448632, 0.8843745829585103, 0.6527828849354955, 0.5302519932105243]}}
{"id": "ee6acdc0-6a24-47fc-ae34-484ce4dc2925", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, population reduction and selective pressure based on fitness rank for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, reduction_factor=0.95):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The initial population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n            reduction_factor (float): Factor to reduce population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.reduction_factor = reduction_factor\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Sort population based on fitness\n            ranked_population = np.argsort(self.fitness)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            # Population reduction\n            if self.evals < self.budget:\n                new_pop_size = int(self.pop_size * self.reduction_factor)\n                if new_pop_size > 1:\n                    best_indices = np.argsort(self.fitness)[:new_pop_size]\n                    self.population = self.population[best_indices]\n                    self.fitness = self.fitness[best_indices]\n                    self.pop_size = new_pop_size\n                else:\n                    # Keep the best individual and re-initialize the rest of population\n                    best_index = np.argmin(self.fitness)\n                    best_x = self.population[best_index].copy()  # Keep a copy of the best solution\n                    self.population = np.random.uniform(self.lb, self.ub, size=(40, self.dim))\n                    self.population[0] = best_x\n                    self.fitness = np.array([func(x) for x in self.population])\n                    self.pop_size = 40\n                    self.evals += 39  # Account for the function evaluations of the new individuals\n                    if self.evals >= self.budget:\n                        break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "An exception occurred: Cannot take a larger sample than population when 'replace=False'.", "error": "", "parent_ids": ["4036bb10-c2d2-41d0-9bc3-52deb4fd2639"], "operator": null, "metadata": {}}
{"id": "e76c82e7-de4d-42da-be6d-88e72806c961", "fitness": 0.6642729175456505, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with self-adaptive F and CR parameters influenced by past successful values, without memory or archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, sf_prob=0.1, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.sf_prob = sf_prob\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                        self.CR = np.clip(np.random.normal(0.9, 0.2), 0.0, 1.0)\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.664 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ccc1cc9b-8e26-492e-9260-2c316cdaf671"], "operator": null, "metadata": {"aucs": [0.2705736711656166, 0.5025521617792554, 0.6044065159773244, 0.8717402396933076, 0.6614606837200154, 0.7480914549037634, 0.713006400485571, 0.6081793315315398, 0.7897750682802511, 0.6421911345766531, 0.7946659378600169, 0.9938545734105533, 0.5701759398601745, 0.6170274584931206, 0.9192183223539954, 0.774785122104597, 0.6091192627424089, 0.8498700075825478, 0.22034475428894573, 0.5244203101033547]}}
{"id": "a6aec335-ec5d-40ed-a4f6-123ed02e5aeb", "fitness": 0.732401771068121, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified memory-based parameter adaptation using only the best solution and reduced stochasticity for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, memory_size=5):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            memory_size (int): The size of the memory for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.memory_size = memory_size\n        self.memory_F = np.full(memory_size, 0.5)\n        self.memory_CR = np.full(memory_size, 0.9)\n        self.memory_idx = 0\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            \n            for i in range(self.pop_size):\n                # Parameter Adaptation: Select F and CR from memory (no selection scheme)\n                self.F = self.memory_F[self.memory_idx]\n                self.CR = self.memory_CR[self.memory_idx]\n\n                # Mutation: Use only the best individual\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (best - self.population[i]) + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Store successful F and CR\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            # Update memory every generation\n            if self.success_F:\n                self.memory_F[self.memory_idx] = np.mean(self.success_F)\n                self.memory_CR[self.memory_idx] = np.mean(self.success_CR)\n            self.memory_idx = (self.memory_idx + 1) % self.memory_size\n            self.success_F = []\n            self.success_CR = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.732 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4036bb10-c2d2-41d0-9bc3-52deb4fd2639"], "operator": null, "metadata": {"aucs": [0.2586327859750476, 0.893764513750519, 0.8285285647250166, 0.9453571324541261, 0.9072594290282942, 0.9163894957445691, 0.3160364537833025, 0.8646592742475078, 0.8984915592572762, 0.5033217461960683, 0.4455175535042242, 0.9924558996154508, 0.838214459420662, 0.8762237430471953, 0.6676863534302333, 0.9114664616053194, 0.5111827466782886, 0.9378806791148251, 0.6433177623629489, 0.49164880742154626]}}
{"id": "784dcb60-be66-4611-947c-51572a564d7d", "fitness": 0.4696424225398652, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with population-wide F and CR adaptation and selective pressure based on fitness rank.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, memory_size=10):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            memory_size (int): The size of the memory for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.memory_size = memory_size\n        self.memory_F = np.ones(memory_size) * 0.5\n        self.memory_CR = np.ones(memory_size) * 0.9\n        self.memory_idx = 0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Parameter Adaptation: Select F and CR from memory\n            F = self.memory_F[self.memory_idx]\n            CR = self.memory_CR[self.memory_idx]\n\n            # Generate population-wide F and CR with small variations\n            F_pop = np.random.normal(F, 0.1, self.pop_size)\n            F_pop = np.clip(F_pop, 0.1, 1.0)\n            CR_pop = np.random.normal(CR, 0.1, self.pop_size)\n            CR_pop = np.clip(CR_pop, 0.1, 1.0)\n\n            new_population = np.copy(self.population)\n            new_fitness = np.copy(self.fitness)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + F_pop[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR_pop[i] or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection: Replace only if better\n                if f < self.fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n            # Rank-based Population Update: Favor better solutions\n            ranked_indices = np.argsort(new_fitness)\n            selection_cutoff = int(self.pop_size * 0.7)  # Select top 70%\n\n            combined_population = np.concatenate([self.population, new_population])\n            combined_fitness = np.concatenate([self.fitness, new_fitness])\n            combined_ranked_indices = np.argsort(combined_fitness)\n\n            self.population = combined_population[combined_ranked_indices[:self.pop_size]]\n            self.fitness = combined_fitness[combined_ranked_indices[:self.pop_size]]\n            \n            # Update memory: Use last CR and F\n            self.memory_F[self.memory_idx] = F  # Store the used F\n            self.memory_CR[self.memory_idx] = CR  # Store the used CR\n            self.memory_idx = (self.memory_idx + 1) % self.memory_size\n\n            if self.evals >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.470 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ccc1cc9b-8e26-492e-9260-2c316cdaf671"], "operator": null, "metadata": {"aucs": [0.19625111531969264, 0.211587868196355, 0.4396553107529597, 0.9348703221419408, 0.8822284999561293, 0.6973890880351465, 0.2923718927449013, 0.3919872774597484, 0.3690696896490725, 0.1883926172211008, 0.4588808582439835, 0.9938135689364562, 0.3005513890786995, 0.36445970351055523, 0.6903278272566489, 0.3548663358501719, 0.5280869804742445, 0.4692143855064168, 0.13376863411514772, 0.4950750863479336]}}
{"id": "4d61b385-c720-416e-9a7e-07aee0a1411c", "fitness": 0.7119667838698329, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with reduced memory, focusing on current-generation best for parameter adaptation and stochastic ranking for selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Parameter Adaptation based on current best\n                F = self.F + 0.1 * np.random.randn()\n                F = np.clip(F, 0.1, 1.0)\n                CR = self.CR + 0.1 * np.random.randn()\n                CR = np.clip(CR, 0.1, 1.0)\n\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + F * (best - self.population[a]) + F * (self.population[b] - self.population[i])\n\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection (Stochastic Ranking)\n                if (f < self.fitness[i]) or (np.random.rand() < 0.1):  #Stochastic Ranking\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.712 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b592aeed-1847-49b4-a5f7-213f27115442"], "operator": null, "metadata": {"aucs": [0.4013202111540325, 0.6116458972767349, 0.8911318677485907, 0.9449865215503607, 0.8888058936647365, 0.9131812431556252, 0.38617995475347744, 0.8366336383462913, 0.8894200462335248, 0.2002163455898407, 0.9387102153511033, 0.9985619740635007, 0.48418955875095393, 0.8712110585754498, 0.5872883434458047, 0.909245282357213, 0.8311398906620998, 0.9312405464615118, 0.21193774091185147, 0.5122894473439572]}}
{"id": "37b89a25-d808-4df8-b684-c213ef4a18ea", "fitness": 0.7338009550006718, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with memory-based parameter adaptation and archive interaction using a single F and CR value for all population members in each generation, enhancing exploration and exploitation balance with decreased complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=40, memory_size=10, sf_prob = 0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n            memory_size (int): The size of the memory for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.memory_F = np.ones(memory_size) * 0.5\n        self.memory_CR = np.ones(memory_size) * 0.9\n        self.memory_idx = 0\n        self.sf_prob = sf_prob\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Parameter Adaptation: Select F and CR from memory\n            F = self.memory_F[self.memory_idx]\n            CR = self.memory_CR[self.memory_idx]\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                \n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    a, b = idxs[0], idxs[1]\n                    mutant = self.population[a] + F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            # Update memory after each generation based on the best result\n            if self.f_opt < np.min(self.fitness):\n                self.memory_F[self.memory_idx] = F  # Store the used F\n                self.memory_CR[self.memory_idx] = CR  # Store the used CR\n            self.memory_idx = (self.memory_idx + 1) % self.memory_size\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.734 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ccc1cc9b-8e26-492e-9260-2c316cdaf671"], "operator": null, "metadata": {"aucs": [0.434541145573907, 0.725699675624319, 0.7497097121884917, 0.8730070749723287, 0.7621300189832149, 0.8279523485939962, 0.6859460485715984, 0.7352472156003825, 0.8009529384136816, 0.7662254337161556, 0.8904906078476945, 1.0, 0.7311222765353497, 0.7679192069454273, 0.9135408263040758, 0.810131705140796, 0]}}
{"id": "49270376-8ab1-45e7-a925-6f36386bb395", "fitness": 0.6446404238852603, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with reduced memory and population size, immediate parameter update, and no archive for faster adaptation and reduced computational cost.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): The initial mutation factor.\n            CR (float): The initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.memory_F = [F] * 2  # Reduced memory size\n        self.memory_CR = [CR] * 2  # Reduced memory size\n        self.memory_idx = 0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter Adaptation\n                F = self.memory_F[self.memory_idx]\n                CR = self.memory_CR[self.memory_idx]\n                \n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update memory with successful parameters - immediate\n                    self.memory_F[self.memory_idx] = F # Assign the F value\n                    self.memory_CR[self.memory_idx] = CR # Assign the CR value\n                    self.memory_idx = (self.memory_idx + 1) % len(self.memory_F)\n\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                \n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.645 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b592aeed-1847-49b4-a5f7-213f27115442"], "operator": null, "metadata": {"aucs": [0.2674529403278344, 0.7200191836103913, 0.8658850183633021, 0.9388582647038126, 0.8977332593634697, 0.6427835916788849, 0.3758857105772423, 0.8633387208748982, 0.8607125001808399, 0.2676730004740754, 0.942951362005242, 0.9942082599935123, 0.29213454511886416, 0.8419564286881462, 0.7548090868839056, 0.5940994035624135, 0.3411805645946423, 0.41842288186744536, 0.5033889417671391, 0.5093148130691475]}}
{"id": "7a273c00-7ae9-49d9-9a62-2e72d5ad329f", "fitness": 0.6315440221947153, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using a single F and CR value with enhanced archive interaction and stochastic universal selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=40, memory_size=10, sf_prob=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.sf_prob = sf_prob\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    a, b = idxs[0], idxs[1]\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.632 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["37b89a25-d808-4df8-b684-c213ef4a18ea"], "operator": null, "metadata": {"aucs": [0.38740808688158335, 0.7415247426523074, 0.784463379947518, 0.8886009719322655, 0.8018613046012079, 0.816949669348125, 0]}}
{"id": "83b67f5e-3a03-40e9-9b35-1ce212d2f176", "fitness": 0.6385570147732396, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and archive interaction, focusing on exploitation around the best solution and enhanced local search.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=20, memory_size=5, sf_prob = 0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n            memory_size (int): The size of the memory for F and CR adaptation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.memory_size = memory_size\n        self.memory_F = np.ones(memory_size) * 0.5\n        self.memory_CR = np.ones(memory_size) * 0.9\n        self.memory_idx = 0\n        self.sf_prob = sf_prob\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        \n        best_idx = np.argmin(self.fitness)\n        x_best = self.population[best_idx]\n\n\n        while self.evals < self.budget:\n            # Parameter Adaptation: Select F and CR from memory\n            F = self.memory_F[self.memory_idx]\n            CR = self.memory_CR[self.memory_idx]\n\n            for i in range(self.pop_size):\n                # Mutation: Focus on exploitation around the best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                a, b = idxs[0], idxs[1]\n                mutant = self.population[i] + F * (x_best - self.population[i]) + F*(self.population[a]-self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        if len(self.archive) > 0:\n                            self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    \n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        x_best = trial # Update x_best directly\n\n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive - simplified\n                    mutant = self.population[i] + F * (arch_member - self.population[i])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            if len(self.archive) > 0:\n                                self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n                            x_best = trial #Update x_best directly\n\n                if self.evals >= self.budget:\n                    break\n                    \n            # Find best individual of current generation:\n            best_idx = np.argmin(self.fitness)\n            x_best = self.population[best_idx]\n            \n            # Update memory after each generation based on the best result\n            if self.f_opt < np.min(self.fitness):\n                self.memory_F[self.memory_idx] = F  # Store the used F\n                self.memory_CR[self.memory_idx] = CR  # Store the used CR\n            self.memory_idx = (self.memory_idx + 1) % self.memory_size\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.639 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["37b89a25-d808-4df8-b684-c213ef4a18ea"], "operator": null, "metadata": {"aucs": [0.16550534363265068, 0.23245968439911224, 0.837461624163421, 0.9502290485542606, 0.9081630751249835, 0.9258489297591924, 0.3602661246507005, 0.8809091394493394, 0.9121204515984203, 0.851163741173553, 0]}}
{"id": "0390d29a-198a-4735-a1da-0731880dfcbe", "fitness": 0.7962408550248591, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution using a single F and CR value for all population members in each generation, enhancing exploration and exploitation balance with decreased complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n            \n            # Parameter Adaptation: Generate F and CR for this generation\n            F = np.clip(np.random.normal(0.5, 0.3), 0.1, 0.9)\n            CR = np.clip(np.random.normal(0.9, 0.2), 0.1, 0.9)\n            \n\n            for i in range(self.pop_size):\n                # Mutation: Use the best individual and two random individuals\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + F * (best - self.population[i]) + F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.796 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a6aec335-ec5d-40ed-a4f6-123ed02e5aeb"], "operator": null, "metadata": {"aucs": [0.4590092683204102, 0.7704620942553451, 0.8239784752676923, 0.9293855590692807, 0.8500046056062007, 0.8835565742815383, 0.733649326085309, 0.787536987444626, 0.8368969057856805, 0.7845968963681283, 0.907927178353888, 0.9963537045565596, 0.7641461014888768, 0.7971048359935609, 0.9347207331298613, 0.876081680935216, 0.7701855956843366, 0.9117690592880193, 0.5865754830243584, 0.5208760355582933]}}
{"id": "1630c9b5-364b-4ad7-9a9a-0d5033176b77", "fitness": 0.6024233718832206, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters (F and CR) based on successful mutations and optional archive interaction for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=10, sf_prob = 0.1, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.sf_prob = sf_prob\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        if len(self.archive) > 0:\n                            self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                    self.CR = np.random.rand()\n                \n                # Learn from archive with probability sf_prob\n                elif len(self.archive) > 0 and np.random.rand() < self.sf_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    a, b = idxs[0], idxs[1]\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            if len(self.archive) > 0:\n                                self.archive[np.random.randint(len(self.archive))] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n                        self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                        self.CR = np.random.rand()\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.602 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["37b89a25-d808-4df8-b684-c213ef4a18ea"], "operator": null, "metadata": {"aucs": [0.23957293707310212, 0.34723808749257723, 0.6107414030409084, 0.8207697364726911, 0.6836352770923364, 0.7681246570851177, 0.6165259222000006, 0.5878144798737375, 0.6855044541252333, 0.6509439634074563, 0.7947543273145683, 0.9918288629627103, 0.250821500360904, 0.6290274376518535, 0.8831902047283225, 0.7832493275419669, 0.49987811547448335, 0]}}
{"id": "ea8395d4-42ba-4732-a7cd-03e6e033df25", "fitness": 0.7105074564248893, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on successful updates and population diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, F_adapt=True, CR_adapt=True):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.F_adapt = F_adapt\n        self.CR_adapt = CR_adapt\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Adapt F and CR\n                    if self.F_adapt:\n                        self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                    if self.CR_adapt:\n                        self.CR = np.clip(np.random.normal(0.9, 0.2), 0.0, 1.0)\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.711 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e76c82e7-de4d-42da-be6d-88e72806c961"], "operator": null, "metadata": {"aucs": [0.33016180092939207, 0.6000303702432024, 0.678085054243166, 0.8963851189093597, 0.76745960630045, 0.7823500371824935, 0.6456729549608988, 0.6709889545573455, 0.7889177588343682, 0.7201016917439491, 0.8823453086415975, 0.9950320483428258, 0.472161895706253, 0.7518403630903676, 0.9274029275660309, 0.7944225705608692, 0.5870382305039918, 0.8399569000583649, 0.5571724410327533, 0.5226230950901058]}}
{"id": "9ea9a5d0-1930-470f-85c4-f736aef4edf0", "fitness": 0.7470654596626971, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on successful mutations, using a single, dynamically adjusted F and CR.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Adaptive F and CR\n                    self.F = np.clip(0.9 * self.F + 0.1 * np.random.normal(0.5, 0.3), 0.1, 1.0)\n                    self.CR = np.clip(0.9 * self.CR + 0.1 * np.random.normal(0.9, 0.2), 0.0, 1.0)\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.747 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e76c82e7-de4d-42da-be6d-88e72806c961"], "operator": null, "metadata": {"aucs": [0.35351776242777155, 0.7513626276650209, 0.7686621985293132, 0.8954335444392457, 0.7967104041594287, 0.8357086631535201, 0.7319563599696273, 0.6854079414042393, 0.7623577708476431, 0.7781421011161375, 0.8750723333710241, 0.998496276017432, 0.7357659827525069, 0.786804003076727, 0.9225230391751568, 0.8068300676075678, 0.6904867114485891, 0.8774911435438264, 0.36064127601985907, 0.5279389865293036]}}
{"id": "4f1f5c46-d4f6-430b-89dc-b818c3acdbfc", "fitness": 0.7342102959188427, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using only the best solution and stochastic acceptance based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (best - self.population[a]) + self.F * (self.population[b] - self.population[i])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection (Stochastic Acceptance)\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.734 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4d61b385-c720-416e-9a7e-07aee0a1411c"], "operator": null, "metadata": {"aucs": [0.5734903039720745, 0.3459043952370745, 0.8738938212927087, 0.9570120081651657, 0.9038718652952009, 0.8942999342777591, 0.8359187308059042, 0.8708850430766943, 0.9060694336102242, 0.23310493421407363, 0.9484587916319915, 0.9998290443197393, 0.40608579855135174, 0.7402431737201823, 0.969820581209183, 0.9102471101583705, 0.4546234652652663, 0.9382989726515071, 0.2801493662439565, 0.6419991446784269]}}
{"id": "972f022e-c95a-419c-8c61-69a82c937c2f", "fitness": 0.7238892103018473, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on current population performance and archive interaction using a reduced archive size, enhancing exploration and exploitation balance with decreased complexity and faster parameter adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=10):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.F = 0.5  # Single F value\n        self.CR = 0.9 # Single CR value\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        if len(self.archive) > 0:\n                            self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                elif len(self.archive) > 0 and np.random.rand() < 0.1: #archive interaction probability of 0.1\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    a, b = idxs[0], idxs[1]\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            if len(self.archive) > 0:\n                                self.archive[np.random.randint(len(self.archive))] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            #Adaptive F and CR: adjust them based on the performance of population\n            delta_fitness = np.abs(self.fitness - np.mean(self.fitness))\n            if np.sum(delta_fitness) > 0:\n                normalized_delta_fitness = delta_fitness / np.sum(delta_fitness)\n                self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.724 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["37b89a25-d808-4df8-b684-c213ef4a18ea"], "operator": null, "metadata": {"aucs": [0.4240290688019771, 0.76311765630718, 0.5697527073437139, 0.8941287716892045, 0.8078280304040267, 0.825685403836432, 0.7398197277701647, 0.7366922299819461, 0.8011508676931905, 0.7676492369444037, 0.8802705069957707, 0.9952017820888187, 0.3535526547288619, 0.7972565177458246, 0.9337597675820801, 0.850079474321341, 0.741193630839487, 0.8727269606606765, 0]}}
{"id": "36a9d7a9-8589-42ea-8c3b-41e352bfb8ff", "fitness": 0.290938894963711, "name": "AdaptiveDE", "description": "Simplified Adaptive DE using a single mutation strategy and greedy selection for faster convergence, with simplified parameter adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Parameter Adaptation based on current best\n                F = self.F + 0.05 * np.random.randn()  # Smaller adaptation\n                F = np.clip(F, 0.1, 0.9)  # Narrowed range\n                CR = self.CR + 0.05 * np.random.randn()  # Smaller adaptation\n                CR = np.clip(CR, 0.3, 0.9)  # Narrowed range\n\n                # Mutation: Simplified mutation using only current-to-best/1\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a = np.random.choice(idxs)\n                mutant = self.population[i] + F * (best - self.population[i]) + F * (self.population[a] - self.population[i]) # current-to-best/1\n\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection (Greedy)\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.291 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4d61b385-c720-416e-9a7e-07aee0a1411c"], "operator": null, "metadata": {"aucs": [0.1256728589200593, 0.21345273041682766, 0.2728779018973704, 0.18796394733342692, 0.23327236830828624, 0.3187075445859425, 0.22802762222673023, 0.28258552569356465, 0.3181132983504332, 0.19524843128506064, 0.24955168325657884, 0.996352296244429, 0.2569713861024553, 0.2072471001302848, 0.23548631519425178, 0.26485066964932213, 0.2250208260541796, 0.4096646909651054, 0.16188360139797497, 0.43582710126193736]}}
{"id": "b139f2cf-b22d-4d58-bcc9-5d72cee080b1", "fitness": 0.6136898335523501, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on the current best and a more robust stochastic ranking selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Simplified Parameter Adaptation based on current best\n                F = np.clip(np.random.normal(self.F, 0.1), 0.1, 1.0)  # Simplified F adaptation\n                CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 1.0)  # Simplified CR adaptation\n\n\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + F * (best - self.population[a]) + F * (self.population[b] - self.population[i])\n\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < CR\n                trial[crossover_mask] = mutant[crossover_mask]\n                # Ensure at least one element is mutated\n                if not np.any(crossover_mask):\n                    trial[np.random.randint(self.dim)] = mutant[np.random.randint(self.dim)]\n\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection (Stochastic Ranking - more robust)\n                p = 0.2 # Increased selection pressure\n                if (f < self.fitness[i]) or (np.random.rand() < p):\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.614 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4d61b385-c720-416e-9a7e-07aee0a1411c"], "operator": null, "metadata": {"aucs": [0.430583961993919, 0.2313564847105044, 0.7140157284052586, 0.9445324600660114, 0.8727531061235418, 0.8973467799048003, 0.3637728848850508, 0.8518272827590544, 0.8767528151179816, 0.2130386449360585, 0.9361358945046504, 0.9988061409423584, 0.30041635632595676, 0.3683810979029205, 0.949250686970303, 0.32617943794493254, 0.32317779125982593, 0.9322946467498505, 0.236135661374831, 0.5070388081691908]}}
{"id": "8f3c261b-0f48-411b-a0d8-13caead44ced", "fitness": 0.5958169972071985, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified self-adaptation of F and CR, focusing on successful parameter pairs.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, F_stepsize=0.1, CR_stepsize=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.F_stepsize = F_stepsize\n        self.CR_stepsize = CR_stepsize\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        # Adapt F and CR based on success\n                        self.F = np.clip(self.F + self.F_stepsize * np.random.normal(0, 1), 0.1, 1.0)\n                        self.CR = np.clip(self.CR + self.CR_stepsize * np.random.normal(0, 1), 0.0, 1.0)\n                    else:\n                        # If not successful, slightly perturb F and CR\n                        self.F = np.clip(self.F + 0.1 * self.F_stepsize * np.random.normal(0, 1), 0.1, 1.0)\n                        self.CR = np.clip(self.CR + 0.1 * self.CR_stepsize * np.random.normal(0, 1), 0.0, 1.0)\n\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.596 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e76c82e7-de4d-42da-be6d-88e72806c961"], "operator": null, "metadata": {"aucs": [0.24442230831005696, 0.363397468692343, 0.5709576415767538, 0.7740921396717684, 0.6999447755925834, 0.7519834394938611, 0.5624273464725942, 0.3837007324965299, 0.7352869907594541, 0.6764521008313089, 0.7255859958118291, 0.9996543562222846, 0.32822898675896794, 0.39333317821596725, 0.8103574857780805, 0.6979449949114871, 0.6108192773037697, 0.8613462333621463, 0.20162321925215498, 0.524781272630026]}}
{"id": "c8d7df19-a929-4ff4-b9ab-d09c6ef8b474", "fitness": 0.530492615682816, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced stochasticity, leveraging a mirrored population for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.mirrored_population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim)) #Mirrored population\n        self.fitness = np.array([func(x) for x in self.population])\n        self.mirrored_fitness = np.array([func(x) for x in self.mirrored_population])\n        self.evals = 2 * self.pop_size\n\n        self.f_opt = np.min(np.concatenate((self.fitness,self.mirrored_fitness)))\n        self.x_opt = self.population[np.argmin(self.fitness)] if np.argmin(self.fitness) < len(self.fitness) else self.mirrored_population[np.argmin(self.mirrored_fitness)]\n\n\n        while self.evals < self.budget:\n            combined_population = np.concatenate((self.population, self.mirrored_population))\n            combined_fitness = np.concatenate((self.fitness, self.mirrored_fitness))\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(2 * self.pop_size, 3, replace=False)\n                a, b, c = combined_population[idxs[0]], combined_population[idxs[1]], combined_population[idxs[2]]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                        self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.0, 1.0)\n\n                #Mirrored Population update\n                mirrored_mutant = a + self.F * (b-c)\n                mirrored_mutant = np.clip(mirrored_mutant, self.lb, self.ub)\n\n                mirrored_trial = np.copy(self.mirrored_population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        mirrored_trial[j] = mirrored_mutant[j]\n                \n                mirrored_f = func(mirrored_trial)\n                self.evals += 1\n\n                if mirrored_f < self.mirrored_fitness[i]:\n                    self.mirrored_population[i] = mirrored_trial\n                    self.mirrored_fitness[i] = mirrored_f\n                    if mirrored_f < self.f_opt:\n                        self.f_opt = mirrored_f\n                        self.x_opt = mirrored_trial\n                        self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.0, 1.0)\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.530 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e76c82e7-de4d-42da-be6d-88e72806c961"], "operator": null, "metadata": {"aucs": [0.19943462840639914, 0.4256756076548026, 0.5010765806612355, 0.7266107091457468, 0.4976361675650993, 0.604509556053437, 0.3825787046811462, 0.4281741807373697, 0.5228772227781393, 0.4892090380134064, 0.7081954024446053, 0.9909832304573107, 0.42207823876790684, 0.5064039221517891, 0.8370550062801756, 0.5602786498377544, 0.39019920502893457, 0.6640395142008322, 0.25228225502174684, 0.5005544937684827]}}
{"id": "7308f224-2e06-44ee-a845-41df82358134", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on successful mutations and a reduced population size for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x)] for x in self.population)\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.population[idxs[0]], self.population[idxs[1]], self.population[idxs[2]]\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Adaptive F and CR\n                    self.F = np.clip(0.9 * self.F + 0.1 * np.random.normal(0.5, 0.3), 0.1, 1.0)\n                    self.CR = np.clip(0.9 * self.CR + 0.1 * np.random.normal(0.9, 0.2), 0.0, 1.0)\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "An exception occurred: too many indices for array: array is 0-dimensional, but 1 were indexed.", "error": "", "parent_ids": ["9ea9a5d0-1930-470f-85c4-f736aef4edf0"], "operator": null, "metadata": {}}
{"id": "64a3a595-e904-4ce9-97ee-c889bd0edb7f", "fitness": 0.5208971754574776, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution using a single F value and stochastic acceptance based on fitness improvement, with a reduced number of random vector selections to enhance speed.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Mutation\n                idx = np.random.randint(self.pop_size)\n                mutant = self.population[i] + self.F * (best - self.population[idx])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection (Stochastic Acceptance)\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.521 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4f1f5c46-d4f6-430b-89dc-b818c3acdbfc"], "operator": null, "metadata": {"aucs": [0.18964106718987817, 0.4654569638408719, 0.4824373862573177, 0.7792864621956131, 0.40184758274072896, 0.5803538855409547, 0.3139983823631912, 0.43371759732827087, 0.4505284400155911, 0.3084746099854242, 0.7445583494541792, 0.9967044658571209, 0.5180211519347919, 0.452791163394224, 0.9158328475878819, 0.5774571386579779, 0.4092414051988774, 0.6987374783527704, 0.1924692382944757, 0.5063878929594099]}}
{"id": "52bd35b2-2b2e-42d9-b545-a8502a3544f5", "fitness": 0.4427596588970781, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution using a reduced parameter set (only F), greedier selection and simplified mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (best - self.population[a]) \n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Evaluation\n                f = func(mutant)\n                self.evals += 1\n\n                # Selection (Greedy)\n                if f < self.fitness[i]:\n                    self.population[i] = mutant\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = mutant\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.443 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4f1f5c46-d4f6-430b-89dc-b818c3acdbfc"], "operator": null, "metadata": {"aucs": [0.17343414634874443, 0.35116196919750886, 0.3980508050546647, 0.704040220519339, 0.32798171762789696, 0.4627198973287474, 0.2951970704112289, 0.3472812268306492, 0.336365555596413, 0.20697000049156322, 0.6605663275112679, 0.9964721401692489, 0.5006495105788014, 0.27760897784907823, 0.7399791732712165, 0.487333772982366, 0.34280814364305856, 0.584097803952234, 0.17337357345874937, 0.48910114511878533]}}
{"id": "7cceb53a-2348-4d70-a86d-4b21c3583391", "fitness": 0.4184945595086379, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F and CR based on population diversity, reducing complexity and enhancing adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            diversity = np.std(self.population)\n            self.F = np.clip(0.5 + 0.3 * diversity, 0.1, 1.0)\n            self.CR = np.clip(0.7 + 0.2 * (1 - diversity), 0.0, 1.0)\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n                f = func(trial)\n                self.evals += 1\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                if self.evals >= self.budget:\n                    break\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.418 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9ea9a5d0-1930-470f-85c4-f736aef4edf0"], "operator": null, "metadata": {"aucs": [0.15656085106948192, 0.21961607538590855, 0.43945848045608304, 0.43603508195825713, 0.3435530981767514, 0.5473384301439606, 0.3234122269184775, 0.40352706638749714, 0.4179145724026785, 0.23713753117198322, 0.30414515480748894, 0.9902645776167716, 0.24776337686488414, 0.3492073680920732, 0.7630397641765437, 0.5609560509183409, 0.35186378550461217, 0.6049203270267673, 0.1716111651411225, 0.5015662059530757]}}
{"id": "a804a527-e34e-432d-83e8-1235dd4c251c", "fitness": 0.7477444182742787, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F and CR adaptation based on population diversity and a reduced update frequency, enhancing convergence speed and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.update_interval = 10 # Reduced update frequency\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        generation = 0\n        while self.evals < self.budget:\n            generation += 1\n\n            # Find the best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            # Parameter Adaptation: Generate F and CR for this generation\n            # Adapt F and CR based on population diversity less frequently\n            if generation % self.update_interval == 0:\n                diversity = np.std(self.fitness)\n                self.F = np.clip(np.random.normal(0.5, 0.3 * diversity), 0.1, 0.9)\n                self.CR = np.clip(np.random.normal(0.9, 0.2 * diversity), 0.1, 0.9)\n\n            for i in range(self.pop_size):\n                # Mutation: Use the best individual and two random individuals\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (best - self.population[i]) + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.748 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0390d29a-198a-4735-a1da-0731880dfcbe"], "operator": null, "metadata": {"aucs": [0.4202282336380687, 0.8093632387097582, 0.8875420503175302, 0.9572409553289133, 0.9026948979594589, 0.9085849411760633, 0.8121014707561273, 0.8634927490644636, 0.8976844635457311, 0.22018006696772197, 0.9579418923465353, 0.9933959251501057, 0.8341209857292616, 0.8965982304545241, 0.7191629880016486, 0.36008771186836597, 0.8396494989880655, 0.9371093329577579, 0.2473582835433248, 0.4903504489821482]}}
{"id": "9e5043b7-347c-4fb3-8d79-59b0fa45401f", "fitness": 0.7520312471520626, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F and CR based on success history and reduced parameter tuning.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                if self.evals >= self.budget:\n                    break\n\n            if self.success_F:\n                self.F = np.mean(self.success_F)\n                self.CR = np.mean(self.success_CR)\n                self.success_F = []\n                self.success_CR = []\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.0, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.752 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9ea9a5d0-1930-470f-85c4-f736aef4edf0"], "operator": null, "metadata": {"aucs": [0.39921511721088143, 0.742523946401077, 0.7416756741770939, 0.9040712432272353, 0.8068328521938803, 0.8172919605945035, 0.7515576060917211, 0.7166360883326384, 0.8076765927694218, 0.7692566977714987, 0.8931412006363659, 0.9911097741417598, 0.7388878085125659, 0.7721192371924095, 0.9454069494897592, 0.8119175212539813, 0.7019924123234427, 0.8771859640663856, 0.3240299713226912, 0.5280963253319401]}}
{"id": "1a59289b-f9e4-4f46-ac1e-07566201f5b5", "fitness": 0.740400711090032, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, focusing on population diversity and reduced archive interaction for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=5):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive. Reduced for speed.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.F = 0.5  # Single F value\n        self.CR = 0.9 # Single CR value\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual (less frequent archiving)\n                    if len(self.archive) < self.archive_size and np.random.rand() < 0.2:\n                        self.archive.append(self.population[i])\n                    elif len(self.archive) > 0 and np.random.rand() < 0.2:\n                        self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            #Adaptive F and CR: adjust them based on the performance of population\n            delta_fitness = np.abs(self.fitness - np.mean(self.fitness))\n            if np.sum(delta_fitness) > 0:\n                normalized_delta_fitness = delta_fitness / np.sum(delta_fitness)\n                self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.740 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["972f022e-c95a-419c-8c61-69a82c937c2f"], "operator": null, "metadata": {"aucs": [0.44491148474832276, 0.7031700537050553, 0.6604908313734172, 0.9089115881828335, 0.8020421077099275, 0.8241805142427769, 0.7277700928307862, 0.7324798879016303, 0.7967864973618171, 0.7404265298971979, 0.8826968086468695, 0.9990825929445236, 0.7548527414770891, 0.7995542468700204, 0.8734793739890997, 0.809423277271655, 0.7030410588702017, 0.8866971884250465, 0.25089942869681514, 0.507117916655556]}}
{"id": "fcf43502-9ca1-4441-9781-723c95893a4b", "fitness": 0.4317621347993524, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with enhanced exploration by dynamically adjusting F and CR based on population diversity and success rate.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = np.copy(self.population[i])\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial[cross_points] = mutant[cross_points]\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            if self.success_F:\n                self.F = np.mean(self.success_F)\n                self.CR = np.mean(self.success_CR)\n                self.success_F = []\n                self.success_CR = []\n            else:\n                self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 0.9)\n                self.CR = np.clip(np.random.normal(0.9, 0.2), 0.1, 0.9)\n                \n            self.F = np.clip(self.F, 0.1, 0.9)\n            self.CR = np.clip(self.CR, 0.1, 0.9)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.432 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0390d29a-198a-4735-a1da-0731880dfcbe"], "operator": null, "metadata": {"aucs": [0.16503754833512063, 0.30024261324253, 0.3905394394926348, 0.5310442536072769, 0.33606609091114437, 0.4297886493092603, 0.3072113278377886, 0.34794276160456306, 0.3590527564048639, 0.22016007800179316, 0.6695934352631587, 0.9980234527230152, 0.38807696983259177, 0.3325525256434301, 0.8050072108009142, 0.43519958827088, 0.3339143063431793, 0.5735174230105411, 0.22392090289657862, 0.4883513624557829]}}
{"id": "8dd999e1-0b18-4b8a-a18e-45ac18df3269", "fitness": 0.5432792696720481, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamically adjusted F and CR parameters based on population diversity, favoring exploitation when population converges and exploration otherwise.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, F_adapt=0.1, CR_adapt=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.F_adapt = F_adapt\n        self.CR_adapt = CR_adapt\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Calculate population diversity (standard deviation of fitness)\n            diversity = np.std(self.fitness)\n            \n            # Adjust F and CR based on diversity\n            if diversity < 1e-3:  # Population has converged\n                F = self.F + self.F_adapt\n                CR = self.CR - self.CR_adapt\n            else:\n                F = self.F - self.F_adapt\n                CR = self.CR + self.CR_adapt\n\n            F = np.clip(F, 0.1, 0.9)\n            CR = np.clip(CR, 0.1, 0.9)\n\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + F * (best - self.population[a]) + F * (self.population[b] - self.population[i])\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection (Stochastic Acceptance)\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.543 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4f1f5c46-d4f6-430b-89dc-b818c3acdbfc"], "operator": null, "metadata": {"aucs": [0.14894896401819024, 0.34292152598552983, 0.3814986515420855, 0.19849596146165527, 0.8886594948493387, 0.9157204589749317, 0.36854111022371117, 0.8525676596156939, 0.31725928576677964, 0.4244520818633224, 0.3664595845395888, 0.9972359708755488, 0.3484640680979906, 0.8662016329013428, 0.9583403849301332, 0.8161234109021338, 0.3405358509287133, 0.369146972007235, 0.424502684604565, 0.5395096393524723]}}
{"id": "69d511ee-109d-4761-b92b-a02c744ecee6", "fitness": 0.6973698499659152, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive F and CR values based on the best solution's success, archive interaction, and reduced parameter adjustments.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=10, archive_prob=0.1):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive.\n            archive_prob (float): The probability of interacting with the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.archive_prob = archive_prob\n        self.F = 0.5  # Initial F value\n        self.CR = 0.9 # Initial CR value\n        self.F_mem = [0.5] * 10  # Memory for F\n        self.CR_mem = [0.9] * 10 # Memory for CR\n        self.mem_idx = 0\n        self.success_F = []\n        self.success_CR = []\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    # Archive the replaced individual\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i])\n                    else:\n                        if len(self.archive) > 0:\n                            self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                elif len(self.archive) > 0 and np.random.rand() < self.archive_prob:\n                    arch_idx = np.random.randint(len(self.archive))\n                    arch_member = self.archive[arch_idx]\n\n                    # Mutation with archive\n                    idxs = np.random.choice(self.pop_size, 2, replace=False)\n                    a, b = idxs[0], idxs[1]\n                    mutant = self.population[a] + self.F * (arch_member - self.population[b])\n                    mutant = np.clip(mutant, self.lb, self.ub)\n\n                    # Crossover with archive-based mutant\n                    trial = np.copy(self.population[i])\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR or j == j_rand:\n                            trial[j] = mutant[j]\n\n                    # Evaluation\n                    f = func(trial)\n                    self.evals += 1\n\n                    # Selection\n                    if f < self.fitness[i]:\n                        self.success_F.append(self.F)\n                        self.success_CR.append(self.CR)\n                        # Archive the replaced individual\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(self.population[i])\n                        else:\n                            if len(self.archive) > 0:\n                                self.archive[np.random.randint(len(self.archive))] = self.population[i]\n                        self.population[i] = trial\n                        self.fitness[i] = f\n\n                        # Update best solution\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            #Adaptive F and CR: adjust them based on the success\n            if self.success_F and self.success_CR:\n                self.F_mem[self.mem_idx] = np.mean(self.success_F)\n                self.CR_mem[self.mem_idx] = np.mean(self.success_CR)\n                self.mem_idx = (self.mem_idx + 1) % 10\n            \n            self.F = np.clip(np.random.normal(np.mean(self.F_mem), 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(np.mean(self.CR_mem), 0.1), 0.1, 1.0)\n            self.success_F = []\n            self.success_CR = []\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.697 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["972f022e-c95a-419c-8c61-69a82c937c2f"], "operator": null, "metadata": {"aucs": [0.25402623827853654, 0.6935465784455146, 0.6369127741005107, 0.8982046563827975, 0.7542959104004343, 0.8471550669893639, 0.7113244989130474, 0.7119364144202635, 0.7569017360079744, 0.691839189337474, 0.8642795431513117, 0.9955237226176139, 0.37044926304970693, 0.778218578128838, 0.9274676772677902, 0.8217371869142132, 0.5997510790646827, 0.8791257845746518, 0.2502020405416271, 0.5044990607319517]}}
{"id": "e5c0d250-2d21-4a88-b3f2-6ba8c1e55b1a", "fitness": 0.7311762571873575, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F/CR adjustment based on success and reduced parameter space exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n                f = func(trial)\n                self.evals += 1\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.0, 1.0)\n                if self.evals >= self.budget:\n                    break\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.731 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9ea9a5d0-1930-470f-85c4-f736aef4edf0"], "operator": null, "metadata": {"aucs": [0.35666207586680165, 0.7441990431510257, 0.7462134384916539, 0.9013202692351575, 0.7865295950618733, 0.8287547129568043, 0.677527177246589, 0.6987613896039224, 0.7931803103370674, 0.7338881066757243, 0.9012141034720582, 0.995521043203804, 0.6822285675375688, 0.7517325066810091, 0.9227326045258062, 0.7811373981368389, 0.6649143346195507, 0.8535864018116173, 0.28192005418573896, 0.5215020109465401]}}
{"id": "99c8f230-b17f-4751-9be0-db9d8fea1473", "fitness": 0.5322383327887137, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution using best solution and a single other random individual for mutation, with dynamic F adaptation based on success rate, and improved stochastic acceptance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.success_rate = 0.0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        success_count = 0\n\n        while self.evals < self.budget:\n            # Find the current best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Mutation using best and one other random individual\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a = np.random.choice(idxs)\n                mutant = self.population[i] + self.F * (best - self.population[i]) + self.F * (self.population[a] - self.population[i])\n\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection (Stochastic Acceptance with scaling)\n                delta = self.fitness[i] - f\n                if delta > 0 and np.random.rand() < (delta / (abs(self.fitness[i]) + 1e-8)):  # Scale acceptance probability\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    success_count += 1\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n\n                if self.evals >= self.budget:\n                    break\n            \n            self.success_rate = success_count / self.pop_size\n            # Adapt F based on success rate (simple adaptation)\n            if self.success_rate > 0.4:\n                self.F = min(self.F + 0.1, 1.0)\n            elif self.success_rate < 0.1:\n                self.F = max(self.F - 0.1, 0.1)\n            success_count = 0\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.532 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4f1f5c46-d4f6-430b-89dc-b818c3acdbfc"], "operator": null, "metadata": {"aucs": [0.14523619103675878, 0.28457085243188907, 0.8568440205980259, 0.172624262299777, 0.8552584644043308, 0.8563344515952869, 0.2631652326067496, 0.6500255635079193, 0.8668374987749831, 0.16218571450237507, 0.9143297502942608, 0.9942135919843144, 0.26385543475913364, 0.23813334532985886, 0.27983095609643904, 0.8844505340332559, 0.40766999729238873, 0.8974565669286084, 0.21784807519245764, 0.4338961521054593]}}
{"id": "adbbbdc4-22bb-4bd3-a29d-611ad020319e", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and reduced archive interactions for faster convergence, while employing a mirrored boundary handling strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n\n                # Mirrored boundary handling\n                for j in range(self.dim):\n                    if mutant[j] < self.lb:\n                        mutant[j] = self.lb + (self.lb - mutant[j])\n                    elif mutant[j] > self.ub:\n                        mutant[j] = self.ub - (mutant[j] - self.ub)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adaptation of F and CR (simplified)\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "An exception occurred: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all().", "error": "", "parent_ids": ["1a59289b-f9e4-4f46-ac1e-07566201f5b5"], "operator": null, "metadata": {}}
{"id": "d46e9907-2b75-4a00-bcf0-6dc8e1621674", "fitness": 0.565044980786167, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on population fitness improvement and reduced stochasticity for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        \n        best_history = [self.f_opt]\n        \n        while self.evals < self.budget:\n            \n            improved = False\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                \n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.copy(self.population[i])\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial[crossover_mask] = mutant[crossover_mask]\n                \n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        improved = True\n\n                if self.evals >= self.budget:\n                    break\n            \n            best_history.append(self.f_opt)\n\n            if improved:\n                self.F = np.clip(self.F + 0.1 * np.random.normal(), 0.1, 1.0)\n                self.CR = np.clip(self.CR + 0.1 * np.random.normal(), 0.0, 1.0)\n            else:\n                self.F = np.clip(self.F - 0.05 * np.random.normal(), 0.1, 1.0)\n                self.CR = np.clip(self.CR - 0.05 * np.random.normal(), 0.0, 1.0)\n                \n            \n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.565 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9e5043b7-347c-4fb3-8d79-59b0fa45401f"], "operator": null, "metadata": {"aucs": [0.217163854776789, 0.35377167239509777, 0.4752497827934531, 0.8006048003751852, 0.569710086998096, 0.6779978094439811, 0.4857991361789765, 0.5726525462166034, 0.6709938479187715, 0.7382025921383415, 0.7453886601982627, 0.9995699640818497, 0.48899926371439295, 0.6109372552453552, 0.6819185965456479, 0.3805722182341913, 0.4462628948431622, 0.5751683152326924, 0.31576633289165146, 0.49416998550083713]}}
{"id": "903f596e-78b9-4432-bef1-730fd584c26c", "fitness": 0.6732513961260563, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive F and CR based on population diversity, reducing computational overhead.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Initial F value\n        self.CR = 0.9 # Initial CR value\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adaptive F and CR based on population fitness diversity\n            fitness_std = np.std(self.fitness)\n            self.F = np.clip(0.5 + 0.3 * fitness_std, 0.1, 1.0)  # Adjust F based on fitness std\n            self.CR = np.clip(0.9 - 0.2 * fitness_std, 0.1, 1.0) # Adjust CR based on fitness std\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.673 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1a59289b-f9e4-4f46-ac1e-07566201f5b5"], "operator": null, "metadata": {"aucs": [0.151487212078387, 0.3774392610621282, 0.7336854980258838, 0.8395057644378758, 0.7744233646779966, 0.8053685195350033, 0.6436993521946188, 0.6823899621483185, 0.7214707181590931, 0.6232949312642181, 0.840702493515098, 0.9944464046304541, 0.3726757540546132, 0.743946346022144, 0.9271175438587506, 0.8247412743523312, 0.6478052193506569, 0.8601308037216571, 0.22709128177115667, 0.6736062176607414]}}
{"id": "4562b973-6470-463e-a732-d2977902d325", "fitness": 0.7505509646680039, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on population diversity and stochastic universal sampling for parent selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.diversity_update_interval = 10\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        generation = 0\n        while self.evals < self.budget:\n            generation += 1\n\n            # Stochastic Universal Sampling for parent selection\n            probabilities = self.fitness.max() - self.fitness + 1e-8  # Add small value to avoid zero probabilities\n            probabilities /= probabilities.sum()\n            indices = np.random.choice(self.pop_size, size=self.pop_size, replace=True, p=probabilities)\n\n            # Parameter Adaptation based on population diversity\n            if generation % self.diversity_update_interval == 0:\n                diversity = np.std(self.fitness)\n                self.F = np.clip(np.random.normal(0.5, 0.3 * diversity), 0.1, 0.9)\n                self.CR = np.clip(np.random.normal(0.9, 0.2 * diversity), 0.1, 0.9)\n\n            for i in range(self.pop_size):\n                # Mutation: Use stochastic universal sampling and the current individual\n                a, b = np.random.choice(self.pop_size, 2, replace=False)\n                mutant = self.population[indices[i]] + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial[crossover_mask] = mutant[crossover_mask]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.751 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a804a527-e34e-432d-83e8-1235dd4c251c"], "operator": null, "metadata": {"aucs": [0.40555705135960374, 0.8114831792040812, 0.8010011127942054, 0.9025869933699218, 0.8375880873356327, 0.8718077547183358, 0.7875952096741612, 0.788561143695368, 0.8399698264529831, 0.8091240646616522, 0.9039294577196886, 0.996504890770208, 0.34565322606422255, 0.8141725484480247, 0.7502161307823386, 0.8627158379078714, 0.8082259231385991, 0.909454039309587, 0.23781280484026768, 0.5270600111133239]}}
{"id": "785e31b5-68da-4c5b-be10-7325da9b680e", "fitness": 0.7346733674399007, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with reduced population diversity metric, adaptive F/CR, and archive interaction for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=5):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            archive_size (int): The size of the archive. Reduced for speed.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive = []\n        self.archive_size = archive_size\n        self.F = 0.5  # Single F value\n        self.CR = 0.9 # Single CR value\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive the replaced individual (less frequent archiving)\n                    if len(self.archive) < self.archive_size and np.random.rand() < 0.1:\n                        self.archive.append(self.population[i])\n                    elif len(self.archive) > 0 and np.random.rand() < 0.1:\n                        self.archive[np.random.randint(len(self.archive))] = self.population[i]\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n            #Adaptive F and CR: adjust them based on the performance of population\n            diversity = np.std(self.fitness)\n            self.F = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)\n            self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.735 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1a59289b-f9e4-4f46-ac1e-07566201f5b5"], "operator": null, "metadata": {"aucs": [0.43161645236829094, 0.7485239589727347, 0.7443645588771286, 0.8555603161641469, 0.7865071066831946, 0.8213023570103182, 0.369293780838313, 0.7377131460389958, 0.7974888561363238, 0.7300762565239514, 0.9048047522683362, 0.9885762606127655, 0.751389467145853, 0.7720145698464335, 0.930732409801605, 0.847384787527233, 0.7413965050237817, 0.8699291892364567, 0.34633357864807557, 0.5184590390740798]}}
{"id": "a046f2d7-985c-4017-b518-c3e984b668a4", "fitness": 0.7427876503850989, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified F and CR adaptation based on current best and population, combined with a reduced update frequency for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.update_interval = 10  # Reduced update frequency\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        generation = 0\n        while self.evals < self.budget:\n            generation += 1\n\n            # Find the best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            # Parameter Adaptation: Generate F and CR for this generation\n            # Adapt F and CR based on the current best and population\n            if generation % self.update_interval == 0:\n                self.F = 0.5 + 0.3 * np.random.randn()\n                self.CR = 0.9 + 0.1 * np.random.randn()\n                self.F = np.clip(self.F, 0.1, 0.9)\n                self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            for i in range(self.pop_size):\n                # Mutation: Use the best individual and two random individuals\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (best - self.population[i]) + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.743 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a804a527-e34e-432d-83e8-1235dd4c251c"], "operator": null, "metadata": {"aucs": [0.4526171302595767, 0.8052147822062006, 0.7671617306985983, 0.2640923865263892, 0.822187872810058, 0.9079758489663265, 0.8061056851199007, 0.845270312221724, 0.8275015436784564, 0.30630013059922534, 0.9271863890977361, 0.9943724687187101, 0.7638640219305292, 0.816576576160744, 0.9214333094289527, 0.6812168312366251, 0.8238877303186389, 0.9232924570006592, 0.6934148224075125, 0.5060809783154134]}}
{"id": "a2114dcc-3eda-4cbc-893d-b65b7c8434bc", "fitness": 0.72399617324587, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters F and CR based on fitness improvements and reduced computational overhead.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        \n                    # Adaptive F and CR\n                    self.F = 0.5 + 0.3 * np.random.randn()\n                    self.CR = 0.9 + 0.1 * np.random.randn()\n                    self.F = np.clip(self.F, 0.1, 1.0)\n                    self.CR = np.clip(self.CR, 0.1, 1.0)\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.724 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1a59289b-f9e4-4f46-ac1e-07566201f5b5"], "operator": null, "metadata": {"aucs": [0.37435264814122726, 0.7118944521935776, 0.6909803610727252, 0.880523261509258, 0.7890343833607852, 0.7968908308988361, 0.694273084560836, 0.6741042191417037, 0.786584315951151, 0.7040747416335347, 0.8694762821175401, 0.9993143484322695, 0.6469644594156101, 0.7560688864970136, 0.9313836456859463, 0.7905663059856926, 0.6581422443193131, 0.8586705733617825, 0.3464828573371598, 0.5201415633014367]}}
{"id": "a3d83b15-7a5c-4d15-a19c-c7f2d8653437", "fitness": 0.6545667459475681, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F and CR adaptation based on a simplified success history and reduced parameter tuning.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_F = []\n        self.success_CR = []\n        self.memory_size = 5\n        self.p = 0.1\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Mutation: Use the best individual and two random individuals\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (best - self.population[i]) + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    delta = np.abs(self.fitness[i] - f)\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n            #Adapt parameters every generation using success history\n            if self.success_F:\n                self.F = np.mean(self.success_F)\n                self.CR = np.mean(self.success_CR)\n\n                #Keep success history limited\n                if len(self.success_F) > self.memory_size:\n                   self.success_F = self.success_F[-self.memory_size:]\n                   self.success_CR = self.success_CR[-self.memory_size:]\n            else:\n                self.F = 0.5\n                self.CR = 0.9\n\n            self.F = np.clip(np.random.normal(self.F, self.p), 0.1, 0.9)\n            self.CR = np.clip(np.random.normal(self.CR, self.p), 0.1, 0.9)\n\n            if self.evals >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.655 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a804a527-e34e-432d-83e8-1235dd4c251c"], "operator": null, "metadata": {"aucs": [0.19480809213382122, 0.6401529983360232, 0.7330230360781744, 0.898753759425083, 0.3175399657810394, 0.8588400612848395, 0.3441327465396443, 0.7445995705499469, 0.8210000119196137, 0.365688622599853, 0.9172467831933492, 0.9904729468122361, 0.5047543616055452, 0.8436912418825976, 0.9606991849441306, 0.6961330205871886, 0.5251773098820665, 0.8945233553100634, 0.31305988322398737, 0.5270379668621608]}}
{"id": "47e49f6a-e051-4ff4-8a60-c35b8d463638", "fitness": 0.7672577864155067, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced memory usage, using a decaying learning rate for F and CR adjustments based on recent successes.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, learning_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.learning_rate = learning_rate\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                \n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                trial[crossover_mask] = mutant[crossover_mask]\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                if self.evals >= self.budget:\n                    break\n\n            if self.success_F:\n                mean_F = np.mean(self.success_F)\n                mean_CR = np.mean(self.success_CR)\n                self.F = (1 - self.learning_rate) * self.F + self.learning_rate * mean_F\n                self.CR = (1 - self.learning_rate) * self.CR + self.learning_rate * mean_CR\n                self.success_F = []\n                self.success_CR = []\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.0, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.767 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9e5043b7-347c-4fb3-8d79-59b0fa45401f"], "operator": null, "metadata": {"aucs": [0.35430913732417346, 0.7633368247665445, 0.7451616989610865, 0.900094469255705, 0.8024309143869999, 0.8461935580939617, 0.7104561877433928, 0.7347822314037901, 0.7952288610486664, 0.7341659209987588, 0.8734460073715771, 0.9997458841950608, 0.7438961099096799, 0.7985353086191647, 0.9255754008730589, 0.816415169863219, 0.6837600702257509, 0.8601756452080944, 0.6194452455762272, 0.6380010824852238]}}
{"id": "ec458f1a-3c81-4e82-9ad3-63ddbba18235", "fitness": 0.6709245011778255, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on population performance and a focus on local search around the current best solution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        \"\"\"\n        Initialize the Adaptive Differential Evolution algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        \"\"\"\n        Optimize the given black box function using Adaptive Differential Evolution.\n\n        Args:\n            func (callable): The black box function to optimize.\n\n        Returns:\n            tuple: The best function value found and the corresponding solution.\n        \"\"\"\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            # Find the best individual\n            best_idx = np.argmin(self.fitness)\n            best = self.population[best_idx]\n\n            for i in range(self.pop_size):\n                # Mutation: Focus on local search around the best individual\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b = np.random.choice(idxs, 2, replace=False)\n                mutant = self.population[i] + self.F * (best - self.population[i]) + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial[cross_points] = mutant[cross_points]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Adaptive F/CR based on performance\n                if f < self.fitness[i]:\n                    self.F = 0.9 * self.F + 0.1 * np.random.rand()\n                    self.CR = 0.9 * self.CR + 0.1 * np.random.rand()\n                    self.population[i] = trial\n                    self.fitness[i] = f\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.671 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a804a527-e34e-432d-83e8-1235dd4c251c"], "operator": null, "metadata": {"aucs": [0.20586364263055723, 0.36282944100407, 0.7614930082461595, 0.8955724584944428, 0.7991056123098526, 0.8515820047245222, 0.5326262736478548, 0.7088156603478282, 0.8275224141110707, 0.5857693385964363, 0.8583447093131343, 0.997729133809975, 0.37356372983604513, 0.6348634158405537, 0.9345119287919074, 0.8475717221471498, 0.6377374179833115, 0.8786620226530276, 0.20609826291993982, 0.5182278261486719]}}
{"id": "65ce2f8a-075c-49f7-aaf2-f044e3163cb3", "fitness": 0.7505900542730266, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, reduced memory usage and faster adaptation based on current best solution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        \n        indices = np.arange(self.pop_size)\n\n        while self.evals < self.budget:\n            np.random.shuffle(indices)\n            for i in indices:\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                trial[mask] = mutant[mask]\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.0, 1.0)\n\n                if self.evals >= self.budget:\n                    break\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.751 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e5c0d250-2d21-4a88-b3f2-6ba8c1e55b1a"], "operator": null, "metadata": {"aucs": [0.47327633863567076, 0.681455023603661, 0.738499041008211, 0.8893356768592078, 0.768721720523008, 0.8107955449860146, 0.7388652282077397, 0.6995724799060591, 0.7909100662062034, 0.746153895752427, 0.8799124802967423, 0.9945934808682421, 0.6636514570651522, 0.7741563047064574, 0.9412801537874352, 0.8316139289869651, 0.6431949282623872, 0.8675401846918651, 0.5545078410604141, 0.5237653100466684]}}
{"id": "9066dedf-ed20-4ab0-9f49-217579c7981b", "fitness": 0.7522739854045217, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on a shorter memory of successful F/CR values and reduced conditional checks for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, memory=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.memory = memory\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.population[i])\n                \n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                if self.evals >= self.budget:\n                    break\n\n            if self.success_F:\n                self.F = np.mean(self.success_F[-self.memory:])\n                self.CR = np.mean(self.success_CR[-self.memory:])\n                \n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.0, 1.0)\n            self.success_F = []\n            self.success_CR = []\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.752 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9e5043b7-347c-4fb3-8d79-59b0fa45401f"], "operator": null, "metadata": {"aucs": [0.37869778994581027, 0.7042945923187265, 0.7420491307726031, 0.9046058876690396, 0.7926928728490595, 0.8167890165878686, 0.6749597647252377, 0.7066692492922906, 0.7908210694372267, 0.7362069996754954, 0.8721645178897386, 0.9986885349198634, 0.7105156744706123, 0.7977723720312565, 0.9269265650570973, 0.8131318799762329, 0.6563124048540031, 0.8783824729276668, 0.6279897419031693, 0.5158091707874364]}}
{"id": "e593c07a-4a7f-4658-9310-33756f37542c", "fitness": 0.6234592763404515, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with faster adaptation using the best solution as a pivot and reduced conditional checks.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                a, b = np.random.choice(self.pop_size, 2, replace=False)\n                mutant = self.x_opt + self.F * (self.population[a] - self.population[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.population[i])\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                        self.CR = np.clip(np.random.normal(0.9, 0.1), 0.0, 1.0)\n\n                if self.evals >= self.budget:\n                    break\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.623 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["65ce2f8a-075c-49f7-aaf2-f044e3163cb3"], "operator": null, "metadata": {"aucs": [0.14424644137466947, 0.22817002290791655, 0.9220179268453988, 0.19878921065336663, 0.30182186474617834, 0.9395178129262083, 0.3241304233792476, 0.5470414162732916, 0.943562207796428, 0.1777569272711237, 0.965706388304137, 0.9964601289264801, 0.3781262510888055, 0.8936915656483891, 0.9635972526849088, 0.9353561652602931, 0.8859061151093921, 0.9650954032044077, 0.2608448118653569, 0.49734719054302945]}}
{"id": "d4c2610f-68f6-447e-b46f-b983dd7e1945", "fitness": 0.3576359873141991, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a focus on local search and parameter adaptation based on successful mutation rates.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_rate = 0.0  # Track success rate for F/CR adaptation\n        self.success_history = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n\n        # Initialize population\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.population[i] + self.F * (self.population[a] - self.population[b])\n\n                # Local search around the best solution\n                mutant = 0.5 * mutant + 0.5 * self.x_opt # Towards best\n\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.copy(self.population[i])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial[crossover_mask] = mutant[crossover_mask]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    self.success_history.append(1)\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                else:\n                    self.success_history.append(0)\n\n                if self.evals >= self.budget:\n                    break\n            \n            # Parameter Adaptation based on success rate\n            if len(self.success_history) > self.pop_size:\n                self.success_rate = np.mean(self.success_history[-self.pop_size:])  # Moving average\n                self.F = np.clip(self.F + 0.1 * (self.success_rate - 0.5), 0.1, 0.9) # Simple update\n                self.CR = np.clip(self.CR + 0.1 * (self.success_rate - 0.5), 0.1, 0.9) # Simple update\n                \n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.358 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4562b973-6470-463e-a732-d2977902d325"], "operator": null, "metadata": {"aucs": [0.1366930891842889, 0.18989346495717174, 0.4538572997395297, 0.19045397403458575, 0.31634162721025194, 0.4511948098333861, 0.2647579358592025, 0.2878720216621802, 0.27121524316006473, 0.5599320552374969, 0.20567226171054054, 0.9983243148147093, 0.256806565248358, 0.22383397220039547, 0.7249723579619556, 0.3262330804584035, 0.3535889158761676, 0.25473797887342386, 0.19647278671083246, 0.48986599155103594]}}
{"id": "80e2b136-95b2-4cf8-8fbe-9fbf30b4c12f", "fitness": 0.46003635678023935, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced memory footprint by using a single, dynamically adjusted learning rate for both F and CR, focusing on immediate improvements.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, learning_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.learning_rate = learning_rate\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                \n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                trial[crossover_mask] = mutant[crossover_mask]\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    \n                    delta_f = self.fitness[i] - f\n                    \n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n                    # Adjust F and CR based on improvement\n                    self.F = np.clip(self.F * (1 + self.learning_rate * delta_f), 0.1, 1.0)\n                    self.CR = np.clip(self.CR * (1 + self.learning_rate * delta_f), 0.0, 1.0)\n\n\n\n                if self.evals >= self.budget:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.460 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["47e49f6a-e051-4ff4-8a60-c35b8d463638"], "operator": null, "metadata": {"aucs": [0.15170351551278527, 0.35058112609197345, 0.3952838714878989, 0.6473755554230622, 0.3696741874185637, 0.4561247825180146, 0.3062312226512611, 0.35302483579300237, 0.34620713708547557, 0.30312847255210407, 0.7565923630195049, 0.9964742398589526, 0.42491932293066326, 0.36336274940364477, 0.8650759107225107, 0.4445734027301004, 0.34981339108288223, 0.5788582078651692, 0.253806455737573, 0.48791638571964446]}}
{"id": "663262b3-d008-4e54-a1bf-b49e17380f01", "fitness": 0.595833357747303, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F/CR adaptation based on successful mutations and reduced memory.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.success_f = []\n        self.success_cr = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        \n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(self.population[i])\n                mask = np.random.rand(self.dim) < self.CR\n                mask[j_rand] = True\n                trial[mask] = mutant[mask]\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.success_f.append(self.F)\n                    self.success_cr.append(self.CR)\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.evals >= self.budget:\n                    break\n            \n            if self.success_f:\n                self.F = np.mean(self.success_f)\n                self.CR = np.mean(self.success_cr)\n                self.F = np.clip(np.random.normal(self.F, 0.1), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(self.CR, 0.1), 0.0, 1.0)\n                self.success_f = []\n                self.success_cr = []\n            else:\n                self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                self.CR = np.clip(np.random.normal(0.9, 0.1), 0.0, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.596 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["65ce2f8a-075c-49f7-aaf2-f044e3163cb3"], "operator": null, "metadata": {"aucs": [0.45278932704420183, 0.2864072301944336, 0.402815550453984, 0.7884320877553073, 0.5955252094796721, 0.3196710454369658, 0.4605197519818133, 0.531904714106067, 0.7544483609129397, 0.7020012902183208, 0.666864307287903, 0.9990447763959058, 0.36970901641990994, 0.7083486190282687, 0.9198759126961262, 0.73890038071812, 0.46248379616136814, 0.7999252022138723, 0.42838223991665514, 0.5286183365242256]}}
{"id": "d60af5be-1f6a-40f0-a567-3114d55a223b", "fitness": 0.764811251463018, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, reduced memory and momentum-based updates for F and CR, enhancing exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, learning_rate=0.1, momentum=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.learning_rate = learning_rate\n        self.momentum = momentum  # Momentum for F and CR updates\n        self.prev_F = F\n        self.prev_CR = CR\n        self.success_F = []\n        self.success_CR = []\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                \n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                trial[crossover_mask] = mutant[crossover_mask]\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                if self.evals >= self.budget:\n                    break\n\n            if self.success_F:\n                mean_F = np.mean(self.success_F)\n                mean_CR = np.mean(self.success_CR)\n                \n                # Momentum-based update\n                self.F = (1 - self.learning_rate) * self.F + self.learning_rate * mean_F + self.momentum * (self.F - self.prev_F)\n                self.CR = (1 - self.learning_rate) * self.CR + self.learning_rate * mean_CR + self.momentum * (self.CR - self.prev_CR)\n\n                # Store current values for momentum\n                self.prev_F = self.F\n                self.prev_CR = self.CR\n\n                self.success_F = []\n                self.success_CR = []\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.0, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.765 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["47e49f6a-e051-4ff4-8a60-c35b8d463638"], "operator": null, "metadata": {"aucs": [0.47016900878504964, 0.7281467020435883, 0.7517250921408767, 0.9015633180422851, 0.8096336655850815, 0.82419924872995, 0.7021203842832432, 0.7385434671444712, 0.7829856571682907, 0.7325648641197433, 0.8965023666036167, 0.999669832816379, 0.7259480255507941, 0.7787036072379203, 0.932828403127913, 0.817898204542305, 0.7035663763340944, 0.8809040593545767, 0.6129573375308438, 0.505595408119335]}}
{"id": "ded31518-5ce0-4a0c-9d96-f76699441031", "fitness": 0.5915849107226935, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using exponentially weighted moving averages for F/CR updates and a more aggressive mutation strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, alpha_F=0.2, alpha_CR=0.2):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.alpha_F = alpha_F\n        self.alpha_CR = alpha_CR\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 4, replace=False)\n                a, b, c, d = idxs[0], idxs[1], idxs[2], idxs[3]  # Added one more parent\n                \n                # More aggressive mutation\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c]) + self.F * (self.population[d] - self.population[i])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.population[i])\n                \n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    delta_F = self.F\n                    delta_CR = self.CR\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n                    # Exponentially weighted moving average update\n                    self.F = (1 - self.alpha_F) * self.F + self.alpha_F * delta_F\n                    self.CR = (1 - self.alpha_CR) * self.CR + self.alpha_CR * delta_CR\n                \n                if self.evals >= self.budget:\n                    break\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.0, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.592 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9066dedf-ed20-4ab0-9f49-217579c7981b"], "operator": null, "metadata": {"aucs": [0.1950045583073411, 0.42462948253451815, 0.5643474313761445, 0.8557617369073311, 0.670861185018925, 0.7111892490285356, 0.3638835559469983, 0.5323522665985041, 0.6418332376658398, 0.521307522112259, 0.7937989516354887, 0.9944660861179976, 0.45101708357192627, 0.5794361372656011, 0.9054350042439773, 0.6781743578532882, 0.45344885352994446, 0.799894861556944, 0.1933564901843412, 0.501500162997965]}}
{"id": "990aacf3-b728-486c-bdd9-e9df6c754414", "fitness": 0.7492889525510364, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using a shorter memory and momentum for faster and smoother F/CR adjustments.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9, learning_rate=0.1, momentum=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.learning_rate = learning_rate\n        self.momentum = momentum\n        self.success_F = []\n        self.success_CR = []\n        self.prev_F = F\n        self.prev_CR = CR\n\n    def __call__(self, func):\n        self.func = func\n        self.bounds = func.bounds\n        self.lb = self.bounds.lb\n        self.ub = self.bounds.ub\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = idxs[0], idxs[1], idxs[2]\n                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n                \n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                \n                crossover_mask = (np.random.rand(self.dim) < self.CR) | (np.arange(self.dim) == j_rand)\n                trial[crossover_mask] = mutant[crossover_mask]\n\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                if self.evals >= self.budget:\n                    break\n\n            if self.success_F:\n                mean_F = np.mean(self.success_F)\n                mean_CR = np.mean(self.success_CR)\n                self.F = self.momentum * self.prev_F + (1 - self.momentum) * ((1 - self.learning_rate) * self.F + self.learning_rate * mean_F)\n                self.CR = self.momentum * self.prev_CR + (1 - self.momentum) * ((1 - self.learning_rate) * self.CR + self.learning_rate * mean_CR)\n                self.prev_F = self.F\n                self.prev_CR = self.CR\n                self.success_F = []\n                self.success_CR = []\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.0, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.749 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["47e49f6a-e051-4ff4-8a60-c35b8d463638"], "operator": null, "metadata": {"aucs": [0.41394207155462226, 0.7075876681968725, 0.7507572110721585, 0.8814105700946878, 0.8092053310563665, 0.8351790944104127, 0.7079032741746891, 0.7426885794837732, 0.7790838254463239, 0.7334698694835072, 0.8898144450327612, 0.9971142600827912, 0.7452762838545801, 0.7915152000148172, 0.9112947351996517, 0.8228408391021088, 0.7082243981850294, 0.8501737798451146, 0.39634883895034057, 0.5119487757801204]}}
