{"id": "3a41ca8a-0c45-4298-b1c1-91e760e59f92", "fitness": -Infinity, "name": "CMAES_O", "description": "Covariance matrix adaptation evolution strategy with orthogonal sampling to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass CMAES_O:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, c_cov_mean=None, c_cov_sigma=None, c_cov_rank_one=None, c_cov_rank_mu=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2  # Number of parents/individuals selected\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))  # Eq. (4.1)\n        self.weights = self.weights / np.sum(self.weights)  # Normalize weights\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) # Variance effective selection mass\n\n        self.cs = cs\n        self.damps = damps if damps is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs # Damping for step-size\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff + 2)) # Learning rate for the mean\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / (self.dim + self.mueff + 5) # Learning rate for the rank-one update of C\n        self.c_cov_rank_one = c_cov_rank_one if c_cov_rank_one is not None else 1 / (2 * (self.dim + 1.3)**2 + self.mueff)\n        self.c_cov_rank_mu = c_cov_rank_mu if c_cov_rank_mu is not None else 0.3 / (self.dim**2 + self.mueff)\n\n        self.xmean = np.zeros(self.dim)    # Mean value\n        self.sigma = 0.5                   # Overall step-size\n        self.B = np.eye(self.dim)           # Eigenvectors of C\n        self.D = np.ones(self.dim)          # Eigenvalues of C\n        self.C = np.eye(self.dim)           # Covariance matrix\n        self.pc = np.zeros(self.dim)        # Evolution path for C\n        self.ps = np.zeros(self.dim)        # Evolution path for sigma\n        self.invsqrtC = np.eye(self.dim)\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        used_budget = 0\n\n        while used_budget < self.budget:\n            # Generate population\n            z = np.random.randn(self.dim, self.popsize)\n            x = self.xmean[:, np.newaxis] + self.sigma * (self.B @ (self.D * z)) # Eq (2) of CMA-ES\n            x = x.T\n\n            # orthogonal sampling\n            H = np.random.randn(self.popsize, self.popsize)\n            Q, R = np.linalg.qr(H)\n            \n            # Evaluate population, taking into account the budget constraint.\n            fitness = np.zeros(self.popsize)\n            for k in range(self.popsize):\n                if used_budget < self.budget:\n                    fitness[k] = func(x[k])\n                    used_budget += 1\n                else:\n                    fitness[k] = np.inf  # Assign a bad fitness if budget is exceeded\n\n            # Sort by fitness\n            idx = np.argsort(fitness)\n            x = x[idx]\n            fitness = fitness[idx]\n\n            if fitness[0] < self.f_opt:\n                self.f_opt = fitness[0]\n                self.x_opt = x[0]\n\n            # Selection and recombination\n            xmean_old = self.xmean.copy()\n            self.xmean = np.sum(x[:self.mu].T * self.weights, axis=1)\n            \n            # Cumulation\n            y = (self.xmean - xmean_old) / self.sigma\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.invsqrtC @ y)\n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * (used_budget / self.popsize))) / 1.414 / self.dim + 0.1) < 1\n            self.pc = (1 - self.c_cov_mean) * self.pc + hsig * np.sqrt(self.c_cov_mean * (2 - self.c_cov_mean) * self.mueff) * y\n\n            # Covariance matrix adaptation\n            artmp = (1 / self.sigma) * (x[:self.mu] - xmean_old)\n            self.C = (1 - self.c_cov_rank_one - self.c_cov_rank_mu) * self.C \\\n                + self.c_cov_rank_one * (self.pc[:, np.newaxis] @ self.pc[np.newaxis, :]) \\\n                + self.c_cov_rank_mu * np.sum(self.weights[:, np.newaxis, np.newaxis] * (artmp.T[:, :, np.newaxis] @ artmp.T[:, np.newaxis, :]), axis=0)\n            \n            # Eigen decomposition to update B and D\n            if (used_budget / self.popsize) % 10 == 0: # Re-decompose every 10 generations\n                self.C = np.triu(self.C) + np.triu(self.C, 1).T # enforce symmetry\n                self.D, self.B = np.linalg.eig(self.C)\n                self.D = np.sqrt(np.abs(self.D)) # prevent possible negative values\n                self.invsqrtC = self.B @ np.diag(self.D**-1) @ self.B.T\n\n            # Step-size adaptation\n            self.sigma = self.sigma * np.exp((self.c_cov_sigma / self.damps) * (np.linalg.norm(self.ps) / np.sqrt(self.dim) - 1))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "ee0eb935-2a55-47b4-a395-40a25278903a", "fitness": -Infinity, "name": "CMAES", "description": "Covariance Matrix Adaptation Evolution Strategy with a population size adaptation mechanism and a restart strategy.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov_mean=None, c_cov_sigma=None, restarts=5):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.restarts_counter = 0\n\n        if popsize is None:\n          self.popsize = 4 + int(3 * np.log(self.dim))\n        else:\n          self.popsize = popsize\n        \n        self.mu = self.popsize // 2  # Number of parents/selected points\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))  # Eq. 4.1\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) # Variance effective selection mass\n\n        self.cs = cs  # Cumulation factor for step-size\n        self.damps = 1 + 2 * np.max((0, np.sqrt((self.mueff - 1) / (self.dim + 1)) - 1)) + self.cs  # Damping factor\n        if damp is not None:\n            self.damps = damp # allow override\n        \n        self.ccov_mean = (1 / (self.damps * self.dim)) * (1 + (2 * self.mueff - 1) / ((self.mueff - 1 + self.dim)))\n        if c_cov_mean is not None:\n            self.ccov_mean = c_cov_mean\n\n        self.ccov_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        if c_cov_sigma is not None:\n            self.ccov_sigma = c_cov_sigma\n\n        self.mean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n\n        self.min_sigma = 1e-12\n        self.tolxup = 1e7\n\n    def sample_population(self):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        y = self.B.dot(self.D * z.T).T\n        x = self.mean + self.sigma * y\n        return x, y\n\n    def update_distribution(self, x, y, fitness_values):\n        # Sort population based on fitness\n        idx = np.argsort(fitness_values)\n        x = x[idx]\n        y = y[idx]\n\n        # Selection and recombination\n        y_mean = np.sum(self.weights[:, None] * y[:self.mu], axis=0)\n\n        # Update evolution path\n        self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.B.dot(y_mean * self.D))\n        norm_ps = np.linalg.norm(self.ps)\n        self.sigma *= np.exp((self.cs / self.damps) * (norm_ps / np.sqrt(self.dim) - 1))\n\n        # Check for stagnation\n        if self.sigma < self.min_sigma:\n            self.sigma = 0.25 # restart sigma\n            #print(\"Sigma Restart\")\n\n        # Update evolution path for covariance matrix\n        self.pc = (1 - self.ccov_mean) * self.pc + np.sqrt(self.ccov_mean * (2 - self.ccov_mean) * self.mueff) * y_mean\n        \n        # Update covariance matrix\n        artmp = (1 / self.sigma) * (x[:self.mu] - self.mean)\n        self.C = (1 - self.ccov_mean - self.ccov_sigma) * self.C + self.ccov_mean * np.outer(self.pc, self.pc) + self.ccov_sigma * np.sum(self.weights[:, None, None] * artmp[:, :, None] * artmp[:, None, :], axis=0)\n\n        # Adapt covariance matrix\n        if np.isinf(np.sum(self.C)):\n            self.C = np.eye(self.dim)  # Reset covariance matrix\n\n        self.C = np.triu(self.C) + np.triu(self.C, 1).T\n        self.D, self.B = np.linalg.eigh(self.C)\n        self.D = np.sqrt(np.abs(self.D))\n\n        # Update mean\n        self.mean += self.sigma * y_mean\n        \n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.restarts_counter = 0\n\n        while self.evaluations < self.budget:\n            x, y = self.sample_population()\n            \n            # Clip to bounds\n            lb = func.bounds.lb\n            ub = func.bounds.ub\n            x = np.clip(x, lb, ub)\n            \n            fitness_values = np.zeros(self.popsize)\n            for i in range(self.popsize):\n                if self.evaluations < self.budget:\n                  fitness_values[i] = func(x[i])\n                  self.evaluations += 1\n                  if fitness_values[i] < self.f_opt:\n                      self.f_opt = fitness_values[i]\n                      self.x_opt = x[i]\n                else:\n                    fitness_values[i] = np.Inf\n            \n            self.update_distribution(x, y, fitness_values)\n\n            # Break if function evaluation budget is met\n            if self.evaluations >= self.budget:\n                break\n            \n            # Restart if necessary\n            if np.max(self.D) > self.tolxup * np.min(self.D) or np.any(np.isnan(self.mean)) or np.any(np.isinf(self.mean)):\n              self.restarts_counter += 1\n              if self.restarts_counter <= self.restarts:\n                  self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim) # restart population\n                  self.sigma = 0.5\n                  self.C = np.eye(self.dim)\n                  self.B = np.eye(self.dim)\n                  self.D = np.ones(self.dim)\n                  self.pc = np.zeros(self.dim)\n                  self.ps = np.zeros(self.dim)\n\n              else:\n                  break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "a53f71a3-2cf7-46af-81c0-b7fb7a65c3dd", "fitness": 0.347601259713251, "name": "HybridPSO_DE", "description": "A population-based algorithm that combines particle swarm optimization (PSO) with differential evolution (DE) for exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, w=0.7, c1=1.5, c2=1.5, cr=0.7, f=0.8):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.w = w  # Inertia weight for PSO\n        self.c1 = c1 # Cognitive coefficient for PSO\n        self.c2 = c2 # Social coefficient for PSO\n        self.cr = cr  # Crossover rate for DE\n        self.f = f # Mutation factor for DE\n        self.pop = None\n        self.fitness = None\n        self.pbest = None\n        self.pbest_fitness = None\n        self.gbest = None\n        self.gbest_fitness = np.inf\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.pbest = self.pop.copy()\n        self.pbest_fitness = self.fitness.copy()\n        self.gbest = self.pop[np.argmin(self.fitness)].copy()\n        self.gbest_fitness = np.min(self.fitness)\n\n    def pso_update(self, func):\n        velocity = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            velocity[i] = (self.w * velocity[i]\n                           + self.c1 * np.random.rand(self.dim) * (self.pbest[i] - self.pop[i])\n                           + self.c2 * np.random.rand(self.dim) * (self.gbest - self.pop[i]))\n\n            self.pop[i] = self.pop[i] + velocity[i]\n            self.pop[i] = np.clip(self.pop[i], func.bounds.lb, func.bounds.ub)\n\n            fitness = func(self.pop[i])\n            self.eval_count += 1\n\n            if fitness < self.pbest_fitness[i]:\n                self.pbest_fitness[i] = fitness\n                self.pbest[i] = self.pop[i].copy()\n\n                if fitness < self.gbest_fitness:\n                    self.gbest_fitness = fitness\n                    self.gbest = self.pop[i].copy()\n        \n    def de_update(self, func):\n          for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = self.pop[np.random.choice(idxs, 3, replace=False)]\n            mutant = a + self.f * (b - c)\n            mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n            \n            trial = self.pop[i].copy()\n            for j in range(self.dim):\n                if np.random.rand() <= self.cr or j == np.random.randint(0, self.dim):\n                    trial[j] = mutant[j]\n                    \n            f = func(trial)\n            self.eval_count += 1\n            \n            if f < self.fitness[i]:\n                self.fitness[i] = f\n                self.pop[i] = trial.copy()\n                \n                if f < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = f\n                    self.pbest[i] = self.pop[i].copy()\n                    \n                    if f < self.gbest_fitness:\n                        self.gbest_fitness = f\n                        self.gbest = self.pop[i].copy()\n\n    def __call__(self, func):\n        self.initialize_population(func)\n        while self.eval_count < self.budget:\n            if self.eval_count < self.budget * 0.5:\n                 self.pso_update(func)\n            else:\n                self.de_update(func)\n\n        return self.gbest_fitness, self.gbest", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSO_DE scored 0.348 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.11062550497932933, 0.17529892948190318, 0.261014497302995, 0.2642735237094811, 0.20504959001048428, 0.3193705537071332, 0.2820761450359539, 0.24569253150112613, 0.3037706691325316, 0.1610039712634852, 0.5282783652548493, 0.9977035242819375, 0.2698228860434574, 0.21029321272346368, 0.7961933336090118, 0.30269790541764574, 0.22975464267072765, 0.5689657163828461, 0.20599380614065688, 0.5141458856160014]}}
{"id": "02cfeca4-0e65-4665-bf8c-eb5969c4abb6", "fitness": 0.6559463764972802, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with shrinking population and archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        archive = []\n\n        while self.budget > 0:\n            \n            # Shrink population size over time\n            new_pop_size = max(10, int(self.pop_size * (self.budget / 10000)))\n            if new_pop_size < self.pop_size:\n                # Select best individuals to keep\n                indices = np.argsort(fitness)[:new_pop_size]\n                population = population[indices]\n                fitness = fitness[indices]\n                self.pop_size = new_pop_size\n                \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    # Update archive (optional)\n                    if len(archive) < self.archive_size:\n                        archive.append(trial)\n                    else:\n                        # Replace random element in archive\n                        idx = np.random.randint(0, self.archive_size)\n                        archive[idx] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.656 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.3483135575007644, 0.798769662372013, 0.5787071371864267, 0.49617876674578687, 0.43482602820718097, 0.8767999861424983, 0.3394586723463393, 0.4854881418028052, 0.7201553455525513, 0.6785584230173665, 0.9146805612789557, 0.9912208233656699, 0.39233009726992185, 0.8006973310917085, 0.7904321119410784, 0.9188047409738288, 0.8504909433113808, 0.9265419672926882, 0.2512512393185582, 0.5252219932280797]}}
{"id": "ce8e0d9f-1a25-4f49-9847-c065d9aef56c", "fitness": -Infinity, "name": "CMAES_O", "description": "CMA-ES with orthogonal sampling, simplified for robustness and corrected broadcasting issues.", "code": "import numpy as np\n\nclass CMAES_O:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, c_cov_mean=None, c_cov_sigma=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        self.cs = cs\n        self.damps = damps if damps is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff + 2))\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / (self.dim + self.mueff + 5)\n\n        self.xmean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        used_budget = 0\n\n        while used_budget < self.budget:\n            # Generate population\n            z = np.random.randn(self.dim, self.popsize)\n            try:\n                C_sqrt = np.linalg.cholesky(self.C)\n                x = self.xmean[:, np.newaxis] + self.sigma * (C_sqrt @ z)\n            except np.linalg.LinAlgError:\n                # Handle non-positive definite covariance matrix\n                self.C = self.C + 1e-6 * np.eye(self.dim)  # Add a small multiple of identity matrix\n                C_sqrt = np.linalg.cholesky(self.C)\n                x = self.xmean[:, np.newaxis] + self.sigma * (C_sqrt @ z)\n\n            x = x.T\n\n            # orthogonal sampling\n            H = np.random.randn(self.popsize, self.popsize)\n            Q, R = np.linalg.qr(H)\n            x = self.xmean + self.sigma * (x - self.xmean) @ Q\n\n            # Evaluate population, taking into account the budget constraint.\n            fitness = np.zeros(self.popsize)\n            for k in range(self.popsize):\n                if used_budget < self.budget:\n                    fitness[k] = func(x[k])\n                    used_budget += 1\n                else:\n                    fitness[k] = np.inf\n\n            # Sort by fitness\n            idx = np.argsort(fitness)\n            x = x[idx]\n            fitness = fitness[idx]\n\n            if fitness[0] < self.f_opt:\n                self.f_opt = fitness[0]\n                self.x_opt = x[0]\n\n            # Selection and recombination\n            xmean_old = self.xmean.copy()\n            self.xmean = np.sum(x[:self.mu] * self.weights[:, np.newaxis], axis=0)\n\n            # Cumulation\n            y = (self.xmean - xmean_old) / self.sigma\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * y\n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * (used_budget / self.popsize))) / 1.414 / self.dim + 0.1) < 1\n            self.pc = (1 - self.c_cov_mean) * self.pc + hsig * np.sqrt(self.c_cov_mean * (2 - self.c_cov_mean) * self.mueff) * y\n\n            # Covariance matrix adaptation\n            artmp = (x[:self.mu] - xmean_old) / self.sigma\n            self.C = (1 - self.c_cov_sigma) * self.C + self.c_cov_sigma * (self.ps[:, np.newaxis] @ self.ps[np.newaxis, :]) \\\n                + self.c_cov_mean * np.sum(self.weights[:, np.newaxis, np.newaxis] * (artmp[:, :, np.newaxis] @ artmp[:, np.newaxis, :]), axis=0)\n\n            # Step-size adaptation\n            self.sigma = self.sigma * np.exp((self.cs / self.damps) * (np.linalg.norm(self.ps) / np.sqrt(self.dim) - 1))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 6 is different from 2).", "error": "", "parent_ids": ["3a41ca8a-0c45-4298-b1c1-91e760e59f92"], "operator": null, "metadata": {}}
{"id": "c9fb773a-dd74-428d-9998-b20075675cab", "fitness": -Infinity, "name": "CMAES_O", "description": "Covariance matrix adaptation evolution strategy with simplified orthogonal sampling, reduced complexity, and budget awareness.", "code": "import numpy as np\n\nclass CMAES_O:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, c_cov_mean=None, c_cov_sigma=None, c_cov_rank_one=None, c_cov_rank_mu=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        self.cs = cs\n        self.damps = damps if damps is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff + 2))\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / (self.dim + self.mueff + 5)\n        self.c_cov_rank_one = c_cov_rank_one if c_cov_rank_one is not None else 1 / (2 * (self.dim + 1.3)**2 + self.mueff)\n        self.c_cov_rank_mu = c_cov_rank_mu if c_cov_rank_mu is not None else 0.3 / (self.dim**2 + self.mueff)\n\n        self.xmean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.invsqrtC = np.eye(self.dim)\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        used_budget = 0\n\n        while used_budget < self.budget:\n            z = np.random.randn(self.dim, self.popsize)\n            x = self.xmean[:, np.newaxis] + self.sigma * (self.B @ (self.D * z))\n            x = x.T\n\n            fitness = np.zeros(self.popsize)\n            for k in range(self.popsize):\n                if used_budget < self.budget:\n                    fitness[k] = func(x[k])\n                    used_budget += 1\n                else:\n                    fitness[k] = np.inf\n\n            idx = np.argsort(fitness)\n            x = x[idx]\n            fitness = fitness[idx]\n\n            if fitness[0] < self.f_opt:\n                self.f_opt = fitness[0]\n                self.x_opt = x[0]\n\n            xmean_old = self.xmean.copy()\n            self.xmean = np.sum(x[:self.mu].T * self.weights, axis=1)\n            y = (self.xmean - xmean_old) / self.sigma\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.invsqrtC @ y)\n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * (used_budget / self.popsize))) / 1.414 / self.dim + 0.1) < 1\n            self.pc = (1 - self.c_cov_mean) * self.pc + hsig * np.sqrt(self.c_cov_mean * (2 - self.c_cov_mean) * self.mueff) * y\n\n            artmp = (1 / self.sigma) * (x[:self.mu] - xmean_old)\n            self.C = (1 - self.c_cov_rank_one - self.c_cov_rank_mu) * self.C \\\n                + self.c_cov_rank_one * (self.pc[:, np.newaxis] @ self.pc[np.newaxis, :]) \\\n                + self.c_cov_rank_mu * np.sum(self.weights[:, np.newaxis, np.newaxis] * (artmp.T[:, :, np.newaxis] @ artmp.T[:, np.newaxis, :]), axis=0)\n\n            if (used_budget / self.popsize) % 10 == 0:\n                self.C = np.triu(self.C) + np.triu(self.C, 1).T\n                try:\n                    self.D, self.B = np.linalg.eig(self.C)\n                    self.D = np.sqrt(np.abs(self.D))\n                    self.invsqrtC = self.B @ np.diag(self.D**-1) @ self.B.T\n                except np.linalg.LinAlgError:\n                    self.D = np.ones(self.dim)\n                    self.B = np.eye(self.dim)\n                    self.invsqrtC = np.eye(self.dim)\n\n            self.sigma = self.sigma * np.exp((self.c_cov_sigma / self.damps) * (np.linalg.norm(self.ps) / np.sqrt(self.dim) - 1))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["3a41ca8a-0c45-4298-b1c1-91e760e59f92"], "operator": null, "metadata": {}}
{"id": "5e756a22-f8e7-4b10-9d48-5360cd10e1c6", "fitness": -Infinity, "name": "CMAES_O", "description": "CMA-ES with orthogonal sampling, simplified eigenvalue decomposition and budget-aware population generation.", "code": "import numpy as np\n\nclass CMAES_O:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, c_cov_mean=None, c_cov_sigma=None, c_cov_rank_one=None, c_cov_rank_mu=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        self.cs = cs\n        self.damps = damps if damps is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff + 2))\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / (self.dim + self.mueff + 5)\n        self.c_cov_rank_one = c_cov_rank_one if c_cov_rank_one is not None else 1 / (2 * (self.dim + 1.3)**2 + self.mueff)\n        self.c_cov_rank_mu = c_cov_rank_mu if c_cov_rank_mu is not None else 0.3 / (self.dim**2 + self.mueff)\n\n        self.xmean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.invsqrtC = np.eye(self.dim)\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        used_budget = 0\n\n        while used_budget < self.budget:\n            remaining_budget = self.budget - used_budget\n            current_popsize = min(self.popsize, remaining_budget)\n\n            z = np.random.randn(self.dim, current_popsize)\n            x = self.xmean[:, np.newaxis] + self.sigma * (self.B @ (self.D * z))\n            x = x.T\n\n            fitness = np.zeros(current_popsize)\n            for k in range(current_popsize):\n                fitness[k] = func(x[k])\n                used_budget += 1\n\n            idx = np.argsort(fitness)\n            x = x[idx]\n            fitness = fitness[idx]\n\n            if fitness[0] < self.f_opt:\n                self.f_opt = fitness[0]\n                self.x_opt = x[0]\n\n            xmean_old = self.xmean.copy()\n            self.xmean = np.sum(x[:self.mu].T * self.weights[:min(self.mu, current_popsize)], axis=1)\n            y = (self.xmean - xmean_old) / self.sigma\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.invsqrtC @ y)\n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * (used_budget / self.popsize))) / 1.414 / self.dim + 0.1) < 1\n            self.pc = (1 - self.c_cov_mean) * self.pc + hsig * np.sqrt(self.c_cov_mean * (2 - self.c_cov_mean) * self.mueff) * y\n\n            artmp = (1 / self.sigma) * (x[:self.mu] - xmean_old)\n            \n            w = self.weights[:min(self.mu, current_popsize)]\n\n            self.C = (1 - self.c_cov_rank_one - self.c_cov_rank_mu) * self.C \\\n                + self.c_cov_rank_one * (self.pc[:, np.newaxis] @ self.pc[np.newaxis, :]) \\\n                + self.c_cov_rank_mu * np.sum(w[:, np.newaxis, np.newaxis] * (artmp.T[:, :, np.newaxis] @ artmp.T[:, np.newaxis, :]), axis=0)\n            \n            if (used_budget / self.popsize) % 10 == 0:\n                self.C = np.triu(self.C) + np.triu(self.C, 1).T\n                try:\n                    self.D, self.B = np.linalg.eigh(self.C)\n                    self.D = np.sqrt(np.abs(self.D))\n                    self.invsqrtC = self.B @ np.diag(self.D**-1) @ self.B.T\n                except np.linalg.LinAlgError:\n                    print(\"Singular matrix encountered. Resetting covariance matrix.\")\n                    self.C = np.eye(self.dim)\n                    self.B = np.eye(self.dim)\n                    self.D = np.ones(self.dim)\n                    self.invsqrtC = np.eye(self.dim)\n\n\n            self.sigma = self.sigma * np.exp((self.c_cov_sigma / self.damps) * (np.linalg.norm(self.ps) / np.sqrt(self.dim) - 1))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["3a41ca8a-0c45-4298-b1c1-91e760e59f92"], "operator": null, "metadata": {}}
{"id": "5a7b121f-8868-4cbd-9032-9359d3dac54d", "fitness": -Infinity, "name": "CMAES_O", "description": "CMA-ES with orthogonal sampling and simplified covariance update for better numerical stability.", "code": "import numpy as np\n\nclass CMAES_O:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damps=None, c_cov_mean=None, c_cov_sigma=None, c_cov_rank_one=None, c_cov_rank_mu=None):\n        self.budget = budget\n        self.dim = dim\n        self.popsize = popsize if popsize is not None else 4 + int(3 * np.log(self.dim))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        self.cs = cs\n        self.damps = damps if damps is not None else 1 + 2 * max(0, np.sqrt((self.mueff - 1)/(self.dim + 1)) - 1) + self.cs\n        self.c_cov_mean = c_cov_mean if c_cov_mean is not None else self.mueff / (self.dim + (self.mueff + 2))\n        self.c_cov_sigma = c_cov_sigma if c_cov_sigma is not None else (self.mueff + 2) / (self.dim + self.mueff + 5)\n        self.c_cov_rank_one = c_cov_rank_one if c_cov_rank_one is not None else 1 / (2 * (self.dim + 1.3)**2 + self.mueff)\n        self.c_cov_rank_mu = c_cov_rank_mu if c_cov_rank_mu is not None else 0.3 / (self.dim**2 + self.mueff)\n\n        self.xmean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.invsqrtC = np.eye(self.dim)\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        used_budget = 0\n\n        while used_budget < self.budget:\n            # Generate population\n            z = np.random.randn(self.dim, self.popsize)\n            x = self.xmean + self.sigma * (self.B @ (self.D * z)).T\n\n            # orthogonal sampling\n            H = np.random.randn(self.popsize, self.popsize)\n            Q, _ = np.linalg.qr(H) # Changed R to _\n\n            # Evaluate population, taking into account the budget constraint.\n            fitness = np.zeros(self.popsize)\n            for k in range(self.popsize):\n                if used_budget < self.budget:\n                    fitness[k] = func(x[k])\n                    used_budget += 1\n                else:\n                    fitness[k] = np.inf\n\n            # Sort by fitness\n            idx = np.argsort(fitness)\n            x = x[idx]\n            fitness = fitness[idx]\n\n            if fitness[0] < self.f_opt:\n                self.f_opt = fitness[0]\n                self.x_opt = x[0]\n\n            # Selection and recombination\n            xmean_old = self.xmean.copy()\n            self.xmean = np.sum(x[:self.mu] * self.weights[:, np.newaxis], axis=0)\n\n            # Cumulation\n            y = (self.xmean - xmean_old) / self.sigma\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.invsqrtC @ y)\n            hsig = (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * (used_budget / self.popsize))) / 1.414 / self.dim + 0.1) < 1\n            self.pc = (1 - self.c_cov_mean) * self.pc + hsig * np.sqrt(self.c_cov_mean * (2 - self.c_cov_mean) * self.mueff) * y\n\n            # Covariance matrix adaptation\n            artmp = (x[:self.mu] - xmean_old) / self.sigma\n            self.C = (1 - self.c_cov_rank_one - self.c_cov_rank_mu) * self.C \\\n                + self.c_cov_rank_one * np.outer(self.pc, self.pc) \\\n                + self.c_cov_rank_mu * np.sum(self.weights[:, np.newaxis, np.newaxis] * artmp[:, :, np.newaxis] * artmp[:, np.newaxis, :], axis=0)\n\n            # Eigen decomposition to update B and D\n            if (used_budget / self.popsize) % 10 == 0:\n                self.C = np.triu(self.C) + np.triu(self.C, 1).T\n                try:\n                    self.D, self.B = np.linalg.eigh(self.C)\n                    self.D = np.sqrt(np.abs(self.D))\n                    self.invsqrtC = self.B @ np.diag(self.D**-1) @ self.B.T\n                except np.linalg.LinAlgError:\n                    self.C = np.eye(self.dim)\n                    self.D = np.ones(self.dim)\n                    self.B = np.eye(self.dim)\n                    self.invsqrtC = np.eye(self.dim)\n\n\n            # Step-size adaptation\n            self.sigma = self.sigma * np.exp((self.c_cov_sigma / self.damps) * (np.linalg.norm(self.ps) / np.sqrt(self.dim) - 1))\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["3a41ca8a-0c45-4298-b1c1-91e760e59f92"], "operator": null, "metadata": {}}
{"id": "a0508c03-5670-4d40-8bf3-190392b94d72", "fitness": 0.4116893860629064, "name": "CMAES", "description": "Covariance Matrix Adaptation Evolution Strategy with a simplified update and adaptive restart mechanism based on fitness stagnation.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov_mean=None, c_cov_sigma=None, restarts=5):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.restarts_counter = 0\n\n        if popsize is None:\n            self.popsize = 4 + int(3 * np.log(self.dim))\n        else:\n            self.popsize = popsize\n\n        self.mu = self.popsize // 2  # Number of parents/selected points\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))  # Eq. 4.1\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) # Variance effective selection mass\n\n        self.cs = cs  # Cumulation factor for step-size\n        self.damps = 1 + 2 * np.max((0, np.sqrt((self.mueff - 1) / (self.dim + 1)) - 1)) + self.cs  # Damping factor\n        if damp is not None:\n            self.damps = damp # allow override\n        \n        self.ccov_mean = (1 / (self.damps * self.dim)) * (1 + (2 * self.mueff - 1) / ((self.mueff - 1 + self.dim)))\n        if c_cov_mean is not None:\n            self.ccov_mean = c_cov_mean\n\n        self.ccov_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        if c_cov_sigma is not None:\n            self.ccov_sigma = c_cov_sigma\n\n        self.mean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n\n        self.min_sigma = 1e-12\n        self.tolxup = 1e7\n        self.fitness_history = []\n\n    def sample_population(self):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        y = z # Simplified: no B and D\n        x = self.mean + self.sigma * y\n        return x, y\n\n    def update_distribution(self, x, y, fitness_values):\n        # Sort population based on fitness\n        idx = np.argsort(fitness_values)\n        x = x[idx]\n        y = y[idx]\n\n        # Selection and recombination\n        y_mean = np.sum(self.weights[:, None] * y[:self.mu], axis=0)\n\n        # Update evolution path\n        self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * y_mean\n        norm_ps = np.linalg.norm(self.ps)\n        self.sigma *= np.exp((self.cs / self.damps) * (norm_ps / np.sqrt(self.dim) - 1))\n\n        # Check for stagnation\n        if self.sigma < self.min_sigma:\n            self.sigma = 0.25 # restart sigma\n\n        # Update evolution path for covariance matrix\n        self.pc = (1 - self.ccov_mean) * self.pc + np.sqrt(self.ccov_mean * (2 - self.ccov_mean) * self.mueff) * y_mean\n        \n        # Update covariance matrix\n        artmp = (1 / self.sigma) * (x[:self.mu] - self.mean)\n        self.C = (1 - self.ccov_mean - self.ccov_sigma) * self.C + self.ccov_mean * np.outer(self.pc, self.pc) + self.ccov_sigma * np.sum(self.weights[:, None, None] * artmp[:, :, None] * artmp[:, None, :], axis=0)\n        \n        # Adapt covariance matrix - simplified\n        self.C = np.triu(self.C) + np.triu(self.C, 1).T\n\n        # Update mean\n        self.mean += self.sigma * y_mean\n        \n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.restarts_counter = 0\n        self.fitness_history = []\n\n        while self.evaluations < self.budget:\n            x, y = self.sample_population()\n            \n            # Clip to bounds\n            lb = func.bounds.lb\n            ub = func.bounds.ub\n            x = np.clip(x, lb, ub)\n            \n            fitness_values = np.zeros(self.popsize)\n            for i in range(self.popsize):\n                if self.evaluations < self.budget:\n                    fitness_values[i] = func(x[i])\n                    self.evaluations += 1\n                    if fitness_values[i] < self.f_opt:\n                        self.f_opt = fitness_values[i]\n                        self.x_opt = x[i]\n                else:\n                    fitness_values[i] = np.Inf\n            \n            self.fitness_history.append(self.f_opt)\n            self.update_distribution(x, y, fitness_values)\n\n            # Break if function evaluation budget is met\n            if self.evaluations >= self.budget:\n                break\n            \n            # Adaptive Restart\n            if len(self.fitness_history) > 10:\n                if np.std(self.fitness_history[-10:]) < 1e-9:\n                    self.restarts_counter += 1\n                    if self.restarts_counter <= self.restarts:\n                        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim) # restart population\n                        self.sigma = 0.5\n                        self.C = np.eye(self.dim)\n                        self.pc = np.zeros(self.dim)\n                        self.ps = np.zeros(self.dim)\n                        self.fitness_history = [] # reset history\n                    else:\n                        break # break if restarts exceeded\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm CMAES scored 0.412 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ee0eb935-2a55-47b4-a395-40a25278903a"], "operator": null, "metadata": {"aucs": [0.12839178057840595, 0.1838730569945436, 0.5742496400336989, 0.5517495887923385, 0.24469991970060478, 0.24766170590050385, 0.23585597768875677, 0.749407815727718, 0.24286898303333448, 0.1748981267618679, 0.9544777167506984, 0.9938352957128705, 0.2231075836331271, 0.23760812238593554, 0.7056925658091051, 0.46513340693454597, 0.3648214316622276, 0.27884941979538225, 0.19612287686472696, 0.4804827064977347]}}
{"id": "f71a704b-0df3-44c1-b03d-ff4f0b56c78b", "fitness": -Infinity, "name": "AdaptiveHybridPSO_DE", "description": "Combines PSO and DE with adaptive switching based on success rates to leverage the strengths of both algorithms.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_DE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, w=0.7, c1=1.5, c2=1.5, cr=0.7, f=0.8, pso_prob=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.w = w\n        self.c1 = c1\n        self.c2 = c2\n        self.cr = cr\n        self.f = f\n        self.pop = None\n        self.fitness = None\n        self.pbest = None\n        self.pbest_fitness = None\n        self.gbest = None\n        self.gbest_fitness = np.inf\n        self.eval_count = 0\n        self.pso_prob = pso_prob\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.pbest = self.pop.copy()\n        self.pbest_fitness = self.fitness.copy()\n        self.gbest = self.pop[np.argmin(self.fitness)].copy()\n        self.gbest_fitness = np.min(self.fitness)\n\n    def pso_update(self, func):\n        new_pop = self.pop.copy()\n        new_fitness = self.fitness.copy()\n        velocity = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            velocity[i] = (self.w * velocity[i]\n                           + self.c1 * np.random.rand(self.dim) * (self.pbest[i] - self.pop[i])\n                           + self.c2 * np.random.rand(self.dim) * (self.gbest - self.pop[i]))\n\n            new_pop[i] = self.pop[i] + velocity[i]\n            new_pop[i] = np.clip(new_pop[i], func.bounds.lb, func.bounds.ub)\n\n            fitness = func(new_pop[i])\n            self.eval_count += 1\n\n            if fitness < new_fitness[i]:\n                new_fitness[i] = fitness\n                if fitness < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = fitness\n                    self.pbest[i] = new_pop[i].copy()\n\n                    if fitness < self.gbest_fitness:\n                        self.gbest_fitness = fitness\n                        self.gbest = new_pop[i].copy()\n        return new_pop, new_fitness\n\n    def de_update(self, func):\n        new_pop = self.pop.copy()\n        new_fitness = self.fitness.copy()\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = self.pop[np.random.choice(idxs, 3, replace=False)]\n            mutant = a + self.f * (b - c)\n            mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n            \n            trial = self.pop[i].copy()\n            for j in range(self.dim):\n                if np.random.rand() <= self.cr or j == np.random.randint(0, self.dim):\n                    trial[j] = mutant[j]\n                    \n            f = func(trial)\n            self.eval_count += 1\n            \n            if f < new_fitness[i]:\n                new_fitness[i] = f\n                new_pop[i] = trial.copy()\n                \n                if f < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = f\n                    self.pbest[i] = new_pop[i].copy()\n                    \n                    if f < self.gbest_fitness:\n                        self.gbest_fitness = f\n                        self.gbest = new_pop[i].copy()\n        return new_pop, new_fitness\n\n    def __call__(self, func):\n        self.initialize_population(func)\n        pso_success = 0\n        de_success = 0\n        pso_count = 0\n        de_count = 0\n        \n        while self.eval_count < self.budget:\n            if np.random.rand() < self.pso_prob:\n                # PSO\n                old_gbest_fitness = self.gbest_fitness\n                new_pop, new_fitness = self.pso_update(func)\n                \n                if self.gbest_fitness < old_gbest_fitness:\n                    pso_success += 1\n                pso_count += 1\n                self.pop = new_pop\n                self.fitness = new_fitness\n            else:\n                # DE\n                old_gbest_fitness = self.gbest_fitness\n                new_pop, new_fitness = self.de_update(func)\n                if self.gbest_fitness < old_gbest_fitness:\n                    de_success += 1\n                de_count += 1\n                self.pop = new_pop\n                self.fitness = new_fitness\n            \n            if pso_count > 10 and de_count > 10:\n                pso_rate = pso_success / pso_count\n                de_rate = de_success / de_count\n                self.pso_prob = pso_rate / (pso_rate + de_rate)\n                pso_success = 0\n                de_success = 0\n                pso_count = 0\n                de_count = 0\n\n        return self.gbest_fitness, self.gbest", "configspace": "", "generation": 1, "feedback": "An exception occurred: float division by zero.", "error": "", "parent_ids": ["a53f71a3-2cf7-46af-81c0-b7fb7a65c3dd"], "operator": null, "metadata": {}}
{"id": "81dbe2f2-e7b3-4f86-955a-3a3b279ab3fa", "fitness": -Infinity, "name": "CMAES", "description": "CMA-ES with improved bound handling by reflecting samples outside the bounds back into the search space, enhancing exploration and exploitation near boundaries and improved covariance update.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov_mean=None, c_cov_sigma=None, restarts=5):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.restarts_counter = 0\n\n        if popsize is None:\n          self.popsize = 4 + int(3 * np.log(self.dim))\n        else:\n          self.popsize = popsize\n        \n        self.mu = self.popsize // 2  # Number of parents/selected points\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))  # Eq. 4.1\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2) # Variance effective selection mass\n\n        self.cs = cs  # Cumulation factor for step-size\n        self.damps = 1 + 2 * np.max((0, np.sqrt((self.mueff - 1) / (self.dim + 1)) - 1)) + self.cs  # Damping factor\n        if damp is not None:\n            self.damps = damp # allow override\n        \n        self.ccov_mean = (1 / (self.damps * self.dim)) * (1 + (2 * self.mueff - 1) / ((self.mueff - 1 + self.dim)))\n        if c_cov_mean is not None:\n            self.ccov_mean = c_cov_mean\n\n        self.ccov_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n        if c_cov_sigma is not None:\n            self.ccov_sigma = c_cov_sigma\n\n        self.mean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.B = np.eye(self.dim)\n        self.D = np.ones(self.dim)\n\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n\n        self.min_sigma = 1e-12\n        self.tolxup = 1e7\n\n    def sample_population(self, func):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        y = self.B.dot(self.D * z.T).T\n        x = self.mean + self.sigma * y\n\n        # Reflect samples at the boundaries\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        for i in range(self.popsize):\n            for j in range(self.dim):\n                if x[i, j] < lb[j]:\n                    x[i, j] = 2 * lb[j] - x[i, j]\n                    y[i, :] = -y[i, :] # Reflect also the y vector\n                elif x[i, j] > ub[j]:\n                    x[i, j] = 2 * ub[j] - x[i, j]\n                    y[i, :] = -y[i, :]  # Reflect also the y vector\n\n        return x, y\n\n    def update_distribution(self, x, y, fitness_values):\n        # Sort population based on fitness\n        idx = np.argsort(fitness_values)\n        x = x[idx]\n        y = y[idx]\n\n        # Selection and recombination\n        y_mean = np.sum(self.weights[:, None] * y[:self.mu], axis=0)\n\n        # Update evolution path\n        self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * (self.B.dot(y_mean * self.D))\n        norm_ps = np.linalg.norm(self.ps)\n        self.sigma *= np.exp((self.cs / self.damps) * (norm_ps / np.sqrt(self.dim) - 1))\n\n        # Check for stagnation\n        if self.sigma < self.min_sigma:\n            self.sigma = 0.25 # restart sigma\n            #print(\"Sigma Restart\")\n\n        # Update evolution path for covariance matrix\n        self.pc = (1 - self.ccov_mean) * self.pc + np.sqrt(self.ccov_mean * (2 - self.ccov_mean) * self.mueff) * y_mean\n        \n        # Update covariance matrix\n        artmp = (1 / self.sigma) * (x[:self.mu] - self.mean)\n        C_temp = np.sum(self.weights[:, None, None] * artmp[:, :, None] * artmp[:, None, :], axis=0)\n        self.C = (1 - self.ccov_mean - self.ccov_sigma) * self.C + self.ccov_mean * np.outer(self.pc, self.pc) + self.ccov_sigma * C_temp\n\n        # Adapt covariance matrix\n        if np.isinf(np.sum(self.C)):\n            self.C = np.eye(self.dim)  # Reset covariance matrix\n\n        self.C = np.triu(self.C) + np.triu(self.C, 1).T\n        try:\n            self.D, self.B = np.linalg.eigh(self.C)\n            self.D = np.sqrt(np.abs(self.D))\n        except np.linalg.LinAlgError:\n            self.C = np.eye(self.dim)\n            self.D = np.ones(self.dim)\n            self.B = np.eye(self.dim)\n\n        # Update mean\n        self.mean += self.sigma * y_mean\n        \n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.restarts_counter = 0\n\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        while self.evaluations < self.budget:\n            x, y = self.sample_population(func)\n            \n            # Clip to bounds (removing this, reflection handles)\n            # x = np.clip(x, lb, ub)\n            \n            fitness_values = np.zeros(self.popsize)\n            for i in range(self.popsize):\n                if self.evaluations < self.budget:\n                  fitness_values[i] = func(x[i])\n                  self.evaluations += 1\n                  if fitness_values[i] < self.f_opt:\n                      self.f_opt = fitness_values[i]\n                      self.x_opt = x[i]\n                else:\n                    fitness_values[i] = np.Inf\n            \n            self.update_distribution(x, y, fitness_values)\n\n            # Break if function evaluation budget is met\n            if self.evaluations >= self.budget:\n                break\n            \n            # Restart if necessary\n            if np.max(self.D) > self.tolxup * np.min(self.D) or np.any(np.isnan(self.mean)) or np.any(np.isinf(self.mean)):\n              self.restarts_counter += 1\n              if self.restarts_counter <= self.restarts:\n                  self.mean = np.random.uniform(lb, ub, size=self.dim) # restart population\n                  self.sigma = 0.5\n                  self.C = np.eye(self.dim)\n                  self.B = np.eye(self.dim)\n                  self.D = np.ones(self.dim)\n                  self.pc = np.zeros(self.dim)\n                  self.ps = np.zeros(self.dim)\n\n              else:\n                  break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: operands could not be broadcast together with shapes (2,) (2,6) .", "error": "", "parent_ids": ["ee0eb935-2a55-47b4-a395-40a25278903a"], "operator": null, "metadata": {}}
{"id": "e194bc0f-e638-430d-bfea-572d9df37bfc", "fitness": 0.30623812217139074, "name": "CMAES", "description": "CMA-ES with simplified covariance matrix adaptation and a more robust stagnation check to avoid numerical issues and broadcasting errors.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov=None, restarts=5):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.restarts_counter = 0\n\n        if popsize is None:\n            self.popsize = 4 + int(3 * np.log(self.dim))\n        else:\n            self.popsize = popsize\n\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        self.cs = cs\n        self.damps = 1 + 2 * np.max((0, np.sqrt((self.mueff - 1) / (self.dim + 1)) - 1)) + self.cs\n        if damp is not None:\n            self.damps = damp\n\n        self.ccov = (1 / self.mueff) * (1 + (self.mueff - 1)/(self.dim + 1))\n        if c_cov is not None:\n            self.ccov = c_cov\n\n        self.mean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n\n        self.ps = np.zeros(self.dim)\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n\n        self.min_sigma = 1e-12\n        self.tolxup = 1e7\n\n    def sample_population(self):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        x = self.mean + self.sigma * np.dot(z, np.linalg.cholesky(self.C).T)\n        return x, z\n\n    def update_distribution(self, x, z, fitness_values):\n        idx = np.argsort(fitness_values)\n        x = x[idx]\n        z = z[idx]\n\n        z_mean = np.sum(self.weights[:, None] * z[:self.mu], axis=0)\n\n        self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * z_mean\n        norm_ps = np.linalg.norm(self.ps)\n        self.sigma *= np.exp((self.cs / self.damps) * (norm_ps / np.sqrt(self.dim) - 1))\n\n        if self.sigma < self.min_sigma:\n            self.sigma = 0.25\n\n        artmp = (x[:self.mu] - self.mean) / self.sigma\n        self.C = (1 - self.ccov) * self.C + self.ccov * np.cov(artmp.T, aweights=self.weights)\n        self.C = np.triu(self.C) + np.triu(self.C, 1).T\n\n        try:\n            np.linalg.cholesky(self.C) # check if positive definite\n        except np.linalg.LinAlgError:\n            self.C = np.eye(self.dim)\n\n        self.mean = np.sum(self.weights[:, None] * x[:self.mu], axis=0)\n        \n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.restarts_counter = 0\n\n        while self.evaluations < self.budget:\n            x, z = self.sample_population()\n\n            lb = func.bounds.lb\n            ub = func.bounds.ub\n            x = np.clip(x, lb, ub)\n\n            fitness_values = np.zeros(self.popsize)\n            for i in range(self.popsize):\n                if self.evaluations < self.budget:\n                    fitness_values[i] = func(x[i])\n                    self.evaluations += 1\n                    if fitness_values[i] < self.f_opt:\n                        self.f_opt = fitness_values[i]\n                        self.x_opt = x[i]\n                else:\n                    fitness_values[i] = np.Inf\n\n            self.update_distribution(x, z, fitness_values)\n\n            if self.evaluations >= self.budget:\n                break\n\n            if np.max(np.diag(self.C)) > self.tolxup * np.min(np.diag(self.C)) or np.any(np.isnan(self.mean)) or np.any(np.isinf(self.mean)):\n                self.restarts_counter += 1\n                if self.restarts_counter <= self.restarts:\n                    self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n                    self.sigma = 0.5\n                    self.C = np.eye(self.dim)\n                    self.ps = np.zeros(self.dim)\n\n                else:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm CMAES scored 0.306 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ee0eb935-2a55-47b4-a395-40a25278903a"], "operator": null, "metadata": {"aucs": [0.0914265680072216, 0.21584728779574514, 0.3403988738566799, 0.3272424753256995, 0.1904519395157468, 0.15859465589942334, 0.23087942702385922, 0.23176033947639207, 0.20818613820537002, 0.18370549451411722, 0.5809384114336347, 0.9968316252174279, 0.30827692306794374, 0.2424151355716917, 0.626652007544082, 0.31114671909978797, 0.23979043423950974, 0.27821666387216015, 0.19176655737112847, 0.17023476639019441]}}
{"id": "d6335096-5d0b-4396-9f4c-65c2f50b9e3e", "fitness": 0.6542817862397058, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR adaptation based on population diversity and optional archive usage.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_rate=0.2):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_rate = archive_rate\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        archive_size = int(self.pop_size * self.archive_rate)\n        archive = []\n\n        while self.budget > 0:\n            # Calculate diversity (standard deviation of the population)\n            diversity = np.std(population)\n            \n            # Adapt CR based on diversity\n            CR = 0.1 + 0.8 * (1 - np.exp(-diversity)) # CR increases with diversity\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    # Update archive\n                    if len(archive) < archive_size:\n                        archive.append(population[i].copy())  #append a copy to avoid future mutations altering the archive\n                    elif archive_size > 0:\n                        idx = np.random.randint(0, archive_size)\n                        archive[idx] = population[i].copy()\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.654 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["02cfeca4-0e65-4665-bf8c-eb5969c4abb6"], "operator": null, "metadata": {"aucs": [0.2761101529773925, 0.4376057588144514, 0.5966457500271516, 0.8744161361653932, 0.7369957576974727, 0.7787724718398351, 0.5854532859779762, 0.5670064299405082, 0.6996954476203587, 0.6518412871478609, 0.8334670171107965, 0.9922699516230793, 0.5037654129057725, 0.7067813739125657, 0.8918817149641365, 0.7647942740015975, 0.5686100011425623, 0.8333057457915356, 0.26091014782477195, 0.525307607308896]}}
{"id": "b2c18f92-9f5e-4463-849c-b1c033d0a00c", "fitness": 0.626494936474832, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with improved parameter adaptation and mutation strategy focusing on efficiency and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Adaptive F and CR\n                F = np.random.normal(self.F, 0.1)\n                F = np.clip(F, 0.1, 0.9)\n                CR = np.random.normal(self.CR, 0.1)\n                CR = np.clip(CR, 0.1, 0.9)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                                    \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.626 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["02cfeca4-0e65-4665-bf8c-eb5969c4abb6"], "operator": null, "metadata": {"aucs": [0.20901346518470176, 0.47289337467391035, 0.622787979161513, 0.8435054458793426, 0.7059853381473635, 0.7677705925494687, 0.5266941918911574, 0.5819973044280506, 0.6987387023294411, 0.64204060788341, 0.7835692317161796, 0.9981323625767325, 0.3552490265577679, 0.6363105023133842, 0.8832996332438481, 0.740731630479748, 0.4962871731810433, 0.8099322679778882, 0.23737031744713433, 0.5175895818745552]}}
{"id": "7e621528-222a-45de-87c8-6f5bac824a2a", "fitness": 0.3693973350013808, "name": "HybridPSO_DE", "description": "Combines PSO and DE with dynamic adaptation based on evaluation budget and includes a local search component to refine the solution.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, w=0.7, c1=1.5, c2=1.5, cr=0.7, f=0.8, ls_prob=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.w = w\n        self.c1 = c1\n        self.c2 = c2\n        self.cr = cr\n        self.f = f\n        self.ls_prob = ls_prob # Probability of local search\n        self.pop = None\n        self.fitness = None\n        self.pbest = None\n        self.pbest_fitness = None\n        self.gbest = None\n        self.gbest_fitness = np.inf\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.pbest = self.pop.copy()\n        self.pbest_fitness = self.fitness.copy()\n        self.gbest = self.pop[np.argmin(self.fitness)].copy()\n        self.gbest_fitness = np.min(self.fitness)\n\n    def pso_update(self, func):\n        velocity = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            velocity[i] = (self.w * velocity[i]\n                           + self.c1 * np.random.rand(self.dim) * (self.pbest[i] - self.pop[i])\n                           + self.c2 * np.random.rand(self.dim) * (self.gbest - self.pop[i]))\n\n            self.pop[i] = self.pop[i] + velocity[i]\n            self.pop[i] = np.clip(self.pop[i], func.bounds.lb, func.bounds.ub)\n\n            fitness = func(self.pop[i])\n            self.eval_count += 1\n\n            if fitness < self.pbest_fitness[i]:\n                self.pbest_fitness[i] = fitness\n                self.pbest[i] = self.pop[i].copy()\n\n                if fitness < self.gbest_fitness:\n                    self.gbest_fitness = fitness\n                    self.gbest = self.pop[i].copy()\n    \n    def de_update(self, func):\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = self.pop[np.random.choice(idxs, 3, replace=False)]\n            mutant = a + self.f * (b - c)\n            mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n            \n            trial = self.pop[i].copy()\n            for j in range(self.dim):\n                if np.random.rand() <= self.cr or j == np.random.randint(0, self.dim):\n                    trial[j] = mutant[j]\n                    \n            f = func(trial)\n            self.eval_count += 1\n            \n            if f < self.fitness[i]:\n                self.fitness[i] = f\n                self.pop[i] = trial.copy()\n                \n                if f < self.pbest_fitness[i]:\n                    self.pbest_fitness[i] = f\n                    self.pbest[i] = self.pop[i].copy()\n                    \n                    if f < self.gbest_fitness:\n                        self.gbest_fitness = f\n                        self.gbest = self.pop[i].copy()\n                        \n    def local_search(self, func, x, radius=0.1):\n        # Simple local search around x\n        x_new = x + np.random.uniform(-radius, radius, size=self.dim)\n        x_new = np.clip(x_new, func.bounds.lb, func.bounds.ub)\n        f_new = func(x_new)\n        self.eval_count += 1\n        if f_new < self.gbest_fitness:\n            self.gbest_fitness = f_new\n            self.gbest = x_new.copy()\n        return x_new, f_new\n\n    def __call__(self, func):\n        self.initialize_population(func)\n        phase = 0\n        while self.eval_count < self.budget:\n            # Dynamically switch between PSO and DE based on budget and stagnation\n            if phase == 0:\n                self.pso_update(func)\n                if self.eval_count > self.budget * 0.3:\n                    phase = 1\n            elif phase == 1:\n                self.de_update(func)\n                if self.eval_count > self.budget * 0.6:\n                    phase = 2\n            else:\n                # Local search around the best solution\n                if np.random.rand() < self.ls_prob:\n                     self.local_search(func, self.gbest)\n\n        return self.gbest_fitness, self.gbest", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSO_DE scored 0.369 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a53f71a3-2cf7-46af-81c0-b7fb7a65c3dd"], "operator": null, "metadata": {"aucs": [0.1318290037867812, 0.21411948977073236, 0.3900736976506166, 0.21531913179542483, 0.27317309625786534, 0.4537077617564276, 0.29481994134912715, 0.28114017592401075, 0.17335577119639678, 0.1736300553260498, 0.6106183687162423, 0.9983753208899206, 0.2821908089996348, 0.41466539712232997, 0.7681855752272584, 0.32017164815193855, 0.25443893062986833, 0.44688704392006606, 0.2214611961906019, 0.4697842853663228]}}
{"id": "88f2d9a3-f67f-41b4-8e57-5a6ea86840c6", "fitness": 0.615073947364196, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a dynamically adjusted crossover rate and a shrinking population.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Shrink population size over time\n            new_pop_size = max(10, int(self.pop_size * (self.budget / 10000)))\n            if new_pop_size < self.pop_size:\n                indices = np.argsort(fitness)[:new_pop_size]\n                population = population[indices]\n                fitness = fitness[indices]\n                self.pop_size = new_pop_size\n            \n            # Dynamically adapt crossover rate\n            self.CR = 0.2 + 0.7 * (self.budget / 10000)\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.615 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["02cfeca4-0e65-4665-bf8c-eb5969c4abb6"], "operator": null, "metadata": {"aucs": [0.3257657894314252, 0.38556945190531555, 0.48701315788052046, 0.9325247253974325, 0.82969236613754, 0.6290095152529257, 0.6924912522162381, 0.4139657651042409, 0.7733987238680589, 0.5256445041697135, 0.9225429443909821, 0.9903132546931264, 0.3295060793294441, 0.7248477659358348, 0.7024143532837377, 0.47957820526120165, 0.6389965975255885, 0.7363544716501624, 0.274204769384116, 0.5076452544663131]}}
{"id": "e83f8fc5-a110-44fe-b94c-6fc89caa1715", "fitness": 0.30603953141310974, "name": "CMAES", "description": "Simplified CMA-ES with dynamic population size based on budget, early stopping based on stagnation, and clipping of distribution parameters.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, restarts=3):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.restarts_counter = 0\n\n        self.popsize = min(budget // 10, 4 + int(3 * np.log(self.dim)))\n        self.mu = self.popsize // 2\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights /= np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        self.cs = 0.3\n        self.damps = 1 + 2 * np.max((0, np.sqrt((self.mueff - 1) / (self.dim + 1)) - 1)) + self.cs\n        self.ccov_mean = (1 / (self.damps * self.dim)) * (1 + (2 * self.mueff - 1) / ((self.mueff - 1 + self.dim)))\n        self.ccov_sigma = (self.mueff + 2) / (self.dim + self.mueff + 5)\n\n        self.mean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.pc = np.zeros(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.fitness_history = []\n        self.min_sigma = 1e-12\n\n    def sample_population(self):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        y = z\n        x = self.mean + self.sigma * y\n        return x, y\n\n    def update_distribution(self, x, y, fitness_values):\n        idx = np.argsort(fitness_values)\n        x = x[idx]\n        y = y[idx]\n\n        y_mean = np.sum(self.weights[:, None] * y[:self.mu], axis=0)\n        self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * y_mean\n        norm_ps = np.linalg.norm(self.ps)\n        self.sigma *= np.exp((self.cs / self.damps) * (norm_ps / np.sqrt(self.dim) - 1))\n        self.sigma = max(self.sigma, self.min_sigma) # Clip sigma\n\n        self.pc = (1 - self.ccov_mean) * self.pc + np.sqrt(self.ccov_mean * (2 - self.ccov_mean) * self.mueff) * y_mean\n        artmp = (1 / self.sigma) * (x[:self.mu] - self.mean)\n        self.C = (1 - self.ccov_mean - self.ccov_sigma) * self.C + self.ccov_mean * np.outer(self.pc, self.pc) + self.ccov_sigma * np.sum(self.weights[:, None, None] * artmp[:, :, None] * artmp[:, None, :], axis=0)\n        self.C = np.triu(self.C) + np.triu(self.C, 1).T\n\n        # Clip covariance matrix (avoid numerical issues)\n        self.C = np.clip(self.C, -1e3, 1e3)\n\n        self.mean += self.sigma * y_mean\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.restarts_counter = 0\n        self.fitness_history = []\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        stagnation_threshold = 1e-9\n        stagnation_length = min(5 + self.dim // 2, 20)\n        while self.evaluations < self.budget:\n            x, y = self.sample_population()\n            x = np.clip(x, lb, ub)\n\n            fitness_values = np.zeros(self.popsize)\n            for i in range(self.popsize):\n                if self.evaluations < self.budget:\n                    fitness_values[i] = func(x[i])\n                    self.evaluations += 1\n                    if fitness_values[i] < self.f_opt:\n                        self.f_opt = fitness_values[i]\n                        self.x_opt = x[i]\n                else:\n                    fitness_values[i] = np.Inf\n            \n            self.fitness_history.append(self.f_opt)\n            self.update_distribution(x, y, fitness_values)\n\n            if self.evaluations >= self.budget:\n                break\n\n            if len(self.fitness_history) > stagnation_length:\n                if np.std(self.fitness_history[-stagnation_length:]) < stagnation_threshold:\n                    self.restarts_counter += 1\n                    if self.restarts_counter <= self.restarts:\n                        self.mean = np.random.uniform(lb, ub, size=self.dim)\n                        self.sigma = 0.5\n                        self.C = np.eye(self.dim)\n                        self.pc = np.zeros(self.dim)\n                        self.ps = np.zeros(self.dim)\n                        self.fitness_history = []\n                        continue\n                    else:\n                        break\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm CMAES scored 0.306 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a0508c03-5670-4d40-8bf3-190392b94d72"], "operator": null, "metadata": {"aucs": [0.14618331514850702, 0.17912116705211734, 0.31365856596189234, 0.16426719979132354, 0.21941428207911828, 0.2973672960798175, 0.26545279030517854, 0.2401799841773301, 0.24554395241351934, 0.16582389961978172, 0.3079149921316019, 0.9935514517573976, 0.2342852632667306, 0.23916700992336537, 0.5728596850129695, 0.27626646611765826, 0.38572919509364534, 0.26583289772906527, 0.14607720048501838, 0.4620940141161566]}}
{"id": "6ccfc0e8-aad9-4819-8699-357c8ebdec87", "fitness": 0.7052730613403076, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified dynamic crossover rate and a constant population size for better efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:            \n            # Dynamically adapt crossover rate - simplified\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.705 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["88f2d9a3-f67f-41b4-8e57-5a6ea86840c6"], "operator": null, "metadata": {"aucs": [0.25474630089993666, 0.5442500869680476, 0.7199688981509317, 0.8937203992447262, 0.7767119688964208, 0.8272905308607807, 0.6741047842496422, 0.6441446598366904, 0.7776983807689931, 0.7613140167062679, 0.8458086614977709, 0.9990009034837539, 0.4782554477783001, 0.7449070976202321, 0.9167795733256647, 0.8248567665420105, 0.6305050326685584, 0.8815454453787014, 0.38155180117273635, 0.5283004707559873]}}
{"id": "d470037b-8d24-43cc-b7af-d2d7ddd5e9cc", "fitness": 0.6813113104034898, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a focused mutation strategy using the best individual.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation: use current best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x1, x2 = population[idxs]\n                mutant = population[best_idx] + self.F * (x1 - x2)  # Use best individual\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        best_idx = i # Update best index\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.681 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b2c18f92-9f5e-4463-849c-b1c033d0a00c"], "operator": null, "metadata": {"aucs": [0.21524041838997388, 0.24555819079056074, 0.8819968850776774, 0.9495626873268423, 0.898739858980089, 0.9213864551394357, 0.3714298447997393, 0.8619664846669112, 0.8976577341001797, 0.4654507620414944, 0.9297475665026185, 0.9942062993243942, 0.6450884470695679, 0.376435283684288, 0.9582455286318226, 0.9068170016131368, 0.45181050341508633, 0.9231934828965743, 0.2116396944012927, 0.5200530792181115]}}
{"id": "55d42d55-7713-42b8-a688-836878e692fb", "fitness": 0.4691906104636807, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and focused mutation strategy, enhancing exploration using a larger population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=100):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                                    \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.469 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b2c18f92-9f5e-4463-849c-b1c033d0a00c"], "operator": null, "metadata": {"aucs": [0.1722277887798429, 0.2760977759656136, 0.44801102910224067, 0.6993682462405786, 0.4308089677783402, 0.5341007718312916, 0.36749793684457277, 0.41835955662983504, 0.4417577770936856, 0.3076437924129234, 0.575017013218838, 0.9988308298656483, 0.296751879207115, 0.41309736211297166, 0.7917976977285432, 0.5316258000031573, 0.3687131256608953, 0.6120085581980457, 0.20785608517172727, 0.4922402154277483]}}
{"id": "bb1b4208-50ae-481f-a2ad-3e96aa1dedd4", "fitness": 0.5167034566197688, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, focusing on efficiency and exploration by adjusting mutation strength based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.3\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    # Adapt F based on fitness improvement\n                    if fitness[i] - f > 1e-6:  #Significant improvement\n                        self.F = max(0.1, self.F * 0.9)  # Reduce F\n                    else:\n                        self.F = min(0.9, self.F * 1.1)  # Increase F\n\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.517 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6335096-5d0b-4396-9f4c-65c2f50b9e3e"], "operator": null, "metadata": {"aucs": [0.18208619524547254, 0.2490141955432984, 0.38817150927558464, 0.7689950244502818, 0.5606627418230488, 0.7590841393273386, 0.44059676135354664, 0.3763022373587408, 0.40959547135896257, 0.27537034257002546, 0.5357540141089064, 0.9976096018442259, 0.25076550733765857, 0.5234726658373257, 0.7552708666807755, 0.7511715346031761, 0.5426069976017938, 0.7214076000579608, 0.33270989704725107, 0.5134218289700005]}}
{"id": "4205fee9-a28d-4f3d-93dd-9f90b6d65c32", "fitness": 0.4567947543179175, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter tuning and a focus on local search by adjusting the mutation strength based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    # Update F based on fitness improvement\n                    if fitness[i] - f > 1e-6:\n                        self.F = np.clip(self.F * 0.9, 0.1, 0.9) # Reduce F if improvement\n                    else:\n                        self.F = np.clip(self.F * 1.1, 0.1, 0.9) # Increase F if no improvement\n                    fitness[i] = f\n                    population[i] = trial\n                                    \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.457 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b2c18f92-9f5e-4463-849c-b1c033d0a00c"], "operator": null, "metadata": {"aucs": [0.26515400976417236, 0.2645078462552748, 0.37430447045302506, 0.4543586465795998, 0.4259294535472916, 0.37643038225449243, 0.42601079333919856, 0.323391473861376, 0.4304843823136172, 0.4501525866717443, 0.43526675247638613, 0.9989378640999113, 0.26831474700711444, 0.42062109303503725, 0.8867649594087036, 0.4419959985853188, 0.3263281077106487, 0.8335508118232731, 0.23834311147589493, 0.49504759569626955]}}
{"id": "ee7c4e72-59b9-4f4f-8372-006550b585da", "fitness": 0.5814328186745317, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a streamlined mutation strategy and dynamic crossover rate adaptation based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_fitness_history = []\n\n        while self.budget > 0:\n            # Adapt CR based on fitness improvement in the last few iterations\n            if len(best_fitness_history) > 5:\n                improvement = best_fitness_history[-5] - fitness.min()\n                CR = min(0.9, max(0.1, 0.4 + improvement)) # CR adapts to recent improvements\n            else:\n                CR = 0.4\n\n            best_fitness_history.append(fitness.min())\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.581 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6335096-5d0b-4396-9f4c-65c2f50b9e3e"], "operator": null, "metadata": {"aucs": [0.2072453494233707, 0.26011006922640645, 0.537392944472453, 0.8344876423276057, 0.6284970107617924, 0.7693722967842864, 0.42225103601772696, 0.5464098471033889, 0.6889290200902354, 0.5114992787854871, 0.7618505761758507, 0.9986749022223935, 0.29410324387459497, 0.597873411502613, 0.8171845079573854, 0.7766194880008375, 0.42128326740888655, 0.8041739654225897, 0.24370373040869875, 0.5069947855240282]}}
{"id": "5e361484-8d3d-4a27-938b-821721a170a6", "fitness": 0.49877944856703016, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive mutation factor and crossover rate based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    # Adapt parameters if improvement found\n                    self.F = np.random.uniform(0.5, 1.0)  # Adjust F\n                    self.CR = np.random.uniform(0.3, 0.9)  # Adjust CR\n                    \n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.499 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6335096-5d0b-4396-9f4c-65c2f50b9e3e"], "operator": null, "metadata": {"aucs": [0.17947953820399687, 0.2732616559970086, 0.4302460784480271, 0.7174100781889978, 0.48632723875420125, 0.5892806221546698, 0.3457544258474722, 0.4254959543015734, 0.5155662585753296, 0.42580555642627516, 0.6386163789941, 0.9824411748063564, 0.27773254471590547, 0.4678516481539233, 0.8287138272837145, 0.6182611380077883, 0.38363757546295596, 0.6712024501453111, 0.2164061549509605, 0.5020986719220359]}}
{"id": "86f5d6d0-860f-4045-b0dc-d32498d9d2aa", "fitness": 0.7787966620639454, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and a focus on exploitation through a smaller population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Adaptive F and CR (simplified)\n                F = np.clip(np.random.normal(self.F, 0.1), 0.1, 0.9)\n                CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 0.9)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                                    \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.779 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b2c18f92-9f5e-4463-849c-b1c033d0a00c"], "operator": null, "metadata": {"aucs": [0.3104529767431371, 0.7690306756348712, 0.8115038467301405, 0.9186370836423594, 0.8155190201754822, 0.8636436798505804, 0.769085809952337, 0.7769941868283572, 0.841594636434187, 0.807473309015293, 0.8795420984077968, 0.9970603549935758, 0.4131437731894274, 0.817145738476863, 0.9322643000216935, 0.8788322277171506, 0.7429326825568674, 0.912015701962187, 0.6063333343147093, 0.7127278046318912]}}
{"id": "9d58bbe8-b116-49bf-8619-7eb3159a5933", "fitness": 0.5833567273420615, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with reduced parameter tuning, focusing on population diversity-based crossover adaptation and a shrinking population.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Shrink population size over time\n            new_pop_size = max(10, int(self.pop_size * (self.budget / 10000)))\n            if new_pop_size < self.pop_size:\n                indices = np.argsort(fitness)[:new_pop_size]\n                population = population[indices]\n                fitness = fitness[indices]\n                self.pop_size = new_pop_size\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover - adapt CR based on fitness variance\n                CR = 0.1 + 0.8 * np.var(fitness) / (np.max(fitness) - np.min(fitness) + 1e-8)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.583 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["88f2d9a3-f67f-41b4-8e57-5a6ea86840c6"], "operator": null, "metadata": {"aucs": [0.18609122097746356, 0.3483041922664324, 0.6502309460410941, 0.8408887009301308, 0.4029691806022192, 0.865416113851542, 0.3463120126071738, 0.48663809793441826, 0.724878037620204, 0.5634577373447913, 0.779648202186272, 0.9966481058099482, 0.27641540681026067, 0.5351389962983918, 0.8083092676131647, 0.8824900219070279, 0.41433536303346785, 0.8363567904273631, 0.21111333381649733, 0.511492818763366]}}
{"id": "5d03be1d-5069-428c-bcf3-a3fb55234163", "fitness": 0.347246445284262, "name": "CMAES", "description": "Simplified CMA-ES with rank-one update, active covariance update, and dynamic population size.", "code": "import numpy as np\n\nclass CMAES:\n    def __init__(self, budget=10000, dim=10, popsize=None, cs=0.3, damp=None, c_cov=None, restarts=3):\n        self.budget = budget\n        self.dim = dim\n        self.restarts = restarts\n        self.restarts_counter = 0\n\n        if popsize is None:\n            self.popsize = 4 + int(3 * np.log(self.dim))\n        else:\n            self.popsize = popsize\n\n        self.mu = self.popsize // 2  # Number of parents/selected points\n        self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n        self.weights = self.weights / np.sum(self.weights)\n        self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n\n        self.cs = cs  # Cumulation factor for step-size\n        self.damps = 1 + 2 * np.max((0, np.sqrt((self.mueff - 1) / (self.dim + 1)) - 1)) + self.cs\n        if damp is not None:\n            self.damps = damp\n\n        self.ccov = (1 / (self.damps * self.dim)) * (1 + (2 * self.mueff - 1) / ((self.mueff - 1 + self.dim))) # Simplified covariance update\n        if c_cov is not None:\n            self.ccov = c_cov\n        \n        self.mean = np.zeros(self.dim)\n        self.sigma = 0.5\n        self.C = np.eye(self.dim)\n        self.ps = np.zeros(self.dim)\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.fitness_history = []\n        self.dynamic_popsize = True # enable dynamic popsize\n\n    def sample_population(self):\n        z = np.random.normal(0, 1, size=(self.popsize, self.dim))\n        y = z\n        x = self.mean + self.sigma * y\n        return x, y\n\n    def update_distribution(self, x, y, fitness_values):\n        idx = np.argsort(fitness_values)\n        x = x[idx]\n        y = y[idx]\n\n        y_mean = np.sum(self.weights[:, None] * y[:self.mu], axis=0)\n\n        self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mueff) * y_mean\n        self.sigma *= np.exp((self.cs / self.damps) * (np.linalg.norm(self.ps) / np.sqrt(self.dim) - 1))\n        \n        # Rank-one update with active covariance update\n        artmp = (1 / self.sigma) * (x[:self.mu] - self.mean)\n        delta = (1 - self.ccov)\n        self.C = delta * self.C + self.ccov * np.outer(self.ps, self.ps) # simplified update\n        \n        self.mean += self.sigma * y_mean\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evaluations = 0\n        self.restarts_counter = 0\n        self.fitness_history = []\n\n        while self.evaluations < self.budget:\n            x, y = self.sample_population()\n            lb = func.bounds.lb\n            ub = func.bounds.ub\n            x = np.clip(x, lb, ub)\n\n            fitness_values = np.zeros(self.popsize)\n            for i in range(self.popsize):\n                if self.evaluations < self.budget:\n                    fitness_values[i] = func(x[i])\n                    self.evaluations += 1\n                    if fitness_values[i] < self.f_opt:\n                        self.f_opt = fitness_values[i]\n                        self.x_opt = x[i]\n                else:\n                    fitness_values[i] = np.Inf\n\n            self.fitness_history.append(self.f_opt)\n            self.update_distribution(x, y, fitness_values)\n\n            if self.evaluations >= self.budget:\n                break\n\n            # Adaptive Restart\n            if len(self.fitness_history) > 10:\n                if np.std(self.fitness_history[-10:]) < 1e-9:\n                    self.restarts_counter += 1\n                    if self.restarts_counter <= self.restarts:\n                        self.mean = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n                        self.sigma = 0.5\n                        self.C = np.eye(self.dim)\n                        self.ps = np.zeros(self.dim)\n                        self.fitness_history = []\n                        if self.dynamic_popsize:\n                            self.popsize = min(self.popsize + 2, 2*self.dim) #dynamic popsize\n                            self.mu = self.popsize // 2\n                            self.weights = np.log(self.mu + 0.5) - np.log(np.arange(1, self.mu + 1))\n                            self.weights = self.weights / np.sum(self.weights)\n                            self.mueff = np.sum(self.weights)**2 / np.sum(self.weights**2)\n                            self.ccov = (1 / (self.damps * self.dim)) * (1 + (2 * self.mueff - 1) / ((self.mueff - 1 + self.dim))) # Simplified covariance update\n                    else:\n                        break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm CMAES scored 0.347 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a0508c03-5670-4d40-8bf3-190392b94d72"], "operator": null, "metadata": {"aucs": [0.18770498626316057, 0.388804969974209, 0.5894102695543935, 0.23663206434838702, 0.2351890511833662, 0.2491966273686278, 0.2805644853402175, 0.23121339785981132, 0.33896314086670043, 0.22962702050201, 0.274158143791829, 0.9940447478134831, 0.259139845381705, 0.23047389448162914, 0.6371957912365274, 0.3566532090367518, 0.29091652653344335, 0.2423513421708926, 0.22080058323779017, 0.4718888087403057]}}
{"id": "d6b9fd27-b840-46b7-b9d9-381cc4450baa", "fitness": 0.6931802938788174, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified dynamic CR adjustment and a smaller, more focused population size reduction based on performance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000) # Reduced range\n\n            # Adaptive population shrinking based on fitness\n            if self.budget < 0.5 * 10000 and self.pop_size > 10:\n                median_fitness = np.median(fitness)\n                bad_indices = np.where(fitness > median_fitness)[0]\n                num_to_remove = min(len(bad_indices), self.pop_size // 4) # Remove at most 25%\n                if num_to_remove > 0:\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.693 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["88f2d9a3-f67f-41b4-8e57-5a6ea86840c6"], "operator": null, "metadata": {"aucs": [0.2259371044649603, 0.6235738973235667, 0.6893470996391049, 0.8951765444873442, 0.7889099995737388, 0.83896853237149, 0.7165464005053126, 0.6419506030214743, 0.8001770867831409, 0.762656660235714, 0.8407681309071167, 0.9947676936868133, 0.30949684724033166, 0.7696317475958554, 0.8914886661566519, 0.8592309593705199, 0.5631378221994683, 0.8753616289403192, 0.2569936934766729, 0.5194847595967522]}}
{"id": "9e6da449-532f-46e1-9844-48e8977fa49a", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and probabilistic replacement for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x)] for x in population)\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Adaptive F and CR (simplified)\n                self.F = np.clip(np.random.normal(self.F, 0.1), 0.1, 0.9)\n                self.CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 0.9)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = population[i] + self.F * (x1 - x2 + x3 - population[i])\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n                \n                # Probabilistic replacement\n                if f < fitness[i] or np.random.rand() < 0.05:\n                    fitness[i] = f\n                    population[i] = trial\n                                    \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "An exception occurred: too many indices for array: array is 0-dimensional, but 1 were indexed.", "error": "", "parent_ids": ["86f5d6d0-860f-4045-b0dc-d32498d9d2aa"], "operator": null, "metadata": {}}
{"id": "c1534e15-8090-486e-b57b-9d89e141d2d7", "fitness": 0.7208369869915456, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, a smaller, focused population, and dynamic population shrinking based on fitness percentiles.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Adaptive population shrinking based on fitness percentile\n            if self.budget < 0.5 * 10000 and self.pop_size > 10:\n                percentile_25 = np.percentile(fitness, 25)\n                bad_indices = np.where(fitness > percentile_25)[0]\n                num_to_remove = min(len(bad_indices), self.pop_size // 4)\n                if num_to_remove > 0:\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.721 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6b9fd27-b840-46b7-b9d9-381cc4450baa"], "operator": null, "metadata": {"aucs": [0.22718898177490965, 0.5978479051579697, 0.7873743764793201, 0.8924342375150334, 0.8415827348490985, 0.8475290385425738, 0.7344497308706961, 0.7452084435592992, 0.8248487661466611, 0.7798014857536062, 0.8626294234373647, 0.9997380078389788, 0.3148917465660792, 0.8240217797457035, 0.9201174812159268, 0.8693345564913856, 0.700529914156667, 0.8914930176623849, 0.2352543318198307, 0.520463780247423]}}
{"id": "3a633cfd-09e1-41e5-9cf2-7b29eb7e1120", "fitness": 0.6730543250920509, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR and population size based on remaining budget and fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Adaptive population shrinking based on fitness variance and budget\n            if self.budget < 0.5 * 10000 and self.pop_size > 10:\n                fitness_variance = np.var(fitness)\n                if fitness_variance < 0.1: #if variance is low, then shrink population\n                    num_to_remove = min(self.pop_size // 4, self.pop_size - 5)  # Ensure pop_size remains at least 5\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.673 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6b9fd27-b840-46b7-b9d9-381cc4450baa"], "operator": null, "metadata": {"aucs": [0.21377636000872757, 0.35221195497727453, 0.6856310468971364, 0.8847858756239662, 0.8190496213891734, 0.8485650928656625, 0.6803521970783337, 0.6203195833418669, 0.804241067117496, 0.6848890472106481, 0.8590317904622966, 0.9992598256903059, 0.32052505224103833, 0.7195190240113069, 0.8914529786008316, 0.8441632678441076, 0.593403900845096, 0.8837284773207593, 0.2268295373225162, 0.5293508009924748]}}
{"id": "0f2ae23e-ebf0-4401-88c3-f676acde78be", "fitness": 0.6761924039187062, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic crossover rate and aggressive population size reduction based on budget and fitness.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Aggressive population shrinking based on budget and fitness\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:  # More aggressive shrinking\n                median_fitness = np.median(fitness)\n                bad_indices = np.where(fitness > median_fitness)[0]\n                num_to_remove = min(len(bad_indices), self.pop_size // 2)  # Remove up to 50%\n                if num_to_remove > 0:\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n                    \n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.676 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d6b9fd27-b840-46b7-b9d9-381cc4450baa"], "operator": null, "metadata": {"aucs": [0.25845765408251586, 0.34789566187298815, 0.6454177299691599, 0.8910770715385403, 0.7946421830925205, 0.8463143468439083, 0.7061234947949437, 0.6482896247330149, 0.7900434772808931, 0.7181352384616886, 0.854984930226768, 0.995479436667009, 0.2981003671349287, 0.7783272328954332, 0.9127340650139331, 0.8589614847508265, 0.5514777521501706, 0.8700988175545303, 0.23752927664116297, 0.519758232669185]}}
{"id": "372487f0-4db6-43fa-bdf2-dd369124de94", "fitness": 0.43369307519368805, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic F and CR based on population diversity and a focus on exploration/exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx]\n\n        while self.budget > 0:\n            # Adaptive F and CR\n            diversity = np.std(fitness)\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9) # exploration\n            self.CR = np.clip(np.random.normal(0.7, 0.1), 0.1, 0.9)  # exploitation\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = population[i] + self.F * (x1 - x2)  # Simplified mutation\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        best_idx = i\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.434 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d470037b-8d24-43cc-b7af-d2d7ddd5e9cc"], "operator": null, "metadata": {"aucs": [0.15094885785552947, 0.2716230440297617, 0.42119074293242464, 0.5534728428234188, 0.3228968100886357, 0.5012190319883243, 0.3059322076392189, 0.36072275124103603, 0.367119686564357, 0.20517958494872324, 0.6729361581692529, 0.9995777262044377, 0.3368105040290881, 0.32626059090884274, 0.8059215849874546, 0.47743632961611604, 0.35372590783993096, 0.5597739431543736, 0.18222214277404414, 0.49889105607878936]}}
{"id": "46404442-e25f-446d-9c82-6dd8e7cefd88", "fitness": 0.2812970034923655, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation and parameter adaptation based on population best, focusing on exploration near the best solution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx]\n\n        while self.budget > 0:\n            # Adaptive F and CR based on best individual\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n            self.CR = np.clip(np.random.normal(0.7, 0.1), 0.1, 0.9)\n\n            for i in range(self.pop_size):\n                # Mutation based on best individual\n                mutant = population[i] + self.F * (self.x_opt - population[i])  # Simplified mutation using best\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        best_idx = i\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.281 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["372487f0-4db6-43fa-bdf2-dd369124de94"], "operator": null, "metadata": {"aucs": [0.1617332276885156, 0.1998792062037743, 0.3172865103398814, 0.16474190819363088, 0.2141340733645064, 0.22491653825652025, 0.24285891427899597, 0.21522604616443874, 0.2905542489130568, 0.20752132955155556, 0.18596156601350278, 0.9998254285951785, 0.2652869251155605, 0.2484113040720901, 0.1933648888141546, 0.32714302739056833, 0.28354329053603244, 0.20182155467009955, 0.20388023045136028, 0.47784985123388735]}}
{"id": "afa85087-6bb9-4ab4-9eb4-6cbb3b56154f", "fitness": 0.7569465736367929, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and population size reduction, focusing on computational efficiency and performance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            # Population shrinking based on budget\n            if self.budget < 0.3 * 10000 and self.pop_size > 5:\n                self.pop_size = max(5, int(self.pop_size * 0.7))\n                indices_to_keep = np.argsort(fitness)[:self.pop_size]\n                population = population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n                    \n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.757 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0f2ae23e-ebf0-4401-88c3-f676acde78be"], "operator": null, "metadata": {"aucs": [0.31271219331051847, 0.7545605000339022, 0.7636913185132141, 0.9353455200003327, 0.850367910965004, 0.8745582209430842, 0.7218337291338393, 0.7737178551939162, 0.8424167434536103, 0.7990289998885345, 0.9111549309829351, 0.9990619323569169, 0.6170118505852347, 0.8364834641954781, 0.9179383795649143, 0.8631770282070561, 0.6885237691301154, 0.9092931203762755, 0.23590592945048616, 0.5321480764504876]}}
{"id": "b3c38410-902a-4735-82ee-d9570fce2f7f", "fitness": 0.6447449133284859, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR and reduced population adjustments based on budget.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate based on remaining budget\n            self.CR = 0.1 + 0.5 * (self.budget / 10000)\n\n            # Adaptive population shrinking based on remaining budget\n            if self.budget < 0.25 * 10000 and self.pop_size > 10:\n                num_to_remove = max(1, self.pop_size // 5)  # Remove at least one\n                indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                population = population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n                self.pop_size = len(population)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.645 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3a633cfd-09e1-41e5-9cf2-7b29eb7e1120"], "operator": null, "metadata": {"aucs": [0.21500036948933143, 0.30907407518819385, 0.6540836592402843, 0.8903365466884493, 0.7892253557622135, 0.8184825700878295, 0.6624900738627166, 0.5950660281702281, 0.781163148183692, 0.6096591906347162, 0.8458352998325891, 0.9959087489063447, 0.30428435235192186, 0.5986999281288801, 0.8759395175173526, 0.832741361621459, 0.5094280473445414, 0.8762546477212869, 0.21802307318734138, 0.5132022726503467]}}
{"id": "04d57087-bdba-4b06-8ab2-7a057cf33a5c", "fitness": 0.6258478999010582, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation using a single target vector for mutation and a focused exploration strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx]\n\n        while self.budget > 0:\n            # Adaptive F and CR, simplified\n            self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n            self.CR = np.clip(np.random.normal(0.7, 0.1), 0.1, 0.9)\n\n            for i in range(self.pop_size):\n                # Mutation using only the best individual\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x1, x2 = population[idxs]\n                mutant = population[best_idx] + self.F * (x1 - x2)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        best_idx = i\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.626 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["372487f0-4db6-43fa-bdf2-dd369124de94"], "operator": null, "metadata": {"aucs": [0.21517228073517392, 0.8596197597963073, 0.9334252114079092, 0.26558989535641453, 0.8918563924480536, 0.950604412480105, 0.30516422315970937, 0.5915537752646893, 0.36075804448513904, 0.19227175455150725, 0.9658837823961024, 0.9981061863427937, 0.3673982439393316, 0.9328249232705954, 0.7440028368130144, 0.913926346903871, 0.3371251282110408, 0.9557508157363688, 0.23476284447846074, 0.501161140244576]}}
{"id": "20e55adf-9f78-4306-a951-953f65e85f16", "fitness": 0.7300915531094624, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified crossover, dynamic population size, and fitness-based shrinking.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Aggressive population shrinking based on budget and fitness\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:  # More aggressive shrinking\n                median_fitness = np.median(fitness)\n                bad_indices = np.where(fitness > median_fitness)[0]\n                num_to_remove = min(len(bad_indices), self.pop_size // 2)  # Remove up to 50%\n                if num_to_remove > 0:\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n                    \n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover - Simplified: always cross at least one point.\n                j_rand = np.random.randint(self.dim)\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                  if np.random.rand() < self.CR or j == j_rand:\n                    trial[j] = mutant[j]\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.730 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0f2ae23e-ebf0-4401-88c3-f676acde78be"], "operator": null, "metadata": {"aucs": [0.2723835373130694, 0.5862895132369506, 0.6989661632683497, 0.9013799876397991, 0.8286007799285675, 0.8399548037562503, 0.7369330603764362, 0.7481084320402587, 0.8203064153881744, 0.7783419884873667, 0.8978959546641525, 0.99915740470575, 0.36599545727296756, 0.7676163705539635, 0.9165046218441039, 0.8512829678830546, 0.6730956585908736, 0.8815776435235175, 0.511969074554647, 0.5254712271609931]}}
{"id": "a1b8c855-5592-48d4-bca2-a67c3486a848", "fitness": 0.5701039154953627, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR, F based on budget, and shrinking population size, focusing on exploration in early stages and exploitation later.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = 0.5\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Adapt CR and F based on remaining budget\n            progress = 1 - (self.budget / 10000)\n            self.CR = 0.4 + 0.5 * progress  # Increase CR as budget decreases\n            self.F = 0.4 + 0.3 * (1 - progress)  # Decrease F as budget decreases\n            \n            # Population shrinking (less aggressive)\n            if self.budget < 0.6 * 10000 and self.pop_size > 4:\n                num_to_remove = max(1, self.pop_size // 5)  # Remove up to 20%\n                worst_indices = np.argsort(fitness)[-num_to_remove:]\n                population = np.delete(population, worst_indices, axis=0)\n                fitness = np.delete(fitness, worst_indices)\n                self.pop_size = len(population)\n\n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.570 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0f2ae23e-ebf0-4401-88c3-f676acde78be"], "operator": null, "metadata": {"aucs": [0.20496204482347768, 0.2795178623379868, 0.5533451916196274, 0.7967444942716515, 0.5833267965143076, 0.7532147717976339, 0.45954552869251586, 0.5612149829274089, 0.6397806221577688, 0.3808845573311791, 0.7953086812650162, 0.9968750441536026, 0.2950026900082364, 0.5218943874446372, 0.8386210371725721, 0.7249372869484377, 0.41855605416789454, 0.835196649654691, 0.25253263058961894, 0.510616996028991]}}
{"id": "dcba882e-6608-44e1-a619-d5d9167582fa", "fitness": 0.6653813756816869, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR and adaptive F, removing population shrinking for simplicity and efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                \n                # Adaptive F\n                self.F = np.random.uniform(0.3, 0.9)\n\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.665 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c1534e15-8090-486e-b57b-9d89e141d2d7"], "operator": null, "metadata": {"aucs": [0.21896288301706368, 0.3388661218714466, 0.6706586622657753, 0.8952029094056668, 0.7674066504795853, 0.8653300480712021, 0.5826173050527464, 0.6809023877139742, 0.8068719545656723, 0.7244115865107932, 0.8136149472180287, 0.9916071545092704, 0.30356911762248195, 0.7076947426152056, 0.8908482564506744, 0.8615937127532843, 0.5163707817770502, 0.8747238904296182, 0.2549065816287418, 0.5414678196754563]}}
{"id": "dc1fa078-0cbf-4f98-a3f1-9655fedc5f3e", "fitness": 0.6202169666278743, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified dynamic CR, F, and population size reduction based on remaining budget.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate and mutation factor\n            self.CR = 0.1 + 0.5 * (self.budget / 10000)\n            self.F = 0.3 + 0.4 * (self.budget / 10000)\n\n            # Adaptive population shrinking based on remaining budget\n            if self.budget < 0.5 * 10000 and self.pop_size > 10:\n                num_to_remove = max(1, self.pop_size // 5) #Reduce more carefully\n                if self.pop_size - num_to_remove >= 5: #Ensure a minimum population size\n                     indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                     population = population[indices_to_keep]\n                     fitness = fitness[indices_to_keep]\n                     self.pop_size = len(population)\n           \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.620 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3a633cfd-09e1-41e5-9cf2-7b29eb7e1120"], "operator": null, "metadata": {"aucs": [0.1976252103139372, 0.3169733819992342, 0.6488092960837752, 0.8292893576965088, 0.7220241782961345, 0.779362057348691, 0.47365901539307276, 0.6223979036215579, 0.7265856785723075, 0.6613606231591869, 0.8312175266089596, 0.996080599105461, 0.2628911514767277, 0.6686966548012443, 0.7304445642396851, 0.7997889600326965, 0.5439083623977746, 0.8184482252660588, 0.22329493530514433, 0.5514816508393305]}}
{"id": "0221ffdd-9e80-44c8-ba54-8b1c69c9f396", "fitness": 0.7634423502568984, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified dynamic CR, fixed F, and aggressive population shrinking based on fitness and budget.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Fixed F value\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate - simplified\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)  # CR between 0.5 and 0.9\n\n            # Adaptive population shrinking based on budget and fitness\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:\n                best_fitness = np.min(fitness)\n                worst_fitness = np.max(fitness)\n                \n                # Shrink aggressively if fitness is relatively uniform and we're past half budget\n                if (worst_fitness - best_fitness) < 0.1:\n                    num_to_remove = max(1, self.pop_size // 3)  # Remove at least one\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.763 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3a633cfd-09e1-41e5-9cf2-7b29eb7e1120"], "operator": null, "metadata": {"aucs": [0.23000757767998337, 0.7367093090128594, 0.7521800777929964, 0.926420885009909, 0.833746620233521, 0.8642159093468206, 0.7247409445366304, 0.7817328445493069, 0.8434053337695154, 0.7998211463736948, 0.9050368733550704, 0.995814672359626, 0.5671690259542763, 0.8043628013655283, 0.9004703649254994, 0.8783330691727514, 0.5545027600361037, 0.8884213459794925, 0.6710849161315257, 0.6106705275528574]}}
{"id": "caa09436-e3f1-40e7-925a-cc2d3f770687", "fitness": 0.5919959507216328, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, dynamic population size based on fitness improvement, and jitter-based mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n        self.min_pop_size = 5  # Minimum population size\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        best_fitness_history = []\n\n        while self.budget > 0:\n            # Adaptive F: Introduce jitter to F\n            self.F = 0.5 + 0.3 * np.random.normal(0, 0.1)\n            self.F = np.clip(self.F, 0.2, 0.8)\n            \n            # Dynamically adapt crossover rate (linearly decreasing)\n            self.CR = 0.9 * (self.budget / 10000)\n            self.CR = np.clip(self.CR, 0.1, 0.9)\n\n            # Track best fitness\n            current_best_fitness = np.min(fitness)\n            best_fitness_history.append(current_best_fitness)\n\n            # Adaptive population shrinking based on lack of improvement\n            if len(best_fitness_history) > 10:\n                if np.std(best_fitness_history[-10:]) < 1e-4 and self.pop_size > self.min_pop_size:  #significant population reduction\n                    self.pop_size = max(self.pop_size // 2, self.min_pop_size)\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    \n\n            for i in range(self.pop_size):\n                # Mutation with jitter\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                \n                #Jitter-based mutation\n                jitter = np.random.uniform(-0.05, 0.05, self.dim)\n                mutant = x1 + self.F * (x2 - x3) + jitter\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.592 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c1534e15-8090-486e-b57b-9d89e141d2d7"], "operator": null, "metadata": {"aucs": [0.3264316537776978, 0.6024166671166336, 0.5265174095630655, 0.9578168239947562, 0.552985466794312, 0.6305681955029151, 0.3672922422434659, 0.47740703421159125, 0.5607648777607406, 0.5495812730277887, 0.9293160597522746, 0.9978480204981923, 0.31517397754145493, 0.5437262010514343, 0.8880667855862403, 0.6416821292249045, 0.4822471567310749, 0.7515813945929378, 0.2293545730178307, 0.509141072443343]}}
{"id": "b554387f-9053-48ab-b154-d774e0ebd31f", "fitness": 0.736872809674236, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, focused population, and dynamic shrinking based on fitness quartiles and stagnation detection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n        self.stagnation_counter = 0\n        self.previous_best = np.inf\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate based on remaining budget\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Adaptive population shrinking based on fitness quartile and stagnation\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:\n                if self.f_opt >= self.previous_best:\n                    self.stagnation_counter += 1\n                else:\n                    self.stagnation_counter = 0\n\n                self.previous_best = self.f_opt\n\n                if self.stagnation_counter > 5:\n                    percentile_75 = np.percentile(fitness, 75)\n                    bad_indices = np.where(fitness > percentile_75)[0]\n                    num_to_remove = min(len(bad_indices), self.pop_size // 4)\n                    if num_to_remove > 0:\n                        indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                        population = population[indices_to_keep]\n                        fitness = fitness[indices_to_keep]\n                        self.pop_size = len(population)\n                        self.stagnation_counter = 0 # Reset stagnation after shrinking\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.737 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c1534e15-8090-486e-b57b-9d89e141d2d7"], "operator": null, "metadata": {"aucs": [0.2732004439369572, 0.5953204518604702, 0.7434782245298088, 0.8816462712368666, 0.8374126115955376, 0.8689590595537564, 0.7689744909372931, 0.7470166320484115, 0.8309240661195334, 0.7738738204308677, 0.9045563389999539, 0.9996730619883346, 0.32474397352713613, 0.79197948768345, 0.9154289995187355, 0.8910844462732812, 0.601407120143549, 0.8963269746790851, 0.5576854340945865, 0.5337642843271061]}}
{"id": "7375c670-083b-486d-9ad9-684a482c916f", "fitness": 0.4549414726048169, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and focus on exploitation by prioritizing crossover near the best solution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        best_idx = np.argmin(fitness)\n        self.f_opt = fitness[best_idx]\n        self.x_opt = population[best_idx]\n\n        while self.budget > 0:\n            # Adaptive CR: Reduce diversity as optimization progresses.\n            self.CR = 0.9 - 0.8 * (1 - self.budget / (self.budget + self.pop_size)) #linear decrease in CR\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = population[i] + 0.5 * (x1 - x2)  # Simplified mutation, F=0.5\n\n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover: Bias crossover towards the best solution\n                cross_points = np.random.rand(self.dim) < self.CR\n                #Guarantee at least one crossover point\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                # Ensure best solution gene is always inherited with some probability\n                if np.random.rand() < 0.9:\n                    best_gene_idx = np.random.randint(0, self.dim)\n                    cross_points[best_gene_idx] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        best_idx = i\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.455 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["372487f0-4db6-43fa-bdf2-dd369124de94"], "operator": null, "metadata": {"aucs": [0.15908941522320785, 0.30798340074928865, 0.4169504358434849, 0.7228829517539517, 0.36274940786052223, 0.5015402303547394, 0.3180834846940498, 0.38446791482240994, 0.37807134449309354, 0.19552219769185852, 0.711728892074799, 0.9978495508400289, 0.42165286548057734, 0.3267266500267467, 0.7669556052961665, 0.4536450334762617, 0.367266778704205, 0.6180193057784629, 0.1947084231177343, 0.49293556381474846]}}
{"id": "83e03b5b-f3a1-4d88-af51-9901db49156e", "fitness": 0.6874329809926103, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR, fixed F, and budget-aware population adjustment, emphasizing simplicity and efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Population adjustment based on budget\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:\n                self.pop_size = max(5, self.pop_size // 2)  # Reduce pop_size, ensure minimum of 5\n                population = population[:self.pop_size]\n                fitness = fitness[:self.pop_size]\n            \n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover - Simplified: binomial\n                trial = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = mutant[j]\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.687 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["20e55adf-9f78-4306-a951-953f65e85f16"], "operator": null, "metadata": {"aucs": [0.21662885923125752, 0.491139167286351, 0.6380301155595702, 0.9107239675597584, 0.768076885230227, 0.8276715829274598, 0.6705434113598916, 0.7306723344095956, 0.7910385292708171, 0.7584148153884646, 0.8623008517758013, 0.9964555626746648, 0.3126773767184453, 0.7482513930275916, 0.9230245622956512, 0.8526420259849187, 0.660081581139777, 0.8746865048632779, 0.20312911445572257, 0.5124709786929629]}}
{"id": "520fb230-ec26-43b9-8345-11e6108aee1b", "fitness": 0.6726722795077112, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with dynamic CR, fixed F, and fitness-based population reduction focused on simplicity and efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Population reduction based on budget\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:\n                num_to_remove = max(1, self.pop_size // 4) # Remove at least 1, up to 25%\n                indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                population = population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n                self.pop_size = len(population)\n\n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                trial = np.copy(population[i])\n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial[crossover_mask] = mutant[crossover_mask]\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.673 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["20e55adf-9f78-4306-a951-953f65e85f16"], "operator": null, "metadata": {"aucs": [0.2572321928444663, 0.2635942578748939, 0.6910263024329333, 0.9061996607817788, 0.8113744214837856, 0.8444053581172029, 0.7146809884628125, 0.6097346147247288, 0.7791533115357623, 0.738158988753129, 0.857747315936223, 1.0, 0.28920696966110837, 0.64482387151899, 0.8915266299670334, 0.853920122727259, 0.5482076874506097, 0.882442062020919, 0.29734297436982715, 0.5726678594907606]}}
{"id": "d68ac237-fe3b-4893-b3f5-7372c3eb6dd2", "fitness": 0.7553677127595947, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with dynamic CR and fitness-based population replacement for improved efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)  # Keep dynamic CR\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.755 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["afa85087-6bb9-4ab4-9eb4-6cbb3b56154f"], "operator": null, "metadata": {"aucs": [0.32956975798916377, 0.7796768788570878, 0.7828808042654924, 0.9186165517790992, 0.7827373657570338, 0.8483303365156704, 0.7603351161529699, 0.7561243139446487, 0.8338751630068122, 0.8171931795878052, 0.9163443056455952, 0.9981657351328629, 0.5770391905298833, 0.797472082246471, 0.9318932601196664, 0.8647148226327851, 0.7122860410811788, 0.8967727262983991, 0.2726331348203568, 0.5306934888289111]}}
{"id": "78263423-aa20-45e0-9792-fbbd6bcd1933", "fitness": 0.753461596889679, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR, fixed F, and fitness-based population shrinking.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamic CR\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            # Population shrinking\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:\n                if np.std(fitness) < 0.05:  # More robust shrinking criterion\n                    num_to_remove = max(1, self.pop_size // 3)\n                    indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n                    \n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.753 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0221ffdd-9e80-44c8-ba54-8b1c69c9f396"], "operator": null, "metadata": {"aucs": [0.25729824922978994, 0.7177683551236541, 0.6145128452533397, 0.9116054323503012, 0.8021870560714159, 0.8657880762017858, 0.7747358189976207, 0.7763857982161816, 0.8271930317140234, 0.7785035060574133, 0.9019506021252083, 0.9988409111596356, 0.5247166464052699, 0.8229267167329362, 0.9403200809595882, 0.8725645857787432, 0.7183701386224728, 0.8904058620554686, 0.5450818391376222, 0.528076385601113]}}
{"id": "78a33dc5-7251-4362-941a-faadbb7cc55c", "fitness": 0.6914265628275758, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and population control based on fitness and remaining budget, focusing on exploration in early stages and exploitation in later stages.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.3  # Initialize with lower CR for more exploration\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate based on remaining budget\n            # Increase CR as budget decreases to focus on exploitation\n            self.CR = 0.3 + 0.6 * (1 - self.budget / 10000) \n\n            # Dynamic population size reduction\n            current_pop_size = self.pop_size\n            if self.budget < 0.3 * 10000 and current_pop_size > 5:\n                num_to_remove = max(1, current_pop_size // 5)  # Remove at least 1\n                indices_to_keep = np.argsort(fitness)[:current_pop_size - num_to_remove]\n                population = population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n                self.pop_size = len(population)\n                \n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.691 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b554387f-9053-48ab-b154-d774e0ebd31f"], "operator": null, "metadata": {"aucs": [0.22440151907116646, 0.5257713169675955, 0.7601861793769722, 0.8512301559741208, 0.7613824149434198, 0.8755013907849185, 0.7296861731789428, 0.7215615072578268, 0.8274308183382804, 0.6004959889037123, 0.7933381273204559, 0.99908172442965, 0.34317857817256114, 0.7372015002269982, 0.8923199812730114, 0.8705437737684246, 0.6849394303722293, 0.8680238274100425, 0.24254913421311775, 0.5197077145680724]}}
{"id": "52706944-0e69-48ba-b534-140b37dffc5d", "fitness": 0.6740864692304335, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR and fitness-based population adjustment using a single trial vector generation for enhanced efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Population adjustment based on budget\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:\n                self.pop_size = max(5, self.pop_size // 2)  # Reduce pop_size, ensure minimum of 5\n                population = population[:self.pop_size]\n                fitness = fitness[:self.pop_size]\n            \n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation and Crossover - combined into a single trial vector generation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                \n                trial = population[i].copy()\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial[j] = x1[j] + self.F * (x2[j] - x3[j])\n\n                # Ensure trial stays within bounds\n                trial = np.clip(trial, func.bounds.lb, func.bounds.ub)\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.674 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["83e03b5b-f3a1-4d88-af51-9901db49156e"], "operator": null, "metadata": {"aucs": [0.2382398859934678, 0.481724596317057, 0.633315768626652, 0.9097260739104612, 0.7867946787056586, 0.8490075710826347, 0.7034480695398307, 0.671148063675419, 0.7923112184090584, 0.7090166602375494, 0.8585285546133572, 0.9990094981665893, 0.2675182328406235, 0.7407570841420578, 0.8346381117711034, 0.84118746967923, 0.5187094081371711, 0.8793318852818621, 0.25638798803828744, 0.5109285654405964]}}
{"id": "1b8ab971-1d5d-4030-bbd9-6e13f70f61a4", "fitness": 0.6306303011025682, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with dynamic CR, fixed F, fitness-based replacement, and reduced population size for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=15):  # Reduced population size\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)  # Keep dynamic CR\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.631 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d68ac237-fe3b-4893-b3f5-7372c3eb6dd2"], "operator": null, "metadata": {"aucs": [0.5222762279377084, 0.367440658668421, 0.35942930298822917, 0.30079378078548125, 0.791552922772871, 0.9399326551950421, 0.3844539767344587, 0.9011168866029245, 0.7268886278153432, 0.5142822654964094, 0.48865364065340966, 0.9960521405080507, 0.3085334978887634, 0.9060195851229145, 0.5915125511204858, 0.933410602875318, 0.8781731380369493, 0.942518356214299, 0.2539955926957105, 0.5055696119385746]}}
{"id": "76c1c10d-2c20-440c-ba80-1503bb758470", "fitness": 0.7264812557586484, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with dynamic CR, fixed F, and survivor selection based on fitness improvement rate.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamic CR\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    delta_f = fitness[i] - f\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.726 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["78263423-aa20-45e0-9792-fbbd6bcd1933"], "operator": null, "metadata": {"aucs": [0.2614224056038763, 0.6905033457372165, 0.7970702760325592, 0.9153709305345507, 0.8359790003466503, 0.8567587576171025, 0.7395347345163268, 0.7971840777399833, 0.857104098143267, 0.3064064661416639, 0.9148252209390265, 0.9942580460601942, 0.6071991330365683, 0.8034843011220415, 0.9289650369232834, 0.8521018197394747, 0.7160154695351544, 0.8847680151059139, 0.2828621797387363, 0.4878118005593771]}}
{"id": "255df22d-0f63-462f-9f34-d20dd34a944f", "fitness": 0.77654607344864, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR based on remaining budget and enhanced population update using binomial crossover.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < CR\n                cross_points[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.777 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d68ac237-fe3b-4893-b3f5-7372c3eb6dd2"], "operator": null, "metadata": {"aucs": [0.3733504398972437, 0.7672622479962282, 0.8106596518846323, 0.921389111642623, 0.8581940918496562, 0.8793342282549541, 0.7620873625325025, 0.7932099434320072, 0.8348553210187225, 0.4308496360497839, 0.9039474383771362, 0.99593336739128, 0.68616909679283, 0.8186068546753411, 0.9217928597287833, 0.880831439934117, 0.7636048726564231, 0.9134492259430149, 0.6999864845137261, 0.5154077944017936]}}
{"id": "7d2e9ca7-4496-4a56-87bb-975f8f11b0d1", "fitness": 0.5513713329643406, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and fitness-based population replacement using only the best individual for mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        best_index = np.argmin(fitness)\n        self.f_opt = fitness[best_index]\n        self.x_opt = population[best_index]\n\n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            CR = 0.5 + 0.4 * (self.budget / 10000)  # Keep dynamic CR\n\n            for i in range(self.pop_size):\n                # Mutation using the best individual\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x2, x3 = population[idxs]\n                mutant = self.x_opt + self.F * (x2 - x3) # Mutation using best solution\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        best_index = i\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.551 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d68ac237-fe3b-4893-b3f5-7372c3eb6dd2"], "operator": null, "metadata": {"aucs": [0.42211633072414956, 0.4244790015892549, 0.9462992072567376, 0.17102305568521114, 0.2951227466771289, 0.9653554123474705, 0.36538139922704493, 0.7464964871020302, 0.9550151511104673, 0.21135352090169968, 0.9336120322752124, 0.9975366725902632, 0.288380829925147, 0.23732868932027873, 0.5875581309665743, 0.3609701982285888, 0.4183822483829378, 0.9558553220813635, 0.2392362437308686, 0.5059239791643813]}}
{"id": "e95aa6d1-57a7-4969-885b-29b20f1ee742", "fitness": 0.4613929380319702, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR and fitness-based population size reduction triggered by stagnation detection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30, stagnation_threshold=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n        self.stagnation_threshold = stagnation_threshold\n        self.stagnation_counter = 0\n        self.previous_best_fitness = np.inf\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamic CR\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.stagnation_counter = 0  # Reset stagnation counter\n                    else:\n                        self.stagnation_counter += 1\n                else:\n                    self.stagnation_counter += 1\n\n                if self.budget <= 0:\n                    break\n            \n            # Population size reduction based on stagnation\n            if self.stagnation_counter > self.stagnation_threshold and self.pop_size > 5:\n                num_to_remove = max(1, self.pop_size // 3)\n                indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                population = population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n                self.pop_size = len(population)\n                self.stagnation_counter = 0 # Reset stagnation after shrinking\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.461 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["78263423-aa20-45e0-9792-fbbd6bcd1933"], "operator": null, "metadata": {"aucs": [0.21315651830786497, 0.3731181286977773, 0.3390139381586539, 0.514093521396098, 0.7441131792150913, 0.45639165426301553, 0.3330573924129918, 0.3409250182299455, 0.40564206117136803, 0.2314021868441073, 0.2701715396116232, 0.995969785753029, 0.27115628007157366, 0.36423706760013463, 0.6402945946723095, 0.9196329350124354, 0.40909210219454073, 0.6728914937684192, 0.22731012760411062, 0.5061892356543134]}}
{"id": "9c6d39a3-c05d-4d21-abf1-2707250ac874", "fitness": 0.6728575693113268, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and budget-aware population management, prioritizing exploration and exploitation balance with enhanced mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.1 + 0.6 * (self.budget / 10000)\n\n            # Population adjustment based on budget\n            if self.budget < 0.3 * 10000 and self.pop_size > 5:\n                self.pop_size = max(5, self.pop_size // 2)  # Reduce pop_size, ensure minimum of 5\n                population = population[:self.pop_size]\n                fitness = fitness[:self.pop_size]\n            \n            if self.pop_size < 3:\n                break\n            \n            for i in range(self.pop_size):\n                # Mutation: enhanced strategy with random F\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                F = np.random.uniform(0.3, 0.7) # dynamic F\n                mutant = x1 + F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover - Simplified: binomial\n                trial = np.copy(population[i])\n                crossover_points = np.random.rand(self.dim) < self.CR\n                trial[crossover_points] = mutant[crossover_points] # vectorization\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.673 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["83e03b5b-f3a1-4d88-af51-9901db49156e"], "operator": null, "metadata": {"aucs": [0.21752111224771142, 0.41928554601610435, 0.6433248266171077, 0.8529526061871981, 0.8127178575772593, 0.8271224643416186, 0.722127945184335, 0.6571067931480539, 0.818146839250323, 0.7622267017340212, 0.8530901283202996, 0.9994213471316139, 0.29845721455617924, 0.7545029794410405, 0.728596819929838, 0.8458402849820083, 0.5762670795045616, 0.8688617290199123, 0.2997319596515544, 0.4998491513857958]}}
{"id": "623c83c8-3946-4f38-ac60-e90be4c0192b", "fitness": 0.5963088615963136, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, focusing on aggressive population reduction based on budget to accelerate convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.3\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Adaptive CR (Simplified)\n            self.CR = 0.1 + 0.8 * (1 - self.budget / 10000)\n\n            # Aggressive Population Reduction\n            if self.budget < 0.5 * 10000 and self.pop_size > 5:\n                num_to_remove = max(1, int(self.pop_size * 0.3))  # Remove a larger portion\n                indices_to_keep = np.argsort(fitness)[:self.pop_size - num_to_remove]\n                population = population[indices_to_keep]\n                fitness = fitness[indices_to_keep]\n                self.pop_size = len(population)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.596 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["78a33dc5-7251-4362-941a-faadbb7cc55c"], "operator": null, "metadata": {"aucs": [0.22366443256844648, 0.3328904025925916, 0.5530921519404894, 0.6780260201433326, 0.688729778965137, 0.827841347492409, 0.39929100805117745, 0.6949445709088922, 0.7501561148999305, 0.398602444867316, 0.6893680805098684, 0.9880634853814483, 0.2782387238525793, 0.6933595037618638, 0.8790819401666483, 0.8525610038404444, 0.4686138189043373, 0.8033177700459279, 0.20719963711489298, 0.5191349959185381]}}
{"id": "1afee8e7-0b17-43fd-a82a-6bb8283000d0", "fitness": 0.7849767939168327, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified dynamic CR and a rank-based population update for better convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        # Sort population based on fitness\n        ranked_indices = np.argsort(fitness)\n        population = population[ranked_indices]\n        fitness = fitness[ranked_indices]\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Rank-based population update: Replace the worst individual if trial is better than it\n                if f < fitness[-1]:  # Compare against the worst\n                    fitness[-1] = f\n                    population[-1] = trial\n\n                    # Re-sort population based on fitness\n                    ranked_indices = np.argsort(fitness)\n                    population = population[ranked_indices]\n                    fitness = fitness[ranked_indices]\n                    \n                    # Update the best solution\n                    if fitness[0] < self.f_opt:\n                        self.f_opt = fitness[0]\n                        self.x_opt = population[0]\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.785 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d68ac237-fe3b-4893-b3f5-7372c3eb6dd2"], "operator": null, "metadata": {"aucs": [0.46626870736121795, 0.8294089071735135, 0.48244666679307424, 0.942553236217899, 0.8909431771010989, 0.9145094372985565, 0.8390788643350426, 0.8691803389764996, 0.9024901289360124, 0.8711914041316928, 0.9263972973993353, 0.9908684005039545, 0.5436548389110709, 0.87438069531931, 0.8623131219086085, 0.9103219533512079, 0.8713973248080611, 0.9336620338387422, 0.24110532373296012, 0.5373640202387969]}}
{"id": "cc343922-057a-4748-9197-a2fd83e5fae3", "fitness": 0.576550076370516, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with dynamic CR, fixed F, and improved fitness-based population shrinking based on a fixed threshold, ensuring a minimum population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.3\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        min_pop_size = 5  # Minimum population size\n        \n        while self.budget > 0:\n            self.CR = 0.3 + 0.6 * (1 - self.budget / 10000)\n\n            # Population shrinking based on fixed threshold\n            if self.pop_size > min_pop_size:\n                threshold = np.median(fitness)  # Use median as threshold\n                indices_to_keep = np.where(fitness <= threshold)[0]\n                \n                if len(indices_to_keep) < self.pop_size: #ensure shrinking happens\n                    population = population[indices_to_keep]\n                    fitness = fitness[indices_to_keep]\n                    self.pop_size = len(population)\n            \n            if self.pop_size < min_pop_size:\n                num_to_add = min_pop_size - self.pop_size\n                new_individuals = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(num_to_add, self.dim))\n                new_fitness = np.array([func(x) for x in new_individuals])\n                self.budget -= num_to_add\n\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n                self.pop_size = len(population)\n            \n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                \n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.577 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["78a33dc5-7251-4362-941a-faadbb7cc55c"], "operator": null, "metadata": {"aucs": [0.14679798752119333, 0.22007973780716206, 0.6504295010203309, 0.947397850406228, 0.7834827350567464, 0.5594963199669547, 0.5800144435883521, 0.8958188246944815, 0.6517246407662918, 0.9324881485850907, 0.44064346472392213, 0.9986173094246419, 0.30055532513850103, 0.34617388017535344, 0.7035647428648981, 0.30652443986233735, 0.39897331922206836, 0.9441766465315367, 0.23548258662240595, 0.4885596234318249]}}
{"id": "687d32b8-ce54-4810-a719-7c767cd62ed8", "fitness": 0.7615679738901246, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and fitness-based population update, focusing on computational efficiency and exploration/exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Adaptive Crossover Rate\n            CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                trial = np.copy(population[i])\n                cross_points = np.random.rand(self.dim) < CR\n                trial[cross_points] = mutant[cross_points]\n\n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.762 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d68ac237-fe3b-4893-b3f5-7372c3eb6dd2"], "operator": null, "metadata": {"aucs": [0.2951516236149637, 0.7251077187367531, 0.7678916418620264, 0.933227504346454, 0.8504858362773785, 0.8674833787170892, 0.7418368242119278, 0.7912294168249578, 0.8121456833947298, 0.694269637506694, 0.9050924107624969, 0.9991596971323934, 0.6159759737555162, 0.7735939530729871, 0.9305603849668678, 0.8544387174313921, 0.7234462988918373, 0.9040431879488038, 0.32031071665768485, 0.7259088716895379]}}
{"id": "3c8bc865-4e34-446e-b7a7-39cfa951aa0e", "fitness": 0.6996433403194533, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified dynamic CR, fixed F, and stochastic ranking-based population replacement for efficiency and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Dynamically adapt crossover rate\n            self.CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n                \n                # Stochastic Ranking\n                if (f < fitness[i]) or (np.random.rand() < 0.1):  # Stochastic replacement\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.700 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d68ac237-fe3b-4893-b3f5-7372c3eb6dd2"], "operator": null, "metadata": {"aucs": [0.2251386089058245, 0.5522098906130306, 0.6841957319541538, 0.9087592380444584, 0.8057470493197925, 0.8428428389375543, 0.7256264710918672, 0.6649777749843959, 0.8186363706451365, 0.7361503512465276, 0.878277262865747, 0.9982849541758472, 0.3103910930849404, 0.7790381530352688, 0.9295884984761248, 0.8433877415891103, 0.6443624723514512, 0.8996043376426173, 0.22030050369271825, 0.5253474637325009]}}
{"id": "8c43b90e-df21-4d44-8d52-089158614e27", "fitness": 0.7115161381264741, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a linearly decreasing crossover rate and a greedy population update.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Linearly decrease crossover rate\n            CR = 0.9 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                #Greedy selection\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.712 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["255df22d-0f63-462f-9f34-d20dd34a944f"], "operator": null, "metadata": {"aucs": [0.2371254390139088, 0.5278863107041432, 0.7167922596693708, 0.9221852500240137, 0.8365390440354827, 0.8586946569569059, 0.726615992474456, 0.6863254536255488, 0.8061369877283846, 0.7374746611612624, 0.9102127102403235, 0.9954096797995231, 0.31746877732281187, 0.8248781617757002, 0.9283214283879492, 0.8758124100862429, 0.6440996909572579, 0.8946239692568289, 0.25269758110100604, 0.5310222982083616]}}
{"id": "106823b3-ac43-47e4-a3a1-981ddf61d663", "fitness": 0.7126326444181468, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a dynamically adjusted crossover rate and direct replacement strategy for enhanced exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Adaptive Crossover Rate (linearly decreases)\n            CR = 0.9 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + 0.5 * (x2 - x3)  # Fixed F = 0.5\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                trial = np.copy(population[i])\n                cross_points = np.random.rand(self.dim) < CR\n                trial[cross_points] = mutant[cross_points]\n\n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Direct replacement if the trial is better\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.713 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["687d32b8-ce54-4810-a719-7c767cd62ed8"], "operator": null, "metadata": {"aucs": [0.21547819795627332, 0.42954195709692733, 0.7630434892363683, 0.9265361993954342, 0.7930772587260257, 0.8620909901029687, 0.7416584021461602, 0.6851666691490043, 0.8199687103337798, 0.7610331009040565, 0.9180451077181847, 0.9985105364001285, 0.4261411348509828, 0.7990037639978398, 0.8802942661983554, 0.8707925174426903, 0.6274445224124348, 0.8901728633109904, 0.3165862865717203, 0.5280669144126079]}}
{"id": "2e14c7fe-0e4d-47c4-a6df-815b88bc8aac", "fitness": 0.7120207250842286, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR based on remaining budget and stochastic ranking for population updates.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            CR = 0.5 + 0.4 * (self.budget / 10000)  # Dynamic CR\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f = func(trial)\n                self.budget -= 1\n\n                # Stochastic Ranking\n                if (f < fitness[i]) or (np.random.rand() < 0.1): #Stochastic ranking\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.712 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["76c1c10d-2c20-440c-ba80-1503bb758470"], "operator": null, "metadata": {"aucs": [0.2229599184590636, 0.6182839831014322, 0.7397421947520779, 0.8996176640379172, 0.8134136169213719, 0.8425714433776372, 0.6501578006933894, 0.7033705020480783, 0.8076855452410601, 0.7004056159979579, 0.9004600493544105, 0.9973259770085845, 0.33439578392610014, 0.7835359552970242, 0.870874469183464, 0.8489735527741181, 0.6392669216341708, 0.8707622693448653, 0.4714915365722697, 0.5251197019595779]}}
{"id": "356f8dd0-071c-4536-991d-0bff92909925", "fitness": 0.7233054332386275, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with linearly decreasing CR and aggressive population update based on pairwise comparison.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Linearly decrease crossover rate\n            CR = 0.9 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < CR\n                cross_points[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Aggressive population update: replace if better\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.723 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["255df22d-0f63-462f-9f34-d20dd34a944f"], "operator": null, "metadata": {"aucs": [0.25629738162739235, 0.6471060145535854, 0.7676910641908951, 0.8956037544206258, 0.8412633406676261, 0.8655304868905067, 0.7631839048522937, 0.7624083170352784, 0.8348147960211436, 0.7276669093160297, 0.9071139484983292, 0.9914514519370774, 0.29970687301069443, 0.7941344627922915, 0.901023334746728, 0.862402290793263, 0.6787474853742517, 0.9084270830023545, 0.23411114641993003, 0.5274246186222504]}}
{"id": "d18512a1-d978-4e94-ba29-6f2da9dfd0d9", "fitness": 0.6604179151875471, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with dynamic CR and rank-based selection for improved exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        # Sort population based on fitness\n        ranked_indices = np.argsort(fitness)\n        population = population[ranked_indices]\n        fitness = fitness[ranked_indices]\n        \n        while self.budget > 0:\n            # Adaptive Crossover Rate\n            CR = 0.1 + 0.8 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                F = 0.3 + 0.7 * np.random.rand() # Random F value for each mutation\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                trial = np.copy(population[i])\n                cross_points = np.random.rand(self.dim) < CR\n                trial[cross_points] = mutant[cross_points]\n\n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Selection: Replace if better\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n            #Sort population\n            ranked_indices = np.argsort(fitness)\n            population = population[ranked_indices]\n            fitness = fitness[ranked_indices]\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.660 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["687d32b8-ce54-4810-a719-7c767cd62ed8"], "operator": null, "metadata": {"aucs": [0.2061970591148795, 0.3010912238893716, 0.6597249615838022, 0.902141067363257, 0.7772326100601045, 0.8115062648131093, 0.5850031199217842, 0.591947827538678, 0.7405928786635827, 0.7301277958776575, 0.8792737966890292, 0.9935018222184544, 0.3536972315667388, 0.7568866610350353, 0.8085111684144576, 0.8124128696528259, 0.5214377811676716, 0.8810102279117663, 0.38242469463044737, 0.5136372416382898]}}
{"id": "fa7d84ac-9141-4a2e-a418-5e811f486d56", "fitness": 0.6732090709712548, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive CR and F, and efficient population update.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = 0.5\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Self-adaptive CR and F\n                cr = np.random.normal(self.CR, 0.1)\n                cr = np.clip(cr, 0, 1)\n                f = np.random.normal(self.F, 0.1)\n                f = np.clip(f, 0.1, 1.0)\n\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + f * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                \n                cross_points = np.random.rand(self.dim) < cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f_trial = func(trial)\n                self.budget -= 1\n\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = trial\n                    \n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial\n                        self.CR = 0.9 * self.CR + 0.1 * cr #CR adaptation based on success\n                        self.F = 0.9 * self.F + 0.1 * f #F adaptation based on success\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.673 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["76c1c10d-2c20-440c-ba80-1503bb758470"], "operator": null, "metadata": {"aucs": [0.23716209174300285, 0.3575141272764728, 0.6872696725704277, 0.8469768684800834, 0.7830286918285515, 0.8455260480858043, 0.6785623063718427, 0.7192157150201445, 0.7603039293221434, 0.7420878643081252, 0.8563092176693985, 0.99546653413156, 0.259202025549661, 0.7398860802410789, 0.9010992260072672, 0.8277022686118058, 0.5652202100420297, 0.8674105971546422, 0.2924412569054523, 0.5017966881056036]}}
{"id": "75eaf206-2783-4c77-9a13-dc31ccbfa8a8", "fitness": 0.0, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and vectorized operations for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7 \n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Mutation\n            idxs = np.random.randint(0, self.pop_size, size=(self.pop_size, 3))\n            x1, x2, x3 = population[idxs[:, 0]], population[idxs[:, 1]], population[idxs[:, 2]]\n            mutant = x1 + self.F * (x2 - x3)\n            \n            # Ensure mutant stays within bounds\n            mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n            # Crossover (Binomial)\n            cross_points = np.random.rand(self.pop_size, self.dim) < self.CR\n            j_rand = np.random.randint(0, self.dim, size=self.pop_size)\n            cross_points[np.arange(self.pop_size), j_rand] = True  # Ensure at least one crossover\n\n            trial = np.where(cross_points, mutant, population)\n            \n            # Evaluation\n            new_fitness = np.array([func(x) for x in trial])\n            self.budget -= self.pop_size\n            \n            # Aggressive population update: replace if better\n            improved = new_fitness < fitness\n            fitness[improved] = new_fitness[improved]\n            population[improved] = trial[improved]\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < self.f_opt:\n                self.f_opt = fitness[best_idx]\n                self.x_opt = population[best_idx]\n\n            if self.budget <= 0:\n                break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["356f8dd0-071c-4536-991d-0bff92909925"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "22dcbf36-9600-4358-ad3f-229614d93086", "fitness": 0.7543394900991985, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a focus on constraint handling for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Adaptive Crossover Rate: Reduce CR as budget decreases\n            CR = 0.5 + 0.4 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds using a repair strategy\n                mutant = np.maximum(np.minimum(mutant, func.bounds.ub), func.bounds.lb)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n                \n                # Greedy selection\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.754 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8c43b90e-df21-4d44-8d52-089158614e27"], "operator": null, "metadata": {"aucs": [0.36890468381934816, 0.7543592034754767, 0.7587454527705086, 0.9107043545317723, 0.8099086313600554, 0.8710909382682706, 0.7650022898215599, 0.7708668595231333, 0.8264232219978492, 0.7819728573799853, 0.905687718472859, 0.996619250415164, 0.30566063765594875, 0.8168305605114565, 0.9004016458088568, 0.8832976214134949, 0.7482727935388279, 0.8930532676340283, 0.3167802265846186, 0.7022075870007556]}}
{"id": "0b54802b-e022-4df7-924d-94451c1d602c", "fitness": 0.7545247198265839, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified crossover and population update, focusing on efficiency and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            CR = 0.7  # Fixed CR for simplicity and potentially better exploration\n\n            for i in range(self.pop_size):\n                if self.budget <= 0:\n                    break\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Simplified Crossover:  Replace dimension with probability CR\n                trial = population[i].copy()\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Greedy population update: replace if better\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.755 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["356f8dd0-071c-4536-991d-0bff92909925"], "operator": null, "metadata": {"aucs": [0.2848203906851714, 0.23063425265912296, 0.852318772992267, 0.9275605115943821, 0.8760822272348541, 0.8947253675011759, 0.37134003334046706, 0.8315910523423942, 0.8807167594471513, 0.8124193380617615, 0.9189490500710947, 0.9971101061954071, 0.512565781389292, 0.83411134971764, 0.9475640523412051, 0.8960679739717538, 0.7994704347661186, 0.9259914319101774, 0.760029492483095, 0.536426017827146]}}
{"id": "6e2ae272-86cd-4b36-a5d9-001dd81e07cf", "fitness": 0.7227051681203831, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter control and a focus on exploitation using a repair mechanism.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Fixed mutation factor\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Crossover rate decreases linearly\n            CR = 0.9 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Repair: If mutant exceeds bounds, project it back\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Greedy selection\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.723 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8c43b90e-df21-4d44-8d52-089158614e27"], "operator": null, "metadata": {"aucs": [0.23084287595328512, 0.67039450889866, 0.7670780219782839, 0.923544187556027, 0.8221189249093304, 0.8559489548712185, 0.7610100850207631, 0.6899786254098235, 0.7984589672130932, 0.7751636394574158, 0.9100650379781734, 0.9945940735170963, 0.35434955821030867, 0.7795086967076881, 0.9241939336475288, 0.865982537851717, 0.6772131806532085, 0.8902750925196374, 0.2295470175338381, 0.5338354425205631]}}
{"id": "73f0026b-29c3-42cc-803f-df6f86940256", "fitness": 0.6779908149692304, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a focused update strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        # Initial best\n        best_index = np.argmin(fitness)\n        self.f_opt = fitness[best_index]\n        self.x_opt = population[best_index]\n\n        while self.budget > 0:\n            CR = 0.5  # Fixed crossover rate\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial) - simplified\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Update if better\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        \n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.678 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["356f8dd0-071c-4536-991d-0bff92909925"], "operator": null, "metadata": {"aucs": [0.19429762737097966, 0.43035853178807104, 0.7154814385704704, 0.889190363348517, 0.7768312919238597, 0.85032670359315, 0.6309361955267061, 0.7163292169722504, 0.7869726547017402, 0.6810605568040475, 0.8306044629776701, 0.9934920747404429, 0.32837279569425337, 0.7626377456363326, 0.9078023226646634, 0.8444211287429958, 0.5391429302386967, 0.8781375075812836, 0.21081430626622377, 0.5926064442422536]}}
{"id": "38a9932e-0bbb-4d45-9c17-de7aa4a680e0", "fitness": 0.7521713108577299, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with linearly decreasing CR and stochastic population update based on pairwise comparison and reduced population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Linearly decrease crossover rate\n            CR = 0.9 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < CR\n                cross_points[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Stochastic population update: replace probabilistically if better\n                if f < fitness[i]:\n                    if np.random.rand() < 0.9:  # Add stochasticity to the update\n                        fitness[i] = f\n                        population[i] = trial\n\n                        if f < self.f_opt:\n                            self.f_opt = f\n                            self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.752 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["356f8dd0-071c-4536-991d-0bff92909925"], "operator": null, "metadata": {"aucs": [0.19556529970376968, 0.6611018439502254, 0.7884388402617524, 0.944925263926842, 0.87711330173753, 0.8040253250335008, 0.8353375179276845, 0.8098904147542987, 0.8761593366761029, 0.8630548339689443, 0.9323606537201912, 0.9974658937983238, 0.31550221678669, 0.8589902562712938, 0.8683525003087691, 0.8983440027333416, 0.8125834316198853, 0.916095848849586, 0.2720727947140301, 0.5160466404118371]}}
{"id": "5ab08bf4-3884-4cd7-89c3-00073845432a", "fitness": 0.7796433478411047, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Simplified Crossover and Budget-Aware Crossover Rate Adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Budget-aware crossover rate adaptation\n            CR = 0.5 + 0.4 * (self.budget / 10000)  # CR starts at 0.9 and decreases to 0.5\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Simplified Crossover (Uniform)\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Greedy replacement\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.780 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["356f8dd0-071c-4536-991d-0bff92909925"], "operator": null, "metadata": {"aucs": [0.317825954849448, 0.7114692616155396, 0.7919637374640718, 0.9169663241931618, 0.8377844129740813, 0.8627272723605682, 0.7827287832983796, 0.7849400596732036, 0.8339161164500298, 0.7821838025105843, 0.9196980937222686, 0.9942112363853512, 0.5244268857852004, 0.8144933485679233, 0.9331278393029493, 0.8704888512989173, 0.6972402853219015, 0.8927748679698264, 0.5868998916595085, 0.7369999314191795]}}
{"id": "5c677717-8688-4355-bcd7-5b4b291def12", "fitness": 0.33116483362877286, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with linearly decreasing CR and probabilistic population update.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            # Linearly decrease crossover rate\n            CR = 0.9 * (self.budget / 10000)\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < CR\n                cross_points[np.random.randint(0, self.dim)] = True  # Ensure at least one crossover\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Probabilistic population update\n                if np.random.rand() < 0.5 or f < fitness[i]:  # 50% chance to replace even if not better\n                    fitness[i] = f\n                    population[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.331 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["356f8dd0-071c-4536-991d-0bff92909925"], "operator": null, "metadata": {"aucs": [0.1383446179971799, 0.19902834751135268, 0.2931326205349345, 0.31178003927430487, 0.25012189688016706, 0.3216812100841756, 0.28107387868962785, 0.26327129399032834, 0.25904874277566003, 0.18037278911213672, 0.3127693059458322, 0.9843589975539386, 0.24870147523475528, 0.27485511081175407, 0.6890724232779688, 0.35136614123726306, 0.27005879532858057, 0.3513940299528091, 0.16864357295281296, 0.4742213834298762]}}
{"id": "945f110d-4d83-4411-92d7-6f0b7a8daa67", "fitness": 0.7234194125851059, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a focus on constraint handling to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR = 0.7\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds - crucial for performance\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, population[i])\n                trial = np.clip(trial, func.bounds.lb, func.bounds.ub) #Ensure trial vector is within bounds\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                #Greedy selection\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.723 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8c43b90e-df21-4d44-8d52-089158614e27"], "operator": null, "metadata": {"aucs": [0.321540526553482, 0.5857663004358762, 0.7429665240121224, 0.8917090114478334, 0.7916650021783467, 0.8572214327330255, 0.6963966649927937, 0.767764098506203, 0.799983769992061, 0.7708935634696699, 0.8734884017397391, 0.9918451808301606, 0.41459802733873474, 0.7845358162127318, 0.8920342612428145, 0.8609064807658915, 0.6852097601312825, 0.8640679863684335, 0.35789308948909127, 0.517902353261824]}}
{"id": "ff2fd99b-7d4a-41b2-96dc-c66bec929a11", "fitness": 0.4960996495669548, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive crossover rate and probabilistic population update.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        cr_history = []\n\n        while self.budget > 0:\n            # Self-Adaptive Crossover Rate\n            if cr_history:\n                CR = np.mean(cr_history)\n            else:\n                CR = 0.5\n\n            CR = np.clip(CR, 0.1, 0.9)  # Ensure CR stays within bounds\n            cr_history = []\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f = func(trial)\n                self.budget -= 1\n\n                # Probabilistic Update\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n                    cr_history.append(1) # Success\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                else:\n                    cr_history.append(0) # Failure\n\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.496 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2e14c7fe-0e4d-47c4-a6df-815b88bc8aac"], "operator": null, "metadata": {"aucs": [0.16196042927022958, 0.20817678867322353, 0.502109973189597, 0.5893291830853955, 0.40027736072346687, 0.7721752795665087, 0.35521769119977475, 0.48388499617593583, 0.6310486688822124, 0.21853471066218444, 0.40327478373968817, 0.9938583374482314, 0.27574648229923193, 0.4393161510513006, 0.7821190949464529, 0.7967859333884402, 0.36979998284280513, 0.8083576044035234, 0.22810718307120648, 0.5019123567196884]}}
{"id": "f70ea6d5-ee49-43f7-82d2-553e10ae35e9", "fitness": 0.6914317807967476, "name": "AdaptiveDE", "description": "Simplified Differential Evolution with linearly decreasing crossover rate and probabilistic replacement for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        while self.budget > 0:\n            CR = 0.9 * (self.budget / 10000) # Linearly decreasing CR\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n                \n                f = func(trial)\n                self.budget -= 1\n\n                # Probabilistic replacement\n                if f < fitness[i] or np.random.rand() < 0.05:\n                    fitness[i] = f\n                    population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                if self.budget <= 0:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.691 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2e14c7fe-0e4d-47c4-a6df-815b88bc8aac"], "operator": null, "metadata": {"aucs": [0.2411929928653166, 0.5584906195350552, 0.6769183750647216, 0.8992190502796851, 0.7802505948257159, 0.8520485756541902, 0.7249104445041802, 0.6706497316297599, 0.8184870003176704, 0.7067301523962564, 0.8594566383296723, 0.9915473677387089, 0.3124510307136116, 0.7562371223523827, 0.9338754280116703, 0.8516506784986007, 0.5576975031965661, 0.8928027955300293, 0.21999456385974125, 0.5240249506314172]}}
{"id": "3c93a098-6682-4fa7-9b97-764a8c2a9819", "fitness": 0.5431514816005409, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a decaying crossover rate and stochastic tournament selection.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.CR_decay_rate = 0.999\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        \n        # Initialize population within bounds\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        CR = 0.9  # Initial crossover rate\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = population[idxs]\n                mutant = x1 + self.F * (x2 - x3)\n                \n                # Ensure mutant stays within bounds\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover (Binomial)\n                cross_points = np.random.rand(self.dim) < CR\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n\n                # Tournament selection (stochastic - compare with a random individual)\n                opponent_idx = np.random.randint(self.pop_size)\n                if f < fitness[opponent_idx]:\n                    fitness[i] = f\n                    population[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                else: # Keep original member if new one is not better than random individual\n                    fitness[i] = fitness[i]\n                    population[i] = population[i]\n\n                if self.budget <= 0:\n                    break\n            \n            CR *= self.CR_decay_rate # Decay CR over time.\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.543 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8c43b90e-df21-4d44-8d52-089158614e27"], "operator": null, "metadata": {"aucs": [0.20971967106467304, 0.38810468511360685, 0.485317900513199, 0.7609010407215605, 0.526097063952172, 0.6315899101817668, 0.44932359242762765, 0.46945948238197344, 0.5026587107879408, 0.4537442954487416, 0.7115029585411741, 0.9978722651568123, 0.31392984314399874, 0.4790783086575836, 0.8622163385299346, 0.5966398804594686, 0.42941420110345085, 0.682577285569177, 0.4044232826494013, 0.5084589156065535]}}
