{"id": "682d0c1f-348c-4c34-b75b-865ccd9abdcd", "fitness": 0.164290789594624, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Archive and stochastic ranking for constraint handling, combined with a restart strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, F=0.5, Cr=0.9, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.F = F\n        self.Cr = Cr\n        self.archive_size = archive_size\n        self.archive = []\n        self.lb = -5.0\n        self.ub = 5.0\n        self.restart_trigger = 100  # Evaluations without improvement before restart\n\n    def __call__(self, func):\n        self.func = func  # Store the function\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n        self.archive = []\n        self.no_improvement_counter = 0\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                while a == i or b == i or c == i:\n                    a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n\n                mutant = self.pop[a] + self.F * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = self.pop[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.fitness[i] = f\n                    self.pop[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.no_improvement_counter = 0  # Reset counter\n                    else:\n                        self.no_improvement_counter += 1 # Increment counter\n                else:\n                     self.no_improvement_counter += 1\n                     if len(self.archive) < self.archive_size:\n                         self.archive.append(self.pop[i].copy())\n                     else:\n                         idx = np.random.randint(0,self.archive_size)\n                         self.archive[idx] = self.pop[i].copy()\n\n            # Restart strategy\n            if self.no_improvement_counter > self.restart_trigger:\n                self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.pop])\n                self.evals += self.pop_size\n                self.no_improvement_counter = 0  # Reset counter\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.164 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.11154980791189062, 0.18916022620111506, 0.27751091432064234, 0.24323299953947208, 0]}}
{"id": "1397b1e1-451d-4562-b004-1d31da8605e9", "fitness": 0.6493584126471788, "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution strategy that adjusts its parameters based on the observed performance and explores the search space efficiently by using a combination of global and local search strategies.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.Cr = Cr # Crossover rate\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.zeros(self.pop_size)\n        for i in range(self.pop_size):\n            self.fitness[i] = func(self.pop[i])\n            self.eval_count += 1\n            if self.fitness[i] < self.f_opt:\n                self.f_opt = self.fitness[i]\n                self.x_opt = self.pop[i]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = self.pop[np.random.choice(idxs, 3, replace=False)]\n            mutated_pop[i] = np.clip(a + self.F * (b - c), -5.0, 5.0)\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < self.Cr or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = self.pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        for i in range(self.pop_size):\n            f = func(crossed_pop[i])\n            self.eval_count += 1\n            if f < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = f\n                if f < self.f_opt:\n                    self.f_opt = f\n                    self.x_opt = crossed_pop[i]\n            # Adaptive F and Cr\n            if np.random.rand() < 0.1:\n               self.F = np.random.uniform(0.1, 0.9)\n               self.Cr = np.random.uniform(0.1, 0.9)\n                \n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.649 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.2248916838465661, 0.5469635405257391, 0.5875995201328075, 0.843847489847168, 0.6642895510364497, 0.7485300586112974, 0.663895511189986, 0.5606891447471984, 0.6972638911763104, 0.6735058116530135, 0.7677524531862893, 0.998859576326021, 0.35524066896856743, 0.6839168621907149, 0.8920207065385968, 0.7733063297228033, 0.5689145647334284, 0.8021462755573402, 0.35715847234945464, 0.5763761406038221]}}
{"id": "2e439e8c-480a-44cb-8cdc-01b74331cb30", "fitness": 0.3864752638654849, "name": "AdaptiveDE", "description": "An adaptive Differential Evolution strategy with self-adaptive parameters and a local search component.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, local_search_prob=0.1, local_search_radius=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.local_search_prob = local_search_prob\n        self.local_search_radius = local_search_radius\n\n    def __call__(self, func):\n        # Initialization\n        population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        best_index = np.argmin(fitness)\n        self.f_opt = fitness[best_index]\n        self.x_opt = population[best_index]\n\n        # Adaptive parameters\n        adaptive_F = self.F * np.ones(self.pop_size)\n        adaptive_CR = self.CR * np.ones(self.pop_size)\n\n        # Optimization loop\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Adaptive parameter adjustment\n                if np.random.rand() < 0.1:  # Adjust F occasionally\n                    adaptive_F[i] = np.random.uniform(0.1, 0.9)\n                if np.random.rand() < 0.1:  # Adjust CR occasionally\n                    adaptive_CR[i] = np.random.uniform(0.1, 1.0)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                mutant = population[i] + adaptive_F[i] * (x_r2 - x_r3)\n                mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_CR[i]\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Local Search\n                if np.random.rand() < self.local_search_prob:\n                   trial = np.clip(trial + np.random.uniform(-self.local_search_radius, self.local_search_radius, size=self.dim), func.bounds.lb, func.bounds.ub)\n\n                # Evaluation\n                f = func(trial)\n                self.budget -= 1\n                if f < fitness[i]:\n                    fitness[i] = f\n                    population[i] = trial\n\n                    # Update best solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n            \n            best_index = np.argmin(fitness)\n            if fitness[best_index] < self.f_opt:\n                self.f_opt = fitness[best_index]\n                self.x_opt = population[best_index]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.386 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.1488795816918399, 0.25472227137434833, 0.3690394745945811, 0.5103402934315129, 0.30143355406648853, 0.4075581989884812, 0.2945029022585127, 0.32774377137378863, 0.30129134336286034, 0.1822458238844079, 0.3827857622991262, 0.9988933822523755, 0.3261298144351449, 0.3070251064673668, 0.7410650293809102, 0.38403675806017146, 0.3457581796321556, 0.4644590955584492, 0.18994523955730236, 0.49164969463987396]}}
{"id": "4c64941e-0158-4f52-b222-fd1ab5d0d605", "fitness": 0.6478077397606328, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with a population-based archive for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=100, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.archive_fitness = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        for i in range(self.dim):\n            if vec[i] < func.bounds.lb[i]:\n                vec[i] = func.bounds.lb[i]\n            elif vec[i] > func.bounds.ub[i]:\n                vec[i] = func.bounds.ub[i]\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n                v = x_1 + self.F * (x_2 - x_3)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.zeros(self.dim)\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == j_rand:\n                        u[j] = v[j]\n                    else:\n                        u[j] = self.population[i][j]\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                        self.archive_fitness.append(f_u)\n                    else:\n                        # Replace a random element in the archive\n                        rand_index = np.random.randint(self.archive_size)\n                        self.archive[rand_index] = self.population[i].copy()\n                        self.archive_fitness[rand_index] = f_u\n                        \n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.648 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.23897720368098285, 0.5378579320474141, 0.6597233522164211, 0.8444833301736906, 0.7144426947838843, 0.7864073097284443, 0.6036011149202719, 0.6125684536516832, 0.7131216209847044, 0.6658049363341483, 0.7730482615800951, 0.9968218665890977, 0.3803158847696134, 0.6374053751344075, 0.9071445734282939, 0.7654552111938264, 0.5352931435144774, 0.8280047179957756, 0.22622811692189748, 0.5294496955635277]}}
{"id": "c8084b21-061d-4a2b-a801-03214365460b", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with Archive and adaptive parameters, focusing on mutation and crossover.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is None else 10 * dim\n        self.archive_size = archive_size\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n        self.archive = []\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Adaptive parameters\n                F = np.random.uniform(0.3, 0.9)\n                Cr = np.random.uniform(0.1, 0.9)\n\n                # Mutation\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.pop[a] + F * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = self.pop[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < Cr or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.fitness[i] = f\n                    self.pop[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                else:\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    elif np.random.rand() < 0.1:  # Replace archive occasionally\n                        idx = np.random.randint(0, self.archive_size)\n                        self.archive[idx] = self.pop[i].copy()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: 'NoneType' object cannot be interpreted as an integer.", "error": "", "parent_ids": ["682d0c1f-348c-4c34-b75b-865ccd9abdcd"], "operator": null, "metadata": {}}
{"id": "1415bb46-54e2-4efa-a131-bf0f3e9ef2a2", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive F and Cr, and a simplified restart mechanism based on stagnation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is None else 10 * dim\n        self.archive_size = archive_size\n        self.archive = []\n        self.lb = -5.0\n        self.ub = 5.0\n        self.restart_trigger = 50  # Evaluations without improvement before restart\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n        self.no_improvement_counter = 0\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Adaptive F and Cr\n                F = np.random.normal(0.5, 0.3)\n                F = np.clip(F, 0.1, 1.0)\n                Cr = np.random.normal(0.9, 0.2)\n                Cr = np.clip(Cr, 0.1, 1.0)\n\n                # Mutation\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.pop[a] + F * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < Cr, mutant, self.pop[i])\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.fitness[i] = f\n                    self.pop[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.no_improvement_counter = 0  # Reset counter\n                    else:\n                        self.no_improvement_counter += 1\n                elif len(self.archive) < self.archive_size:\n                    self.archive.append(self.pop[i].copy())\n                else:\n                    idx = np.random.randint(0, self.archive_size)\n                    self.archive[idx] = self.pop[i].copy()\n\n\n            # Restart strategy: simplified, triggered by stagnation\n            if self.no_improvement_counter > self.restart_trigger:\n                self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.pop])\n                self.evals += self.pop_size\n                self.no_improvement_counter = 0\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: 'NoneType' object cannot be interpreted as an integer.", "error": "", "parent_ids": ["682d0c1f-348c-4c34-b75b-865ccd9abdcd"], "operator": null, "metadata": {}}
{"id": "6e308dc4-6ac9-4202-8f51-c337bccb4721", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with dynamic F/Cr adjustment and population diversity check to avoid stagnation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.F = 0.5\n        self.Cr = 0.9\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            mutated_pop[i] = np.clip(a + self.F * (b - c), -5.0, 5.0)\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            cross_mask = np.random.rand(self.dim) < self.Cr\n            j_rand = np.random.randint(self.dim)\n            cross_mask[j_rand] = True  # Ensure at least one element is crossed over\n            crossed_pop[i] = np.where(cross_mask, mutated_pop[i], self.pop[i])\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.eval_count += self.pop_size\n\n        improved = new_fitness < self.fitness\n        self.pop[improved] = crossed_pop[improved]\n        self.fitness[improved] = new_fitness[improved]\n\n        if np.min(self.fitness) < self.f_opt:\n            self.f_opt = np.min(self.fitness)\n            self.x_opt = self.pop[np.argmin(self.fitness)]\n            \n        # Adaptive F and Cr - Simplified and applied more frequently\n        self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n        self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n    def check_diversity(self):\n        # Reset population if diversity is too low\n        if np.std(self.fitness) < 1e-6:  #Stagnation threshold\n            lb, ub = -5.0, 5.0  # Assuming func.bounds is not consistently available.\n            self.pop = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n            #Recalculate fitness of reset population\n            #Fitness needs to be recalculated as the population is reinitialized\n            #This handles cases where bounds are not defined correctly, avoiding errors\n            #when accessing func.bounds.lb/ub\n            self.fitness = np.array([func(x) for x in self.pop]) #Recalculating fitness\n            self.eval_count += self.pop_size\n            self.f_opt = np.min(self.fitness)\n            self.x_opt = self.pop[np.argmin(self.fitness)]\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n            if self.eval_count < self.budget: # only check if budget allows\n              self.check_diversity()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "An exception occurred: name 'func' is not defined.", "error": "", "parent_ids": ["1397b1e1-451d-4562-b004-1d31da8605e9"], "operator": null, "metadata": {}}
{"id": "86b75123-6b16-4d35-9521-58791640fc44", "fitness": 0.14447019185968968, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and periodic population rejuvenation for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, F=0.5, Cr=0.9, archive_size=5, restart_trigger=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.F = F\n        self.Cr = Cr\n        self.archive_size = archive_size\n        self.archive = []\n        self.lb = -5.0\n        self.ub = 5.0\n        self.restart_trigger = restart_trigger  # Evaluations without improvement before restart\n        self.no_improvement_counter = 0\n        self.f_opt = np.Inf\n        self.x_opt = None\n\n    def __call__(self, func):\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n        self.archive = []\n        self.no_improvement_counter = 0\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.pop[idxs[0]] + self.F * (self.pop[idxs[1]] - self.pop[idxs[2]])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = self.pop[i].copy()\n                crossover_mask = np.random.rand(self.dim) < self.Cr\n                trial[crossover_mask] = mutant[crossover_mask]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.fitness[i] = f\n                    self.pop[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                        self.no_improvement_counter = 0\n                    else:\n                        self.no_improvement_counter += 1\n                else:\n                    self.no_improvement_counter += 1\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    else:\n                        idx = np.random.randint(0, self.archive_size)\n                        self.archive[idx] = self.pop[i].copy()\n            # Rejuvenation\n            if self.no_improvement_counter > self.restart_trigger:\n                self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.pop])\n                self.evals += self.pop_size\n                self.no_improvement_counter = 0\n                self.f_opt = np.min(self.fitness)\n                self.x_opt = self.pop[np.argmin(self.fitness)]\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.144 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["682d0c1f-348c-4c34-b75b-865ccd9abdcd"], "operator": null, "metadata": {"aucs": [0.11227560393841485, 0.20000656338643552, 0.26559860011390835, 0]}}
{"id": "46680c2a-c187-49a7-8cdf-10d542ae03fc", "fitness": 0.7310480426858761, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with adaptive F and Cr and reduced parameter count for better generalization.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Initial mutation factor\n        self.Cr = 0.9 # Initial Crossover rate\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            mutated_pop[i] = np.clip(a + self.F * (b - c), -5.0, 5.0)\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            cross_mask = np.random.rand(self.dim) < self.Cr\n            j_rand = np.random.randint(self.dim)\n            cross_mask[j_rand] = True  # Ensure at least one element is crossed over\n            crossed_pop[i] = np.where(cross_mask, mutated_pop[i], self.pop[i])\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.eval_count += self.pop_size\n\n        improvement = new_fitness < self.fitness\n        self.pop[improvement] = crossed_pop[improvement]\n        self.fitness[improvement] = new_fitness[improvement]\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.pop[best_idx]\n        \n        # Adaptive F and Cr\n        self.F = 0.5 + 0.3 * np.random.randn()\n        self.Cr = 0.9 + 0.2 * np.random.randn()\n        self.F = np.clip(self.F, 0.1, 0.9)\n        self.Cr = np.clip(self.Cr, 0.1, 1.0)\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.731 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1397b1e1-451d-4562-b004-1d31da8605e9"], "operator": null, "metadata": {"aucs": [0.404025157876546, 0.717286156832603, 0.6818972844312493, 0.8656948261721679, 0.7868704350182827, 0.7848160870503016, 0.6801502893366449, 0.6884003507581999, 0.7418817313359085, 0.7116605629407402, 0.8374305960235316, 0.9801320431376173, 0.6522441037737807, 0.7246587078185952, 0.9033726769959423, 0.7713749381114932, 0.6529774349455064, 0.8346822629225419, 0.5304592629354778, 0.6709459453003905]}}
{"id": "33e2b36c-5cda-49ba-8a88-9e780f774541", "fitness": 0.4988467157436608, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with adaptive mutation factor F and crossover rate Cr based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.Cr = Cr # Crossover rate\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            mutated_pop[i] = np.clip(a + self.F * (b - c), -5.0, 5.0)\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            cross_mask = np.random.rand(self.dim) < self.Cr\n            crossed_pop[i] = np.where(cross_mask, mutated_pop[i], self.pop[i])\n            if np.random.rand() < 0.05:  # Ensure at least one parameter is changed\n                j = np.random.randint(self.dim)\n                crossed_pop[i, j] = mutated_pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.eval_count += self.pop_size\n\n        improvement = new_fitness < self.fitness\n        self.pop = np.where(improvement[:, None], crossed_pop, self.pop)\n        self.fitness = np.where(improvement, new_fitness, self.fitness)\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        \n        # Adaptive F and Cr based on successful updates\n        success_rate = np.mean(improvement)\n        if success_rate > 0.2:\n            self.F = np.clip(self.F + 0.05, 0.1, 0.9)\n            self.Cr = np.clip(self.Cr + 0.05, 0.1, 0.9)\n        elif success_rate < 0.1:\n            self.F = np.clip(self.F - 0.05, 0.1, 0.9)\n            self.Cr = np.clip(self.Cr - 0.05, 0.1, 0.9)\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.499 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1397b1e1-451d-4562-b004-1d31da8605e9"], "operator": null, "metadata": {"aucs": [0.1618399172904479, 0.21594323860600706, 0.4822293310108613, 0.768450286889222, 0.5006726064233308, 0.5573555983428806, 0.39166955036218987, 0.43431810768566215, 0.4863167145381778, 0.46068894441979846, 0.7135870807915501, 0.9994149893691371, 0.27059700456412916, 0.3980030984515297, 0.7702672165795839, 0.5722442838814878, 0.3997654863683503, 0.6663050901584135, 0.22420840434086642, 0.5030573647995915]}}
{"id": "c263e745-7442-425e-9cb3-5d0a645fd0b8", "fitness": 0.6927087271372103, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and adaptive mutation factor, focusing on efficiency and reduced complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=50, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptive Mutation Factor\n                F = np.random.uniform(0.1, 0.9)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n                v = x_1 + F * (x_2 - x_3)\n                \n                # Add archive element with small probability\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    arch_idx = np.random.randint(len(self.archive))\n                    v = x_1 + F * (x_2 - self.archive[arch_idx])\n\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        # Replace a random element in the archive\n                        rand_index = np.random.randint(self.archive_size)\n                        self.archive[rand_index] = self.population[i].copy()\n                        \n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.693 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c64941e-0158-4f52-b222-fd1ab5d0d605"], "operator": null, "metadata": {"aucs": [0.247621916027981, 0.6342765610643073, 0.6714123986927638, 0.85952325127664, 0.7947997916536874, 0.7936713144942421, 0.6764776406707531, 0.645749549328112, 0.7601803427275549, 0.6779420489194254, 0.8530907263952406, 0.9991552016800873, 0.3682370911209737, 0.7153870588837038, 0.8794039805166619, 0.7982355165515846, 0.5854671609735959, 0.8527378903291959, 0.41488308193154544, 0.6259220195061501]}}
{"id": "99e458b2-8eba-41c6-b79f-99464546f61c", "fitness": 0.6372969361560032, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and adaptive mutation factor to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptive Mutation Factor\n                F = np.random.uniform(0.1, 0.9)\n\n                # Mutation\n                candidates = list(range(self.pop_size))\n                candidates.remove(i)\n                if len(self.archive) > 0:\n                    use_archive = np.random.rand() < 0.1  # 10% chance to use archive\n                    if use_archive:\n                         idx_archive = np.random.randint(len(self.archive))\n                         x_archive = self.archive[idx_archive]\n                         \n                         idxs = np.random.choice(candidates, 2, replace=False)\n                         x_1, x_2 = self.population[idxs]\n                         v = self.population[i] + F * (x_archive - self.population[i]) + F * (x_1 - x_2)\n\n                    else:\n                         idxs = np.random.choice(candidates, 3, replace=False)\n                         x_1, x_2, x_3 = self.population[idxs]\n                         v = x_1 + F * (x_2 - x_3)\n                else:\n                    idxs = np.random.choice(candidates, 3, replace=False)\n                    x_1, x_2, x_3 = self.population[idxs]\n                    v = x_1 + F * (x_2 - x_3)\n                \n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        # Replace a random element in the archive\n                        rand_index = np.random.randint(self.archive_size)\n                        self.archive[rand_index] = self.population[i].copy()\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.637 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c64941e-0158-4f52-b222-fd1ab5d0d605"], "operator": null, "metadata": {"aucs": [0.23708259146680655, 0.4491622608525879, 0.5847726503401558, 0.8572647568067989, 0.7155254135978881, 0.7701079052018515, 0.6253394640458334, 0.6118056117784163, 0.6812324259476681, 0.6142688534696549, 0.7827947326380096, 0.9964587237489475, 0.335095169305789, 0.714122990367041, 0.8432858493643951, 0.773849336217591, 0.5568623062478882, 0.8023774673232271, 0.27420860360405297, 0.5203216107954602]}}
{"id": "e05b5b63-e63b-4ccf-817a-3114065ee696", "fitness": 0.7025438936104652, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a smaller archive, adaptive mutation factor, and direct archive participation in mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n\n                # Archive participation\n                if len(self.archive) > 0 and np.random.rand() < 0.2:\n                    x_3 = self.archive[np.random.randint(len(self.archive))]\n                else:\n                    idxs = np.random.choice(self.pop_size, 1, replace=False)\n                    x_3 = self.population[idxs[0]] #prevent x3=x1 or x3=x2\n\n\n                F = self.F * (0.5 + np.random.rand()) # Adaptive F\n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i]) # current-to-best\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        if np.random.rand() < 0.1:\n                            rand_index = np.random.randint(self.archive_size)\n                            self.archive[rand_index] = self.population[i].copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.703 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c64941e-0158-4f52-b222-fd1ab5d0d605"], "operator": null, "metadata": {"aucs": [0.30153149819617886, 0.6823274475855121, 0.7852291325441595, 0.9070428495762174, 0.7903559720831457, 0.8500750099365442, 0.6114762437320699, 0.7493395777038101, 0.8291041318357211, 0.2465954330700343, 0.9007185725276652, 0.9968334314930231, 0.5016289894231163, 0.7965474202490761, 0.9484749719413493, 0.8458409484523408, 0.6891392746211795, 0.8944668473923967, 0.2207823302958849, 0.5033677895498774]}}
{"id": "f800f33d-c572-4474-a6f5-3a367780fec2", "fitness": 0.62735794433879, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and dynamic F/CR adaptation for better exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.7  # Initial crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        return np.clip(vec, func.bounds.lb, func.bounds.ub)\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptive F and CR\n                F = np.random.normal(self.F, 0.1)\n                F = np.clip(F, 0.1, 1.0)\n                CR = np.random.normal(self.CR, 0.1)\n                CR = np.clip(CR, 0.1, 1.0)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n                v = x_1 + F * (x_2 - x_3)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.random.rand(self.dim) < CR\n                u = v * u + self.population[i] * ~u\n                u = self.ensure_bounds(u, func)\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        rand_index = np.random.randint(self.archive_size)\n                        self.archive[rand_index] = self.population[i].copy()\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.627 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c64941e-0158-4f52-b222-fd1ab5d0d605"], "operator": null, "metadata": {"aucs": [0.2139477451252314, 0.40126588235120364, 0.6188371669413708, 0.8226276204665851, 0.6796934144115354, 0.7594511127305928, 0.5868608412704226, 0.5737291523421273, 0.6838699637243366, 0.6419834228559629, 0.819002818230042, 0.997674960154968, 0.36552995240617814, 0.6472665992580062, 0.8998351068871111, 0.7510689787573841, 0.5229222237761133, 0.8150207180934678, 0.2248891272558421, 0.52168207973732]}}
{"id": "07d417ff-10ba-4057-af26-29cec1e2699f", "fitness": 0.6660983505057189, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with dynamic parameter adaptation based on population diversity and a reduced set of parameters.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.Cr = 0.9 # Crossover rate - fixed\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            mutated_pop[i] = np.clip(a + self.F * (b - c), -5.0, 5.0)\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            cross_points = np.random.rand(self.dim) < self.Cr\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            crossed_pop[i] = np.where(cross_points, mutated_pop[i], self.pop[i])\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.eval_count += self.pop_size\n\n        improved = new_fitness < self.fitness\n        self.pop[improved] = crossed_pop[improved]\n        self.fitness[improved] = new_fitness[improved]\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.pop[best_idx]\n\n        # Adaptive F\n        if np.std(self.fitness) > 0.01:\n            self.F = 0.5 + 0.3 * np.random.rand() # adjust F based on population diversity\n        else:\n            self.F = 0.5 # Keep F at the base value\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.666 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1397b1e1-451d-4562-b004-1d31da8605e9"], "operator": null, "metadata": {"aucs": [0.25268091169568496, 0.617352484141253, 0.6618096561470718, 0.8455022717807458, 0.6934832574200345, 0.774162728747342, 0.5856492701815064, 0.6132067722073372, 0.7050556612791176, 0.61813148865911, 0.8063338690769375, 0.9988207034750295, 0.577587246682024, 0.7043055082457046, 0.9168984496574226, 0.7309250578470811, 0.5899508780218514, 0.8354048320042371, 0.27590216420715674, 0.518803798637732]}}
{"id": "7bee91d7-9b6e-4e0f-b1ba-2e409dbb4130", "fitness": 0.7145543802568136, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and adaptive parameters, removing stochastic ranking.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.archive_size = archive_size\n        self.archive = []\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5  # Initial value for F\n        self.Cr = 0.9 # Initial value for Cr\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Adaptive parameter update\n                self.F = np.random.normal(0.5, 0.3)  # Adjust F dynamically\n                self.F = np.clip(self.F, 0.1, 1.0)\n\n                self.Cr = np.random.normal(0.9, 0.1)  # Adjust Cr dynamically\n                self.Cr = np.clip(self.Cr, 0.1, 1.0)\n                \n                # Mutation\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.pop[a] + self.F * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = self.pop[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.fitness[i] = f\n                    self.pop[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                else:\n                    # Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    else:\n                        idx = np.random.randint(0, self.archive_size)\n                        self.archive[idx] = self.pop[i].copy()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.715 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["682d0c1f-348c-4c34-b75b-865ccd9abdcd"], "operator": null, "metadata": {"aucs": [0.4293174601971438, 0.6710288741730606, 0.6551215241042889, 0.8626332672328739, 0.754422599806152, 0.7846623645223768, 0.6411382381603483, 0.6682464329225896, 0.7274155844647852, 0.6462714671183619, 0.8689113381261291, 0.9961587012856444, 0.6473797444899647, 0.7438420089829345, 0.8693875553301474, 0.7895187613030441, 0.6440788129122492, 0.8495800362277754, 0.5163424367259775, 0.5256303970504232]}}
{"id": "fb0d0dab-e7e5-4fd7-a1f0-f3c63624d51a", "fitness": 0.0, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, greedy archive update, and reduced parameter count.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.archive_size = archive_size\n        self.archive = []\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.Cr = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.pop[a] + self.F * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = self.pop[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    # Archive update (greedy)\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    else:\n                        worst_idx = np.argmax([func(x) for x in self.archive])\n                        if self.fitness[i] < func(self.archive[worst_idx]):\n                            self.archive[worst_idx] = self.pop[i].copy()\n                            \n                    self.fitness[i] = f\n                    self.pop[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7bee91d7-9b6e-4e0f-b1ba-2e409dbb4130"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "ff698618-93fe-4a5e-8837-4d185ae2d452", "fitness": 0.5643130660892506, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation and focused exploration around the best solution.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Initial mutation factor\n        self.Cr = 0.9 # Initial Crossover rate\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 2, replace=False)\n            a, b = self.pop[idxs]\n            mutated_pop[i] = np.clip(self.x_opt + self.F * (a - b), -5.0, 5.0) #Exploration around best\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            cross_mask = np.random.rand(self.dim) < self.Cr\n            j_rand = np.random.randint(self.dim)\n            cross_mask[j_rand] = True  # Ensure at least one element is crossed over\n            crossed_pop[i] = np.where(cross_mask, mutated_pop[i], self.pop[i])\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.eval_count += self.pop_size\n\n        improvement = new_fitness < self.fitness\n        self.pop[improvement] = crossed_pop[improvement]\n        self.fitness[improvement] = new_fitness[improvement]\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.pop[best_idx]\n        \n        # Adaptive F and Cr - Simplified\n        self.F = 0.5 + 0.1 * np.random.randn()\n        self.Cr = 0.9 + 0.05 * np.random.randn()\n        self.F = np.clip(self.F, 0.1, 0.9)\n        self.Cr = np.clip(self.Cr, 0.5, 1.0)\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.564 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46680c2a-c187-49a7-8cdf-10d542ae03fc"], "operator": null, "metadata": {"aucs": [0.14017281495205425, 0.9033531269595559, 0.517572055844262, 0.2827550444472381, 0.23352372247744058, 0.9416152564882317, 0.3180095814334297, 0.35250322229742603, 0.9246611288797797, 0.2259862557871155, 0.956462736797264, 0.9984951277614798, 0.24752825741214735, 0.39672338469767887, 0.7522835355213433, 0.9289586238482467, 0.4265519531318438, 0.9557533386173502, 0.2866779946239397, 0.49667415980718244]}}
{"id": "d254a7a3-43f3-43f7-ba11-8cd7cccbe190", "fitness": 0.7300063843499738, "name": "AdaptiveDifferentialEvolution", "description": "Streamlined Adaptive Differential Evolution with simplified parameter adaptation and direct population update.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.Cr = 0.9\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            # Mutation and Crossover\n            mutated_pop = np.zeros_like(self.pop)\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + self.F * (b - c), -5.0, 5.0)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                j_rand = np.random.randint(self.dim)\n                cross_mask[j_rand] = True\n                mutated_pop[i] = np.where(cross_mask, mutated_vector, self.pop[i])\n\n            # Selection\n            new_fitness = np.array([func(x) for x in mutated_pop])\n            self.eval_count += self.pop_size\n\n            improvement = new_fitness < self.fitness\n            self.pop[improvement] = mutated_pop[improvement]\n            self.fitness[improvement] = new_fitness[improvement]\n\n            best_idx = np.argmin(self.fitness)\n            self.f_opt = self.fitness[best_idx]\n            self.x_opt = self.pop[best_idx]\n\n            # Adaptive F and Cr (simplified)\n            self.F = np.clip(np.random.normal(0.5, 0.2), 0.1, 0.9)\n            self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.730 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46680c2a-c187-49a7-8cdf-10d542ae03fc"], "operator": null, "metadata": {"aucs": [0.38726875205470845, 0.686851703158257, 0.7116247208993101, 0.8941924201214491, 0.7577960002058625, 0.7939188113293381, 0.7029117727418328, 0.6869581541841727, 0.7581437355636041, 0.6668724831639834, 0.8735888863194161, 0.9995880675422146, 0.5772706764448567, 0.759464697883619, 0.9261999011405665, 0.7738115935706946, 0.6328137945304673, 0.8339485870234669, 0.646638597255213, 0.5302643318664433]}}
{"id": "de631094-0a98-49ff-8131-70cbda4454c0", "fitness": 0.6195406571210815, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive crossover rate and focused mutation strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptive Mutation Factor and Crossover Rate\n                F = np.random.uniform(0.1, 0.9)\n                CR = np.random.uniform(0.1, 0.9)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n                v = x_1 + F * (x_2 - x_3)\n\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.620 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c263e745-7442-425e-9cb3-5d0a645fd0b8"], "operator": null, "metadata": {"aucs": [0.19037768492609608, 0.3103239467645842, 0.5815158039299394, 0.8240972379199947, 0.6835317603025117, 0.7481763911954669, 0.5297801513488604, 0.5703009912022055, 0.7129694817715291, 0.6069748244957468, 0.8261083575483884, 0.9878401574936206, 0.35874020090888603, 0.6837167324084972, 0.8295008180425416, 0.7745764826131118, 0.5391177067714301, 0.8181901665285602, 0.3044372896620485, 0.5105369565876117]}}
{"id": "4c04034b-6a0a-4e54-b501-c113ac19347a", "fitness": 0.6782201767602986, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation based on population fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Initial mutation factor\n        self.Cr = 0.9 # Initial Crossover rate\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            mutated_pop[i] = np.clip(a + self.F * (b - c), -5.0, 5.0)\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            cross_mask = np.random.rand(self.dim) < self.Cr\n            j_rand = np.random.randint(self.dim)\n            cross_mask[j_rand] = True  # Ensure at least one element is crossed over\n            crossed_pop[i] = np.where(cross_mask, mutated_pop[i], self.pop[i])\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.eval_count += self.pop_size\n\n        improvement = new_fitness < self.fitness\n        self.pop[improvement] = crossed_pop[improvement]\n        self.fitness[improvement] = new_fitness[improvement]\n\n        best_idx = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_idx]\n        self.x_opt = self.pop[best_idx]\n        \n        # Adaptive F and Cr based on fitness variance\n        fitness_std = np.std(self.fitness)\n        self.F = np.clip(0.5 + 0.3 * (1 - fitness_std / np.abs(self.f_opt)), 0.1, 0.9)\n        self.Cr = np.clip(0.9 + 0.2 * (fitness_std / np.abs(self.f_opt)), 0.1, 1.0)\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.678 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46680c2a-c187-49a7-8cdf-10d542ae03fc"], "operator": null, "metadata": {"aucs": [0.27822782184076955, 0.23269801155814474, 0.6720201116632737, 0.8496668190475016, 0.7611178331151136, 0.8250424996112291, 0.5399183421138988, 0.6450120350482271, 0.7228754386546157, 0.618124512239038, 0.853421074680881, 0.9951425176930687, 0.7658565427074069, 0.7734264092991849, 0.8943208842517543, 0.7811377942532672, 0.6639375891986616, 0.8208133229997967, 0.34674941217753086, 0.5248945630526072]}}
{"id": "5d74b027-721f-48ae-ba27-3f7b2acafe52", "fitness": 0.6861069732959976, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and a smaller population size.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 5 * dim  # Reduced population size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5  # Initial value for F\n        self.Cr = 0.9 # Initial value for Cr\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Self-adaptive parameter update (simplified)\n                if np.random.rand() < 0.1:\n                    self.F = np.random.normal(0.5, 0.3)\n                    self.F = np.clip(self.F, 0.1, 1.0)\n\n                if np.random.rand() < 0.1:\n                    self.Cr = np.random.normal(0.9, 0.1)\n                    self.Cr = np.clip(self.Cr, 0.1, 1.0)\n                \n                # Mutation\n                a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = self.pop[a] + self.F * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = self.pop[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.fitness[i] = f\n                    self.pop[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.686 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7bee91d7-9b6e-4e0f-b1ba-2e409dbb4130"], "operator": null, "metadata": {"aucs": [0.22659545186002616, 0.354419781694594, 0.7028979395097201, 0.922523015788704, 0.83756571195277, 0.8999917196764806, 0.8158021775823455, 0.46134320546265783, 0.8785831745267118, 0.7659458362093452, 0.9226779064004957, 0.9989744101805144, 0.30731117150518483, 0.759564657790499, 0.8080818697877172, 0.8909980054894098, 0.43803292820528184, 0.8556866877929008, 0.3618149639315239, 0.5133288505730695]}}
{"id": "d5e53731-de4f-436a-b078-4a326766bd6e", "fitness": 0.5938440580357409, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation and crossover, focusing on efficiency and exploration by adaptively adjusting mutation strength and crossover probability based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            \n            #Adaptive F and CR based on population diversity\n            std = np.std(self.fitness)\n            self.F = 0.5 + 0.3 * np.exp(-std) # Reduce F when population is diverse, otherwise explore more.\n            self.CR = 0.1 + 0.8 * np.exp(-std) # Reduce CR when population is diverse, otherwise explore more.\n                \n            for i in range(self.pop_size):\n                # Mutation - using only two random individuals and current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                v = self.population[i] + self.F * (x_1 - x_2 + self.x_opt - self.population[i]) # current-to-best\n\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Simple Archive update\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    elif np.random.rand() < 0.1:\n                        self.archive[np.random.randint(self.archive_size)] = u.copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.594 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e05b5b63-e63b-4ccf-817a-3114065ee696"], "operator": null, "metadata": {"aucs": [0.15661904539160132, 0.24559844648884277, 0.7508431758309455, 0.7536562910017579, 0.643138432989971, 0.766061976634762, 0.39209906844980547, 0.6001189003665333, 0.6449194424757769, 0.3910576717861969, 0.7510561211322053, 0.9982468531935702, 0.3252761721381313, 0.6356752280971715, 0.853544295930298, 0.7852556544056661, 0.5237820600242429, 0.8095207873721868, 0.20257338234596411, 0.6478381546591926]}}
{"id": "7b0ed827-9cb6-4fba-acc0-1befcd2aaf5d", "fitness": 0.6899279422762248, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation, adaptive F, archive, and stochastic ranking.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                # Archive participation - less frequent and cleaner\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    x_3 = self.archive[np.random.randint(len(self.archive))]\n\n\n                F = self.F * (0.5 + np.random.rand()) # Adaptive F\n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i]) # current-to-best\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                #Stochastic Ranking\n                if (f_u < self.fitness[i]) or (np.random.rand() < 0.1): \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        if np.random.rand() < 0.1:\n                            rand_index = np.random.randint(self.archive_size)\n                            self.archive[rand_index] = self.population[i].copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.690 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e05b5b63-e63b-4ccf-817a-3114065ee696"], "operator": null, "metadata": {"aucs": [0.24440416214767835, 0.7670787164404604, 0.7895941183333041, 0.9013159525084484, 0.8067646298020064, 0.8572532900817376, 0.35424894739362267, 0.7494987452125887, 0.7898803321777145, 0.2123333838471867, 0.8847959142068802, 0.9997431707652056, 0.2875067022817531, 0.8008142876945025, 0.9447865145195674, 0.8508559470084929, 0.7001277858141794, 0.8837223220176987, 0.46376048413871984, 0.5100734391327477]}}
{"id": "14f3ed61-4fd7-4317-8538-05a2d584803e", "fitness": 0.714862294464418, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with archive and self-adaptive parameters, focusing on intensified local search around the best solution and simplified adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=10, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation: Focus on local search around x_opt\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                # Adaptive F: Simplified adaptation\n                F = self.F + 0.1 * np.random.normal()\n                F = np.clip(F, 0.1, 1.0)\n                \n                v = self.x_opt + F * (x_1 - x_2)  # Simplified mutation around x_opt\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    elif np.random.rand() < 0.1:\n                        rand_index = np.random.randint(self.archive_size)\n                        self.archive[rand_index] = u.copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.715 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e05b5b63-e63b-4ccf-817a-3114065ee696"], "operator": null, "metadata": {"aucs": [0.2601914819984775, 0.20569198142265877, 0.9106560943957127, 0.9559830121523751, 0.9319893008601144, 0.9431905553443926, 0.378283249791728, 0.783986584052391, 0.9235962517331805, 0.9102575227254637, 0.9410338725404913, 0.9967779116570041, 0.43352711830103186, 0.3404238135161195, 0.9641770650526322, 0.9307184133399125, 0.8010937126240134, 0.9537459431442213, 0.22457618222806042, 0.507345822408378]}}
{"id": "6bfcda6b-86b6-412b-a183-5e32ef27aeb0", "fitness": 0.39418849926029, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a combined population-archive mutation strategy.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, archive_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.archive_size = archive_size\n        self.archive = []\n        self.lb = -5.0\n        self.ub = 5.0\n        self.F = 0.5\n        self.Cr = 0.9\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals = self.pop_size\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                    break\n\n                # Mutation\n                candidates = list(range(self.pop_size))\n                candidates.remove(i)\n                a, b = np.random.choice(candidates, 2, replace=False)\n\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    c = self.archive[np.random.randint(len(self.archive))]\n                else:\n                    c_idx = np.random.choice(candidates, 1, replace=False)[0]\n                    c = self.pop[c_idx]\n\n                mutant = self.pop[i] + self.F * (self.pop[a] - self.pop[b])\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                trial = self.pop[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        trial[j] = mutant[j]\n\n                # Evaluation\n                f = func(trial)\n                self.evals += 1\n\n                # Selection\n                if f < self.fitness[i]:\n                    self.fitness[i] = f\n                    self.pop[i] = trial\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n\n                    # Archive update (only if better)\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    else:\n                        idx = np.random.randint(0, self.archive_size)\n                        self.archive[idx] = self.pop[i].copy()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.394 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7bee91d7-9b6e-4e0f-b1ba-2e409dbb4130"], "operator": null, "metadata": {"aucs": [0.15261928836834449, 0.2763825872967417, 0.37086688234645515, 0.4912661146324624, 0.28730865307736253, 0.418751877218533, 0.2951974086265371, 0.32826870025072763, 0.2982463618438159, 0.18756326426544367, 0.5049965158252252, 0.9964227733605089, 0.37660725136517414, 0.29251785157452237, 0.7608333444671798, 0.39146557792401304, 0.3341465604172419, 0.4579618015015744, 0.18152808325435377, 0.4808190875895825]}}
{"id": "951d81b2-03d4-4989-84c6-4f2039ec5701", "fitness": 0.0, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a focus on population diversity through larger population size and dynamic bounds.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=60):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5  # Initial mutation factor\n        self.Cr = 0.9  # Initial Crossover rate\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def mutate(self):\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.pop[idxs]\n            mutated_pop[i] = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutated_pop\n\n    def crossover(self, mutated_pop):\n        crossed_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            cross_mask = np.random.rand(self.dim) < self.Cr\n            # Ensure at least one element is crossed over\n            if not np.any(cross_mask):\n                j_rand = np.random.randint(self.dim)\n                cross_mask[j_rand] = True\n            crossed_pop[i] = np.where(cross_mask, mutated_pop[i], self.pop[i])\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.eval_count += self.pop_size\n\n        improvement = new_fitness < self.fitness\n        self.pop[improvement] = crossed_pop[improvement]\n        self.fitness[improvement] = new_fitness[improvement]\n\n        best_idx = np.argmin(self.fitness)\n        if self.fitness[best_idx] < self.f_opt:\n            self.f_opt = self.fitness[best_idx]\n            self.x_opt = self.pop[best_idx]\n        \n        # Simplified Adaptive F and Cr\n        self.F = 0.5 + 0.2 * np.random.normal()\n        self.Cr = 0.9 + 0.1 * np.random.normal()\n        self.F = np.clip(self.F, 0.1, 0.9)\n        self.Cr = np.clip(self.Cr, 0.1, 1.0)\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = self.mutate()\n            crossed_pop = self.crossover(mutated_pop)\n            self.selection(func, crossed_pop)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["46680c2a-c187-49a7-8cdf-10d542ae03fc"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "3862c8cb-2069-4ec1-be39-71f2046d6355", "fitness": 0.7168871801154022, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-pbest mutation, archive, and adaptive F, prioritizing exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, p=0.1, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.p = p  # percentage of best individuals for pbest\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - current-to-pbest\n                p_best_size = max(int(self.p * self.pop_size), 1)\n                p_best_indices = np.argsort(self.fitness)[:p_best_size]\n                \n                idx_pbest = np.random.choice(p_best_indices)\n                x_pbest = self.population[idx_pbest]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F\n                F = self.F * (0.5 + np.random.rand())\n\n                v = self.population[i] + F * (x_pbest - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        if np.random.rand() < 0.1:\n                            rand_index = np.random.randint(self.archive_size)\n                            self.archive[rand_index] = self.population[i].copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDE scored 0.717 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e05b5b63-e63b-4ccf-817a-3114065ee696"], "operator": null, "metadata": {"aucs": [0.259209494617901, 0.6610172578556673, 0.768354021764591, 0.8970904441066041, 0.8053330106798455, 0.844120343130933, 0.6378250840137041, 0.7519743911106536, 0.8153218638932711, 0.6463162947011318, 0.8836139306724241, 0.9902948170642999, 0.4835664676899424, 0.8015649349630438, 0.9467214545851846, 0.8413071272104335, 0.6644076595166459, 0.8930454210670178, 0.2473418668996309, 0.49931771676511816]}}
{"id": "75a9d2fc-5456-48f4-a270-7135491afb87", "fitness": 0.4548601753281691, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with reduced parameter tuning and focused exploitation using current-to-rand mutation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            mutated_pop = np.zeros_like(self.pop)\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                \n                # Current-to-rand mutation\n                mutated_vector = np.clip(self.pop[i] + self.F * (b - c), -5.0, 5.0)\n\n                cross_mask = np.random.rand(self.dim) < self.Cr\n                mutated_pop[i] = np.where(cross_mask, mutated_vector, self.pop[i])\n\n            new_fitness = np.array([func(x) for x in mutated_pop])\n            self.eval_count += self.pop_size\n\n            improvement = new_fitness < self.fitness\n            self.pop[improvement] = mutated_pop[improvement]\n            self.fitness[improvement] = new_fitness[improvement]\n\n            best_idx = np.argmin(self.fitness)\n            if self.fitness[best_idx] < self.f_opt:\n                self.f_opt = self.fitness[best_idx]\n                self.x_opt = self.pop[best_idx]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.455 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d254a7a3-43f3-43f7-ba11-8cd7cccbe190"], "operator": null, "metadata": {"aucs": [0.1687809612824942, 0.35571976351953705, 0.4223897961077462, 0.6720061919517253, 0.34241815718732904, 0.49763439075305527, 0.29989917743883876, 0.38481301655128186, 0.37331196033244574, 0.19306695966458953, 0.7006587807356583, 0.999742369617259, 0.42269953723403764, 0.3300816965042842, 0.7936656074113554, 0.47490125729477506, 0.36959222429345384, 0.6138316252159632, 0.1913357205593491, 0.4906543129082027]}}
{"id": "a72f879b-5b1e-4b8b-b435-4bee37a45f2f", "fitness": 0.7520423554160875, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified mutation and parameter adaptation for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = 0.5\n        self.Cr = 0.9\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            # Mutation and Crossover\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + self.F * (b - c), -5.0, 5.0)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                mutated_vector = np.where(cross_mask, mutated_vector, self.pop[i]) # simplified crossover\n                \n                f = func(mutated_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = mutated_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = mutated_vector\n\n            # Adaptive F and Cr (simplified)\n            self.F = np.clip(np.random.normal(0.5, 0.2), 0.1, 0.9)\n            self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.752 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d254a7a3-43f3-43f7-ba11-8cd7cccbe190"], "operator": null, "metadata": {"aucs": [0.4603204372028544, 0.7436432022946191, 0.6772704211143674, 0.8927049108245383, 0.8003469601581642, 0.8327628728032482, 0.7252271400230996, 0.7223155910597006, 0.7690302039602356, 0.7379673479043241, 0.8855448838521972, 0.9970026813911637, 0.718315559614247, 0.7649465334318193, 0.9057289857855298, 0.8366924125635244, 0.7388860289518684, 0.8737684748114583, 0.255398543317208, 0.7029739172575855]}}
{"id": "b9fb4d0b-21a2-4068-8246-ac3ca7d31ffa", "fitness": 0.7057032630152216, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation, adaptive F, and stochastic ranking, reducing complexity and promoting exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                F = self.F * (0.5 + np.random.rand()) # Adaptive F\n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i]) # current-to-best\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                #Stochastic Ranking\n                if (f_u < self.fitness[i]) or (np.random.rand() < 0.1): \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.706 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7b0ed827-9cb6-4fba-acc0-1befcd2aaf5d"], "operator": null, "metadata": {"aucs": [0.1425192966244001, 0.7949082220007251, 0.7875188259956157, 0.9014533365376638, 0.8139129082158117, 0.8509383951471085, 0.7303906861633298, 0.7647939394562115, 0.8122073593690127, 0.2113161589006226, 0.8920849190421163, 0.9943968737177715, 0.39359331461246483, 0.7820665855593918, 0.9158638971265902, 0.8198505372693343, 0.6655551733168452, 0.890101782688657, 0.450166316498952, 0.5004267320618081]}}
{"id": "871980f5-21d3-4e77-af5d-fbb320502586", "fitness": 0.7243674146181658, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation, adaptive F, and archive, using a simpler update rule for both population and archive.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                # Archive participation\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    x_3 = self.archive[np.random.randint(len(self.archive))]\n\n                F = self.F * (0.5 + np.random.rand())\n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i])\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    #Update archive: replace a random member\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u.copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.724 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7b0ed827-9cb6-4fba-acc0-1befcd2aaf5d"], "operator": null, "metadata": {"aucs": [0.330970461644015, 0.7233064130393381, 0.7998726459649877, 0.9074078908179297, 0.8143759175288374, 0.8528726489866638, 0.6212657751239226, 0.758653364592683, 0.809511384543038, 0.4548314526160141, 0.8938620574131957, 0.9887975854677515, 0.49339972407222943, 0.7812201103955472, 0.947497630287557, 0.8520878301867523, 0.7065966980428074, 0.8962698697482419, 0.35108449760372173, 0.5034643342880812]}}
{"id": "53173587-cc7e-4670-87f3-22e6f85415d5", "fitness": 0.6218448961522497, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with focus on intensified local search around the best solution using a modified mutation strategy and adaptive parameters.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=10, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation: Focus on local search around x_opt\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                # Adaptive F: Simplified adaptation - simplified further\n                F = np.clip(self.F + 0.1 * np.random.normal(), 0.1, 1.0)\n                \n                # Simplified mutation strategy focusing more on x_opt\n                v = self.x_opt + F * (x_1 - self.population[i])  \n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive - simplified update rule\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    elif np.random.rand() < 0.05:  # Reduced frequency of archive update\n                        rand_index = np.random.randint(self.archive_size)\n                        self.archive[rand_index] = u.copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.622 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["14f3ed61-4fd7-4317-8538-05a2d584803e"], "operator": null, "metadata": {"aucs": [0.36365124373525726, 0.18240186256093127, 0.856375149465675, 0.2593086309623027, 0.9056995474104889, 0.9149096548848635, 0.3588157662651178, 0.8583147046884438, 0.9037325571152903, 0.4879653483922408, 0.9460751248322361, 0.999581059180091, 0.4981803028138715, 0.2876964509555707, 0.7376776032064389, 0.898827913789817, 0.29289580980434216, 0.9350579090821954, 0.27303591913576597, 0.4766953647640524]}}
{"id": "8c685fa0-5e7a-4d3b-9dce-fa985a9e6414", "fitness": 0.3424320814774695, "name": "AdaptiveDE", "description": "Streamlined Adaptive Differential Evolution focusing on current-to-best mutation with simplified adaptive F and CR.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, archive_size=10, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation: current-to-best\n                idxs = np.random.choice(self.pop_size, 1, replace=False) # Only choose one index\n                x_r1 = self.population[idxs[0]]\n                \n                # Adaptive F and CR\n                F = self.F + 0.1 * np.random.normal()\n                F = np.clip(F, 0.1, 1.0)\n                CR = self.CR + 0.1 * np.random.normal()\n                CR = np.clip(CR, 0.1, 1.0)\n\n                v = self.population[i] + F * (self.x_opt - self.population[i]) + F * (x_r1 - self.population[i]) # current-to-best mutation\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.342 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["14f3ed61-4fd7-4317-8538-05a2d584803e"], "operator": null, "metadata": {"aucs": [0.15408912240931183, 0.1884388155850788, 0.3873618893962545, 0.18876369172916796, 0.2313165322095012, 0.4799370531123658, 0.27436446053698527, 0.2661892324198256, 0.2546762022123349, 0.16237831496805122, 0.22027678374899984, 0.9923600160491354, 0.2735554340500821, 0.2590798924544915, 0.8125921073209745, 0.3132818957919641, 0.28638817795499794, 0.3453334278519926, 0.2725992965269489, 0.485659283220926]}}
{"id": "157b5b9a-9479-47da-b144-23bc4ed91bd8", "fitness": 0.6211831045758484, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive CR and F, archive, and stochastic ranking with reduced complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.CR = 0.7  # Initial Crossover rate\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                # Archive participation - less frequent\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    x_3 = self.archive[np.random.randint(len(self.archive))]\n\n                # Adaptive F and CR\n                F = 0.5 * (1 + np.random.rand())\n                CR = np.clip(np.random.normal(self.CR, 0.1), 0.1, 0.9) # Self-adaptive CR\n                \n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i]) # current-to-best\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                #Stochastic Ranking - simplified\n                if (f_u < self.fitness[i]) or (np.random.rand() < 0.1):\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    # Update archive - simplified\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    elif np.random.rand() < 0.1:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n\n                    # Adapt CR based on success\n                    if f_u < self.fitness[i]:\n                        self.CR = 0.9 * self.CR + 0.1 * CR\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.621 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7b0ed827-9cb6-4fba-acc0-1befcd2aaf5d"], "operator": null, "metadata": {"aucs": [0.2208516727210469, 0.21843146196158636, 0.6722393236543532, 0.8525529734918731, 0.7449446143864609, 0.7728343719290164, 0.5352979653377243, 0.6012708380157854, 0.7271657852404596, 0.23351549385651482, 0.8194775827036813, 0.9995795039694403, 0.3158164417286957, 0.6761744285374072, 0.9201113366156016, 0.7822518688331157, 0.5453541495948204, 0.8400046686425106, 0.3092517892452973, 0.6365358210515768]}}
{"id": "74760cac-3e52-44f0-bf96-e122e6ba516f", "fitness": 0.7195638118569537, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive CR and F, current-to-pbest mutation, and immediate update, promoting faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, p=0.1, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.p = p  # percentage of best individuals for pbest\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - current-to-pbest\n                p_best_size = max(int(self.p * self.pop_size), 1)\n                p_best_indices = np.argsort(self.fitness)[:p_best_size]\n                \n                idx_pbest = np.random.choice(p_best_indices)\n                x_pbest = self.population[idx_pbest]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F and CR\n                F = self.F * (0.5 + np.random.rand())\n                CR = self.CR * (0.5 + np.random.rand())\n\n                v = self.population[i] + F * (x_pbest - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.720 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3862c8cb-2069-4ec1-be39-71f2046d6355"], "operator": null, "metadata": {"aucs": [0.2929419784230173, 0.726465077357199, 0.7704395578159063, 0.9070417579703294, 0.8154957493167253, 0.848139770844103, 0.5546139668162949, 0.7470653629256138, 0.8176629805324998, 0.6430055838574513, 0.9019937065199264, 0.9956081175630358, 0.48988997520526467, 0.7657209538871337, 0.9309610615181703, 0.8416112762372943, 0.6998477299124057, 0.8887478435333507, 0.22861026421588992, 0.5254135226874617]}}
{"id": "e964c124-1d7f-43aa-b585-2462cb0d805f", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified parameter adaptation, focusing on exploitation and reduced complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, p=0.1, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.p = p  # percentage of best individuals for pbest\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x)] for x in self.population)\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - current-to-pbest\n                p_best_size = max(int(self.p * self.pop_size), 1)\n                p_best_indices = np.argsort(self.fitness.flatten())[:p_best_size] #flattening to ensure compatibility\n\n                idx_pbest = np.random.choice(p_best_indices)\n                x_pbest = self.population[idx_pbest]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F - Simplified\n                F = self.F + 0.1 * np.random.randn() # Simplified adaptation\n                F = np.clip(F, 0.1, 1.0)\n\n                v = self.population[i] + F * (x_pbest - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "An exception occurred: too many indices for array: array is 0-dimensional, but 1 were indexed.", "error": "", "parent_ids": ["3862c8cb-2069-4ec1-be39-71f2046d6355"], "operator": null, "metadata": {}}
{"id": "58086a46-31f3-426b-88d2-d00a5544f0d1", "fitness": 0.5983097417211912, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-rand mutation, adaptive F, and simplified population management, reducing complexity and promoting exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - current-to-rand\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                \n                # Adaptive F\n                F = self.F * (0.5 + np.random.rand())\n\n                v = self.population[i] + F * (x_r1 - self.population[i]) + F * (x_r2 - x_r3)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDE scored 0.598 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3862c8cb-2069-4ec1-be39-71f2046d6355"], "operator": null, "metadata": {"aucs": [0.2036095268928173, 0.506051315843647, 0.5476310175624006, 0.8574194517507977, 0.6691863951221966, 0.7791821586044334, 0.43393496944555077, 0.6213895810655716, 0.7310728154947939, 0.19346812929293278, 0.8419877317377588, 0.9991042524843728, 0.3734286951828013, 0.6590796351192709, 0.8371147531586995, 0.6946662824775066, 0.4807008213388332, 0.8441765033943739, 0.19900620806382097, 0.49398459039124354]}}
{"id": "853cc53e-a5c5-4215-a0d6-dd0e7f37e0f7", "fitness": 0.6941276304697894, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation and adaptive F using a single random number for crossover and immediate update.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                F = self.F * (0.5 + np.random.rand()) # Adaptive F\n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i]) # current-to-best\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                if np.random.rand() < self.CR:\n                    u = v\n                else:\n                     u = self.population[i]\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]: \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.694 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b9fb4d0b-21a2-4068-8246-ac3ca7d31ffa"], "operator": null, "metadata": {"aucs": [0.25756995020871, 0.8156623674701567, 0.8142144965469332, 0.9253224363372767, 0.8225555884629866, 0.8635906708224934, 0.7224612315937858, 0.7666438875672799, 0.8395175510775563, 0.2612417701187376, 0.9152462977308521, 0.9948406429105702, 0.8248150254816633, 0.36075558894868753, 0.9474623774026952, 0.378920224007002, 0.7699884991520075, 0.8917612722639285, 0.19476810533943834, 0.5152146259530248]}}
{"id": "3d8d4908-e3bd-4dab-998e-9affe55dc151", "fitness": 0.7440333447835545, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with reduced parameter tuning and population updates for efficiency.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F and Cr (simplified - less frequent updates)\n            if self.eval_count % (self.pop_size * 5) == 0: # Update every 5 generations\n                self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.744 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a72f879b-5b1e-4b8b-b435-4bee37a45f2f"], "operator": null, "metadata": {"aucs": [0.4326450505956937, 0.6803324038495314, 0.7147445612490053, 0.9117342089451739, 0.7812533238401039, 0.8081067969043669, 0.7182324648411518, 0.711894389767503, 0.7980606839318858, 0.7611783824643802, 0.9085483888270167, 0.9921195247819096, 0.7815303270663557, 0.7756334692791553, 0.9368352987087337, 0.8154943472062319, 0.7029646144288961, 0.8844014875586863, 0.25027477982800506, 0.5146823915973027]}}
{"id": "19fb73e8-c0da-4f2d-bfdb-7e58c3127585", "fitness": 0.7321577605026046, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive CR and F, current-to-best mutation, and immediate update, further simplified for faster convergence and reduced complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F and CR\n                F = self.F * (0.5 + np.random.rand())\n                CR = self.CR * (0.5 + np.random.rand())\n\n                v = self.population[i] + F * (x_best - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.732 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["74760cac-3e52-44f0-bf96-e122e6ba516f"], "operator": null, "metadata": {"aucs": [0.31280455092865456, 0.7340492132687828, 0.7844217697976399, 0.8993941327318059, 0.8091562211247034, 0.8525031755727293, 0.6622972075521815, 0.7738432324094089, 0.8236961599881867, 0.6570968418432069, 0.8944454086647705, 0.9986553807020738, 0.6155729872772737, 0.7404436662055431, 0.9209552920668339, 0.8501187870169261, 0.7286398078709635, 0.8823454231849681, 0.1990800332265722, 0.5036359186188651]}}
{"id": "8c7af224-0f05-4787-aba5-0f00d9d9a604", "fitness": 0.5921638682221736, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive F and CR, current-to-best mutation, and probabilistic replacement for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                F = 0.5 + 0.5 * np.random.rand() # Adaptive F (0.5, 1)\n                CR = np.random.rand() # Adaptive CR (0, 1)\n                \n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i]) # current-to-best\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                # Probabilistic Replacement\n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                elif np.random.rand() < 0.05:  # 5% chance to replace even if worse\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.592 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b9fb4d0b-21a2-4068-8246-ac3ca7d31ffa"], "operator": null, "metadata": {"aucs": [0.21973961848107415, 0.35441618818192455, 0.5817966487994215, 0.8216849067266133, 0.635796790442645, 0.7396214830544823, 0.41813663101058773, 0.5562035953648825, 0.6451796584865497, 0.5534685354891528, 0.7281414919408737, 0.9966406843449563, 0.31971321831188826, 0.649959982573366, 0.8866264149262045, 0.7263906312624882, 0.49119045430492636, 0.7810232838264035, 0.22751783417134752, 0.510029312743683]}}
{"id": "8de8524b-8f56-4570-addb-248b5ba08dce", "fitness": 0.573360800840029, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-rand mutation, adaptive F, and stochastic ranking, enhancing exploration while reducing parameter tuning complexity.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - Current to rand\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_rand = self.population[idxs]\n\n                F = self.F * (0.5 + np.random.rand()) # Adaptive F\n                v = self.population[i] + F * (x_1 - x_2 + x_rand - self.population[i])\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                #Stochastic Ranking\n                if (f_u < self.fitness[i]) or (np.random.rand() < 0.1): \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.573 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b9fb4d0b-21a2-4068-8246-ac3ca7d31ffa"], "operator": null, "metadata": {"aucs": [0.21387802970049896, 0.5200473195204999, 0.45552491576575305, 0.8264765331439047, 0.6571072068759369, 0.7529438324593885, 0.5438012648837134, 0.5840400510157231, 0.6765001025558353, 0.23269272281321118, 0.7494106754159051, 0.9935812968178969, 0.29829111595205093, 0.6007966396262239, 0.7557008601146147, 0.6075142190184717, 0.47779818775182736, 0.8108098251217516, 0.2161445534524139, 0.4941566647949581]}}
{"id": "c8003434-4d3a-4927-a7a9-4b7dd11e3239", "fitness": 0.7239024962112757, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, adaptive F and CR, and a size-limited archive, focusing on exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                # Archive participation: Simplified condition\n                if self.archive and np.random.rand() < 0.1:\n                    x_3 = self.archive[np.random.randint(len(self.archive))]\n\n                # Adaptive F and CR\n                F = self.F * (0.5 + np.random.rand())\n                CR = self.CR * (0.5 + np.random.rand()) # Adaptive CR\n\n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i])\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    #Update archive: replace a random member\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u.copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.724 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["871980f5-21d3-4e77-af5d-fbb320502586"], "operator": null, "metadata": {"aucs": [0.2539437662789631, 0.7677605706213271, 0.7994520665848928, 0.9138573708724472, 0.8067899140790687, 0.853077153658141, 0.66213870703907, 0.7686292081671964, 0.8137090008100143, 0.2098034171048766, 0.901320917352745, 0.9997445161193739, 0.6908257746657511, 0.7820820108455933, 0.9366492416379304, 0.8593295188936502, 0.7122893459640592, 0.8957585317707372, 0.34000555408623234, 0.510883337673443]}}
{"id": "b782ed00-1d88-41b5-b6ba-3e6e13cc589f", "fitness": 0.6443610803113023, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation and parameter adaptation using a single parameter F for mutation and crossover.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                # Archive participation\n                if len(self.archive) > 0 and np.random.rand() < 0.1:\n                    x_3 = self.archive[np.random.randint(len(self.archive))]\n\n                # Simplified mutation and crossover using F\n                F = self.F * (0.5 + np.random.rand())\n                v = self.population[i] + F * (x_1 - x_2 + self.x_opt - self.population[i])\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover: Apply F directly as crossover probability\n                u = np.where(np.random.rand(self.dim) < F, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    #Update archive: replace a random member\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u.copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.644 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["871980f5-21d3-4e77-af5d-fbb320502586"], "operator": null, "metadata": {"aucs": [0.20712174324192023, 0.5054510033566351, 0.7053187799875551, 0.8553080502238624, 0.7211068421195357, 0.7866807164775389, 0.5386974630149857, 0.6317403309916163, 0.7262993284463926, 0.5579945605507216, 0.8383413054234198, 0.9870701450783255, 0.34370055347374884, 0.6837578074614893, 0.9239893281208278, 0.7924586468268157, 0.5262494702445271, 0.8423799746132508, 0.1999172917460279, 0.5136382648268525]}}
{"id": "ad3a0439-728d-4798-9cbb-8b58b5d23272", "fitness": 0.272204713404708, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-pbest mutation and adaptive F, using a scaling factor for mutation to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, p=0.1, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.p = p  # percentage of best individuals for pbest\n        self.F = F  # Mutation factor\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - current-to-pbest\n                p_best_size = max(int(self.p * self.pop_size), 1)\n                p_best_indices = np.argsort(self.fitness)[:p_best_size]\n                \n                idx_pbest = np.random.choice(p_best_indices)\n                x_pbest = self.population[idx_pbest]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F\n                F = self.F * (0.5 + np.random.rand())\n\n                # Scaling factor\n                scale = 0.1 \n\n                v = self.population[i] + F * (x_pbest - self.population[i]) + F * (x_1 - x_2) * scale\n                v = self.ensure_bounds(v, func)\n                \n                # Selection\n                f_v = func(v)\n                self.evals += 1\n                \n                if f_v < self.fitness[i]:\n                    self.population[i] = v\n                    self.fitness[i] = f_v\n\n                    if f_v < self.f_opt:\n                        self.f_opt = f_v\n                        self.x_opt = v.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.272 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["74760cac-3e52-44f0-bf96-e122e6ba516f"], "operator": null, "metadata": {"aucs": [0.1288018254251312, 0.256939085595701, 0.27985900315546397, 0.20990284191861353, 0.1870482405545516, 0.203576186976004, 0.23022034784694756, 0.2309963586710988, 0.24915831967796098, 0.16336672916433326, 0.26072227202926224, 0.9996564822358844, 0.2559531793340818, 0.20957319906762106, 0.19156078464282622, 0.26123966113938946, 0.2464464365764737, 0.18145824159748536, 0.24936987246141906, 0.4482452000239109]}}
{"id": "fb2e1c76-30aa-497c-a5fa-a65e42f912d6", "fitness": 0.602599824712376, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-pbest mutation, adaptive F and CR, and a probabilistic archive update.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, pbest_ratio=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.pbest_ratio = pbest_ratio\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # pbest selection\n                pbest_size = max(1, int(self.pop_size * self.pbest_ratio))\n                pbest_indices = np.argsort(self.fitness)[:pbest_size]\n                pbest_idx = np.random.choice(pbest_indices)\n                x_pbest = self.population[pbest_idx]\n                \n                # Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n\n                # Adaptive F and CR\n                F = 0.5 + np.random.rand() * 0.5\n                CR = np.random.rand()\n\n                v = self.population[i] + F * (x_pbest - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    # Probabilistic Archive Update\n                    if len(self.archive) < self.archive_size or np.random.rand() < 0.1:\n                        if len(self.archive) < self.archive_size:\n                            self.archive.append(u.copy())\n                        else:\n                            self.archive[np.random.randint(self.archive_size)] = u.copy()\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.603 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["871980f5-21d3-4e77-af5d-fbb320502586"], "operator": null, "metadata": {"aucs": [0.21620712662107777, 0.3827973774929936, 0.5831887836039767, 0.8401051318176117, 0.6939100708031295, 0.7396727740646756, 0.41758505809888924, 0.5707705909120258, 0.6712840293924065, 0.5476090171150165, 0.7911912402215016, 0.9994162448072235, 0.34564029244930894, 0.6121898214426571, 0.9028234416788913, 0.7278796179757889, 0.49781878364141663, 0.7931574395935821, 0.2110441621310637, 0.5077054903842855]}}
{"id": "6f9c793d-f9ba-4017-8b4b-590b3b1a80f0", "fitness": 0.40587060603650577, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation strategy and parameter adaptation using a success-history based adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, F_mu=0.5, CR_mu=0.7, F_std=0.1, CR_std=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F_mu = F_mu\n        self.CR_mu = CR_mu\n        self.F_std = F_std\n        self.CR_std = CR_std\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.sf = []\n        self.scr = []\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Parameter adaptation\n                F = np.clip(np.random.normal(self.F_mu, self.F_std), 0.0, 1.0)\n                CR = np.clip(np.random.normal(self.CR_mu, self.CR_std), 0.0, 1.0)\n\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_1, x_2, x_3 = self.population[idxs]\n\n                v = self.population[i] + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    delta = np.abs(self.fitness[i] - f_u)\n                    self.sf.append(F)\n                    self.scr.append(CR)\n\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    #Update archive: replace a random member\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = u.copy()\n\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n\n                if self.evals >= self.budget:\n                    break\n            \n            if len(self.sf) > 0:\n                self.F_mu = np.mean(self.sf)\n                self.CR_mu = np.mean(self.scr)\n                self.sf = []\n                self.scr = []\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.406 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["871980f5-21d3-4e77-af5d-fbb320502586"], "operator": null, "metadata": {"aucs": [0.14136642351801088, 0.30521959747190963, 0.3944919842974286, 0.5236143358070234, 0.3102273695143648, 0.40146529308609724, 0.3088897583363056, 0.33115304897278663, 0.31716349314247394, 0.19851913838790525, 0.49445973291448475, 0.9838108493450068, 0.40752145636119075, 0.29627911395178175, 0.7531991731795105, 0.4367209498066409, 0.3089010684529615, 0.523531029575673, 0.19189602070209621, 0.4889822839064646]}}
{"id": "0b873c5f-9b1a-433c-a07b-60ba6c8063fe", "fitness": 0.0, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive CR and F, current-to-best mutation, and periodic population reset, promoting diversity and convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7, reset_freq=500):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.reset_freq = reset_freq # Frequency of population reset\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                best_index = np.argmin(self.fitness)\n                x_best = self.population[best_index]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F and CR\n                F = self.F * (0.5 + np.random.rand())\n                CR = self.CR * (0.5 + np.random.rand())\n\n                v = self.population[i] + F * (x_best - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n\n            # Periodic Population Reset\n            if self.evals % self.reset_freq == 0:\n                self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.population])\n                self.evals += self.pop_size\n                best_index = np.argmin(self.fitness)\n                if self.fitness[best_index] < self.f_opt:\n                      self.f_opt = self.fitness[best_index]\n                      self.x_opt = self.population[best_index].copy()\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["74760cac-3e52-44f0-bf96-e122e6ba516f"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "78b753a1-828a-439d-b9cb-f29c011a8c37", "fitness": 0.4048274059745725, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified mutation, adaptive F and CR, and a simple archive update.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=20, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size + len(self.archive), 3, replace=False)\n                if idxs[0] < self.pop_size:\n                    x_1 = self.population[idxs[0]]\n                else:\n                    x_1 = self.archive[idxs[0] - self.pop_size]\n                if idxs[1] < self.pop_size:\n                    x_2 = self.population[idxs[1]]\n                else:\n                    x_2 = self.archive[idxs[1] - self.pop_size]\n                if idxs[2] < self.pop_size:\n                    x_3 = self.population[idxs[2]]\n                else:\n                    x_3 = self.archive[idxs[2] - self.pop_size]\n                \n                F = self.F * (0.5 + np.random.rand())\n                CR = self.CR * (0.5 + np.random.rand())\n                v = self.population[i] + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    #Update archive: replace a random member\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.population[i].copy())\n                    else:\n                        self.archive[np.random.randint(self.archive_size)] = self.population[i].copy()\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDE scored 0.405 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["871980f5-21d3-4e77-af5d-fbb320502586"], "operator": null, "metadata": {"aucs": [0.1508540165898985, 0.2762774858500717, 0.38244837914989505, 0.4562173473801917, 0.30666278455121443, 0.42217782874014687, 0.28807694613573553, 0.34056779775179136, 0.3177168621808264, 0.18748750049387564, 0.5892442730501679, 0.9966037970869739, 0.36293054705928507, 0.30772991361314783, 0.7486712315343197, 0.43182221735120263, 0.32289771439408954, 0.5115676428505529, 0.20808798867168876, 0.48850584505637495]}}
{"id": "664ce672-3c48-4e70-a659-fd9eb562dd99", "fitness": -Infinity, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation and adaptive CR, focusing on exploration and exploitation balance through dynamic parameter adjustment and a reduced archive interaction.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.population = None\n        self.fitness = None\n        self.archive = []\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x)] for x in self.population)\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index][0]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n\n                # Adaptive F and CR\n                F = self.F + 0.1 * np.random.randn()\n                F = np.clip(F, 0.1, 1.0)\n                CR = self.CR + 0.1 * np.random.randn()\n                CR = np.clip(CR, 0.1, 1.0)\n\n                v = self.population[i] + F * (self.x_opt - self.population[i] + x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    \n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(u.copy())\n                    elif np.random.rand() < 0.1:\n                        self.archive[np.random.randint(self.archive_size)] = u.copy()\n\n                if f_u < self.f_opt:\n                    self.f_opt = f_u\n                    self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "An exception occurred: too many indices for array: array is 0-dimensional, but 1 were indexed.", "error": "", "parent_ids": ["c8003434-4d3a-4927-a7a9-4b7dd11e3239"], "operator": null, "metadata": {}}
{"id": "541d8657-3237-4790-a9da-c8e73a3cb8e6", "fitness": 0.0, "name": "AdaptiveDifferentialEvolution", "description": "Further simplified Adaptive Differential Evolution with reduced parameter tuning, smaller population size, and periodic population replacement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, Cr=0.9, refresh_proportion=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.refresh_proportion = refresh_proportion\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F and Cr (simplified - less frequent updates)\n            if self.eval_count % (self.pop_size * 5) == 0: # Update every 5 generations\n                self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n                \n                # Refresh a portion of the population\n                num_refresh = int(self.pop_size * self.refresh_proportion)\n                refresh_indices = np.random.choice(self.pop_size, num_refresh, replace=False)\n                self.pop[refresh_indices] = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(num_refresh, self.dim))\n                self.fitness[refresh_indices] = np.array([func(x) for x in self.pop[refresh_indices]])\n                self.eval_count += num_refresh\n\n                #Update best\n                best_index = np.argmin(self.fitness)\n                if self.fitness[best_index] < self.f_opt:\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.pop[best_index]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d8d4908-e3bd-4dab-998e-9affe55dc151"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "ad6a7452-2d0e-451b-b8b4-fa0f41f8a0f8", "fitness": 0.7396756132977852, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation and reduced evaluations for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F and Cr (simplified - less frequent updates, even more simplified)\n            if self.eval_count % self.pop_size == 0: # Update every generation\n                F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.740 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d8d4908-e3bd-4dab-998e-9affe55dc151"], "operator": null, "metadata": {"aucs": [0.4973044903314371, 0.6796382614372483, 0.6852584209434867, 0.8955227543696624, 0.7940589715172415, 0.8335994255339225, 0.7156755577998202, 0.7255784637268031, 0.7880471038469032, 0.7530042667957009, 0.8985006720140235, 0.9966270942561507, 0.7276932203794405, 0.7697570306296734, 0.9040850312971004, 0.8246015278545105, 0.695994437916573, 0.8789435091949294, 0.20856008883432664, 0.5210619372767504]}}
{"id": "455f294b-4f94-49c0-8761-0636c3202969", "fitness": 0.7121256081739017, "name": "AdaptiveDifferentialEvolution", "description": "Further simplifies Adaptive DE by removing explicit F and CR updates and directly uses random values each generation, and reduces population updates.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                # Adaptive F and Cr (simplified - using random values directly)\n                F = np.random.uniform(0.3, 0.8)\n                Cr = np.random.uniform(0.7, 1.0)\n\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.712 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d8d4908-e3bd-4dab-998e-9affe55dc151"], "operator": null, "metadata": {"aucs": [0.32661516397326207, 0.6580598017848801, 0.714910645746426, 0.873146866418493, 0.7480441485394682, 0.7975111210401439, 0.6701383529463676, 0.7013809338302756, 0.7701194779793636, 0.7064288285382134, 0.8737052125740268, 0.9949730342842207, 0.6504253053111839, 0.7498295022042671, 0.9165994355853894, 0.804968388460143, 0.629349383092583, 0.8520279387436882, 0.22498117752776048, 0.5792974448978765]}}
{"id": "a6ef9d91-5907-489e-8eec-7b885995e624", "fitness": 0.7433764796492753, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with adaptive CR and current-to-best mutation, reducing parameter tuning and complexity for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive CR\n                CR = self.CR * (0.5 + np.random.rand())\n\n                v = self.population[i] + 0.5 * (x_best - self.population[i]) + 0.5 * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.743 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19fb73e8-c0da-4f2d-bfdb-7e58c3127585"], "operator": null, "metadata": {"aucs": [0.24412178896972359, 0.6980545773007822, 0.7961648206537524, 0.918049097544005, 0.825455892040731, 0.8657164786328126, 0.5181732298683153, 0.792368700381145, 0.8382997100547068, 0.7289450167127267, 0.9111607753661533, 0.9999150643397267, 0.6634835722768511, 0.8150283860212308, 0.9292629469320063, 0.8562772783054722, 0.739204712974683, 0.8994258410265265, 0.319411391200605, 0.5090103123835541]}}
{"id": "02d04e72-5ee1-454a-a57f-a9776cfc778e", "fitness": 0.7352201919112374, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified current-to-best mutation and reduced parameter tuning for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n\n                F = 0.5 + np.random.rand() * 0.5  # Adaptive F, simplified\n                v = self.population[i] + F * (self.x_opt - self.population[i] + x_1 - x_2) # current-to-best\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover - binomial with fixed CR\n                CR = 0.7\n                u = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        u[j] = v[j]\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]: \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.735 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["853cc53e-a5c5-4215-a0d6-dd0e7f37e0f7"], "operator": null, "metadata": {"aucs": [0.2901749166318406, 0.7177865257190944, 0.7787528698252134, 0.9171188037365496, 0.8140492909581326, 0.854760451419022, 0.6473965225713652, 0.7603583113989925, 0.808062395154364, 0.77485703931584, 0.9034753496278121, 0.9956847667812075, 0.5066277482170711, 0.719566710493877, 0.9529457084972777, 0.8358087564525596, 0.7539909084981593, 0.8936690770352527, 0.2460721383909118, 0.5332455475002074]}}
{"id": "e5386202-869f-42d5-8f8c-4c4ed4283514", "fitness": 0.6054304688701474, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with simplified adaptive parameter control and a reduced population size for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F and CR\n                F = 0.5 + np.random.rand() * 0.3 # F in [0.5, 0.8]\n                CR = np.random.rand() * 0.5 # CR in [0, 0.5]\n\n                v = self.population[i] + F * (x_best - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.605 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19fb73e8-c0da-4f2d-bfdb-7e58c3127585"], "operator": null, "metadata": {"aucs": [0.18370578400214366, 0.2746586096153304, 0.6554380080521633, 0.8527119512500768, 0.6666338731070881, 0.80608835127264, 0.40045735813445593, 0.5740925194252053, 0.7354288642778646, 0.5348739293451843, 0.7207565035125156, 0.9957571392803494, 0.2992534019280755, 0.62587530284595, 0.8783009498944433, 0.7821776450676973, 0.4777788023506776, 0.8244657915708951, 0.21689722825739188, 0.6032573642128025]}}
{"id": "80233021-8063-4f2c-a584-c6831124434a", "fitness": 0.2450236958724752, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation and dynamically adjusted F and CR based on success rate for faster adaptation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.success_F = self.F\n        self.success_CR = self.CR\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F and CR\n                F = self.success_F * (0.5 + np.random.rand() * 0.5) # Keep F closer to success value\n                CR = self.success_CR * (0.5 + np.random.rand() * 0.5) # Keep CR closer to success value\n                \n                v = self.population[i] + F * (x_best - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.success_F = 0.9 * self.success_F + 0.1 * F # Update based on success\n                    self.success_CR = 0.9 * self.success_CR + 0.1 * CR # Update based on success\n                    \n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.245 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19fb73e8-c0da-4f2d-bfdb-7e58c3127585"], "operator": null, "metadata": {"aucs": [0.09137770904364462, 0.200226899317404, 0.26349465545910444, 0.16515890460401517, 0.15852590439494163, 0.19641994633160464, 0.21648304905475924, 0.1597636364288899, 0.2147708126736979, 0.1473814252826232, 0.20605422658966932, 0.999505823394408, 0.25643593525205677, 0.17542420997467034, 0.18652427695454465, 0.2707908310453849, 0.18373154955707582, 0.21279527067724946, 0.18757387585102459, 0.40803497556273605]}}
{"id": "c48f4e16-e72b-490e-bfff-076c221e9bd6", "fitness": 0.6153556298664451, "name": "AdaptiveDE", "description": "Simplified Adaptive DE with self-adaptive F and CR using current-to-pbest mutation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, pbest_proportion=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pbest_proportion = pbest_proportion\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Adaptive F and CR\n            F = 0.5 + 0.5 * np.random.rand()\n            CR = np.random.rand()\n            \n            # Determine pbest individuals\n            pbest_count = max(1, int(self.pop_size * self.pbest_proportion))\n            pbest_indices = np.argsort(self.fitness)[:pbest_count]\n\n            for i in range(self.pop_size):\n                # Mutation (current-to-pbest)\n                pbest_idx = np.random.choice(pbest_indices)\n                x_pbest = self.population[pbest_idx]\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n\n                v = self.population[i] + F * (x_pbest - self.population[i] + x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.615 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["853cc53e-a5c5-4215-a0d6-dd0e7f37e0f7"], "operator": null, "metadata": {"aucs": [0.22428868372952315, 0.3944826072383447, 0.5998471885216465, 0.8487744584275289, 0.6685293544241, 0.7224187377566353, 0.4773215760369264, 0.5601654176084097, 0.6609995867877796, 0.6823531517305348, 0.795620949553853, 0.9905896559291383, 0.3979425484226179, 0.6501883551905767, 0.8829940553718517, 0.7633798522949161, 0.5000888036182389, 0.7884213761954769, 0.199730581193446, 0.4989756572973588]}}
{"id": "61a4c0d1-6a70-4e85-82de-46716fdae187", "fitness": 0.7641751409281503, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with self-adaptive F and CR parameters and reduced population size update frequency for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.archive = [] # Optional archive for past solutions\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                # Self-adaptive F and CR\n                F = np.clip(np.random.normal(self.F, 0.1), 0.1, 0.9)\n                Cr = np.clip(np.random.normal(self.Cr, 0.1), 0.1, 1.0)\n\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F and Cr (less frequent updates based on success) - removed global adaptation\n            # Reduce frequency of adaptation\n            #if self.eval_count % (self.pop_size * 10) == 0:  # Update every 10 generations\n            #    self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n            #    self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n                # Consider using an archive here for more robust adaptation\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.764 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d8d4908-e3bd-4dab-998e-9affe55dc151"], "operator": null, "metadata": {"aucs": [0.5959865193063663, 0.7527469041809954, 0.7032131149082055, 0.9257304473021176, 0.8653554119488958, 0.8682756467938143, 0.8156244101616681, 0.8435704776342974, 0.8628036366499923, 0.8575045820918717, 0.934927916416622, 0.9915210509282518, 0.4799327927873388, 0.8502968853676642, 0.9596116470793173, 0.8850258661055744, 0.403671915177209, 0.9091466438240837, 0.2535703850611374, 0.5249865648375831]}}
{"id": "1800e76a-591f-4e94-9466-6b474a5d979d", "fitness": 0.0, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation and periodic population rejuvenation for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.F = 0.5  # Initialize F\n        self.Cr = 0.9 # Initialize Cr\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        generation = 0\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n            \n            generation += 1\n            # Adaptive F and Cr (simplified - less frequent updates)\n            if generation % 5 == 0: # Update every 5 generations\n                self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n            \n            # Population Rejuvenation\n            if generation % 10 == 0:\n                worst_idx = np.argmax(self.fitness)\n                self.pop[worst_idx] = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n                self.fitness[worst_idx] = func(self.pop[worst_idx])\n                self.eval_count += 1\n                if self.fitness[worst_idx] < self.f_opt:\n                    self.f_opt = self.fitness[worst_idx]\n                    self.x_opt = self.pop[worst_idx]\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d8d4908-e3bd-4dab-998e-9affe55dc151"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "3350c287-e893-406f-a170-fa17e1c97318", "fitness": 0.7823873093805177, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution using a single random number for both F and CR adaptation, along with aggressive parameter settings for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.6, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Adaptive F and CR using the same random number\n                rand = np.random.rand()\n                F = self.F * (0.5 + rand)\n                CR = self.CR * (0.5 + rand)\n\n                v = self.population[i] + F * (x_best - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDE scored 0.782 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19fb73e8-c0da-4f2d-bfdb-7e58c3127585"], "operator": null, "metadata": {"aucs": [0.5099031904626243, 0.8100866857908261, 0.8562588343962761, 0.9313917231330081, 0.8701992940499474, 0.8908434426980512, 0.36733712696712595, 0.8160180723853743, 0.8678472449564871, 0.8395182539359101, 0.9132899051824449, 0.9961235983219561, 0.8076900889080425, 0.8358462941163742, 0.9603516101816697, 0.8881445908246832, 0.8052493396571858, 0.9202265699030239, 0.23253512856383907, 0.5288851931755031]}}
{"id": "fa09ce03-a9bb-4a9b-811c-bc115a92f1a8", "fitness": 0.7384525646993889, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with a reduced parameter set (only F adaptive) and aggressive clipping for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F (simplified - less frequent updates, even more simplified)\n            if self.eval_count % self.pop_size == 0: # Update every generation\n                F = np.clip(np.random.normal(0.5, 0.3), 0.1, 0.9) # Increased std\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.738 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ad6a7452-2d0e-451b-b8b4-fa0f41f8a0f8"], "operator": null, "metadata": {"aucs": [0.36405276810405385, 0.7342697171638397, 0.7565610500669909, 0.8981356935712169, 0.7624692319755282, 0.811148242536452, 0.7775569039205379, 0.7609395388234872, 0.7992952207270478, 0.7694019511132906, 0.8828248724389038, 0.9991863479749701, 0.5998127188504456, 0.7778211920503337, 0.914637205161006, 0.823813032654324, 0.6951083955762452, 0.8625923459304502, 0.25339094809403573, 0.52603391725462]}}
{"id": "65851f70-55da-4ccd-98af-4c8d35fc1f83", "fitness": 0.6409556854493685, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with self-adaptive parameters and reduced update frequency for enhanced convergence speed and exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=20):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.F = 0.5\n        self.Cr = 0.9\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F and Cr (simplified - less frequent updates)\n            if self.eval_count % (5 * self.pop_size) == 0: # Update every 5 generations\n                self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                self.Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.641 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ad6a7452-2d0e-451b-b8b4-fa0f41f8a0f8"], "operator": null, "metadata": {"aucs": [0.43120269005047174, 0.28516942398322487, 0.5772469569287108, 0.9446646614755781, 0.6395222987206699, 0.293810046942518, 0.3704370055955748, 0.4480048298644238, 0.8706306810459061, 0.8851220842036351, 0.9467618260838364, 0.997923802113529, 0.5171154533753672, 0.8638769399999684, 0.9650171548531445, 0.9108868048526854, 0.7056269968533956, 0.3241370443238474, 0.32864838466556245, 0.5133086230553203]}}
{"id": "a6415b24-5037-400c-8c8a-a348058869e6", "fitness": 0.6816397601968254, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with a simplified, more robust adaptation of F and CR, focusing on exploitation with occasional exploration bursts.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F and Cr (simplified and robust)\n            if self.eval_count % (self.budget//10) == 0: # Update every 10% of budget\n                F = np.clip(np.random.normal(0.5, 0.3), 0.1, 0.9) # Wider range for more exploration\n                Cr = np.clip(np.random.normal(0.9, 0.2), 0.2, 1.0) # Wider range to escape local optima\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.682 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ad6a7452-2d0e-451b-b8b4-fa0f41f8a0f8"], "operator": null, "metadata": {"aucs": [0.31430506791660795, 0.6311734418490051, 0.5244452964724025, 0.8866427579333074, 0.7563948758265499, 0.7486610758457448, 0.5857689773150441, 0.71555739056295, 0.6966339772222361, 0.7665122065029022, 0.8568270178183048, 0.9998381314713526, 0.5622137483021702, 0.6722828533832342, 0.7482882283788694, 0.8036672810968601, 0.6327944936651622, 0.8442027115725632, 0.35506743704250987, 0.5315182337587294]}}
{"id": "70e1df1e-d9f8-47cb-afd2-080869fa7925", "fitness": 0.6803038529789575, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with reduced population size, aggressive F and CR adaptation tied to function evaluation count, and a simplified mutation strategy for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                # Adaptive F and CR based on evaluation count\n                progress = self.evals / self.budget\n                F = 0.5 + 0.5 * progress  # F increases with progress\n                CR = 0.7 + 0.3 * progress # CR increases with progress\n\n                v = self.population[i] + F * (x_best - self.population[i]) + F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.680 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3350c287-e893-406f-a170-fa17e1c97318"], "operator": null, "metadata": {"aucs": [0.5629657626390707, 0.8924332347523973, 0.8793552078076211, 0.9552663803505771, 0.9051418217027517, 0.9329943321909788, 0.30755151513904644, 0.8821327412401014, 0.9102526940168164, 0.1971973112707216, 0.9457987345067581, 0.9976333667799838, 0.3598540070631878, 0.49012981130811495, 0.9751124540472671, 0.3346231905071927, 0.41113738687097534, 0.9351110008836537, 0.22397838934969272, 0.5074077171522421]}}
{"id": "9c819bb6-b700-44d7-9f82-602802f0e2c3", "fitness": 0.7334527948704412, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation and simplified CR adaptation using a fixed value, focusing on faster execution.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, CR=0.7, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR  # Crossover rate\n        self.F = F    # Mutation factor\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                v = self.population[i] + self.F * (x_best - self.population[i]) + self.F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.733 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a6ef9d91-5907-489e-8eec-7b885995e624"], "operator": null, "metadata": {"aucs": [0.2805378491966407, 0.6334035390648247, 0.8008509032183695, 0.921211160260156, 0.8248259538858731, 0.8637216755423589, 0.7010059510668335, 0.7782229480848263, 0.8354960036162025, 0.6532407734813138, 0.9114335306489112, 1.0, 0.5027646882404943, 0.8065625247210871, 0.9464905059879615, 0.8504186438510882, 0.7390925119242615, 0.8953280497326708, 0.21624396036062765, 0.508204724524322]}}
{"id": "57b60798-51f8-47e4-a36f-4f3d95e18256", "fitness": 0.7061482049983345, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Differential Evolution with per-vector adaptive F and CR, reducing complexity and maintaining diversity through bound enforcement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                # Per-vector adaptive F and CR\n                F = np.random.uniform(0.1, 0.9)\n                Cr = np.random.uniform(0.1, 1.0)\n\n                mutated_vector = a + F * (b - c)\n                mutated_vector = np.clip(mutated_vector, func.bounds.lb, func.bounds.ub) # explicit bound handling\n\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.706 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["61a4c0d1-6a70-4e85-82de-46716fdae187"], "operator": null, "metadata": {"aucs": [0.25894767876437086, 0.5805655141571822, 0.7122146718936877, 0.8830182744107851, 0.8190815659343316, 0.8548409269017855, 0.7592107849490487, 0.7476108268896607, 0.8142589781772371, 0.7347708822969804, 0.8709546675032815, 0.9968287675809985, 0.2756754354851185, 0.7560815825064804, 0.928184999968114, 0.8516140240221931, 0.6389793350837892, 0.8845514555718941, 0.24296230273134867, 0.5126114251384002]}}
{"id": "29628a56-8073-4371-94f4-41dac0ea8839", "fitness": 0.5516529880045844, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a dynamically adjusted crossover rate based on population diversity and a simplified mutation strategy for faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def calculate_diversity(self):\n        \"\"\"Calculates the diversity of the population.\"\"\"\n        return np.std(self.population)\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            diversity = self.calculate_diversity()\n            CR = 0.5 + 0.4 * diversity #Adaptive CR based on population diversity. Higher diversity, higher CR\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best with simplified approach\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n\n                v = self.population[i] + 0.5 * (x_best - self.population[i]) + 0.5 * (x_1 - x_2)  # Simplified mutation\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.552 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a6ef9d91-5907-489e-8eec-7b885995e624"], "operator": null, "metadata": {"aucs": [0.43105544744994573, 0.2198399779286785, 0.40289503398122883, 0.21773644215295052, 0.9070742535407018, 0.9304335094001289, 0.33411767081046984, 0.3361736824939233, 0.9210741767485542, 0.2257430396946991, 0.9572740238781356, 0.9979972606005572, 0.37317910940785237, 0.3066152396128362, 0.6698413730018213, 0.611736397681191, 0.7858240750358765, 0.6795632651923478, 0.22747500596691683, 0.49741077551286994]}}
{"id": "22ded323-255d-4fd6-9c92-d901c462c300", "fitness": 0.3994451904475209, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-best mutation and dynamic F and CR based on fitness improvement, promoting faster convergence and better exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=40, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Find best individual\n            best_index = np.argmin(self.fitness)\n            x_best = self.population[best_index]\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-best\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n\n                v = self.population[i] + self.F * (x_best - self.population[i]) + self.F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    \n                    # Adaptive F and CR: reduce if improvement, else increase.\n                    if f_u < self.fitness[i]:\n                        self.F *= 0.95\n                        self.CR *= 1.05\n                    else:\n                        self.F *= 1.05\n                        self.CR *= 0.95\n                    \n                    self.F = np.clip(self.F, 0.1, 0.9)\n                    self.CR = np.clip(self.CR, 0.1, 1.0)\n                    \n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDE scored 0.399 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3350c287-e893-406f-a170-fa17e1c97318"], "operator": null, "metadata": {"aucs": [0.127845210769177, 0.6130370388183104, 0.3694153860278582, 0.1983274389684363, 0.21705336149509769, 0.39120869738839437, 0.2981920199909045, 0.43266858656854124, 0.5139594908523657, 0.19192221167882095, 0.516941968684047, 0.998402975070381, 0.4051910058794682, 0.3755441697872828, 0.6035412287684574, 0.2969465274905576, 0.2834490857402344, 0.46077003145269724, 0.1995419141642616, 0.494945459355125]}}
{"id": "e9b38f43-8ab9-48fc-8c68-6f0d09078be0", "fitness": 0.7528635995842261, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Differential Evolution with adaptive mutation strength based on population diversity and infrequent crossover adaptation, enhancing exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            # Calculate population diversity (standard deviation along each dimension)\n            diversity = np.std(self.pop, axis=0)\n            # Adaptive F based on diversity: Higher diversity -> larger F\n            F = self.F * (1 + np.mean(diversity))  # Scale F by average diversity\n            F = np.clip(F, 0.1, 0.9)  # Clip to a reasonable range\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Infrequent Cr adaptation\n            if self.eval_count % (self.pop_size * 20) == 0: # Adapt Cr less frequently\n                 self.Cr = np.clip(np.random.normal(0.9, 0.05), 0.2, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.753 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["61a4c0d1-6a70-4e85-82de-46716fdae187"], "operator": null, "metadata": {"aucs": [0.4553644923387783, 0.7022089650402841, 0.724847245032666, 0.8833190109165109, 0.8196602648272255, 0.8770401421439671, 0.7019608954014883, 0.7862507231868845, 0.8112714113580677, 0.6997039880341525, 0.8839035750503729, 0.9974350659103972, 0.6903582104798238, 0.8389581936480379, 0.6730057938859089, 0.8486588385977989, 0.7615967112955095, 0.8816615871108706, 0.5057338778558476, 0.5143329995699291]}}
{"id": "46dd9202-9181-495c-a8c7-ca1581d2b775", "fitness": 0.6377497636222389, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with adaptive CR and current-to-pbest mutation using a success history archive for F, focusing on exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, archive_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.F_history = []\n        self.Cr_history = []\n        self.archive = [] # Archive for past solutions\n        self.p_best_factor = 0.1 #percentage of best solutions to select from\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            # Selection of pbest individuals to apply \"current-to-pbest\" mutation\n            p = max(int(self.p_best_factor * self.pop_size), 1)\n            \n            # Determine the best p individuals\n            idx_best = np.argsort(self.fitness)[:p]\n            \n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x1, x2 = self.pop[idxs]\n                \n                # Select a random \"pbest\" individual\n                idx_pbest = np.random.choice(idx_best)\n                x_pbest = self.pop[idx_pbest]\n\n                # Adaptation of F and CR: sample from history\n                if self.F_history:\n                    F = np.random.choice(self.F_history)\n                else:\n                    F = 0.5  # default value if history is empty\n\n                if self.Cr_history:\n                    Cr = np.random.choice(self.Cr_history)\n                else:\n                    Cr = 0.9 # default value if history is empty\n                    \n                # Mutation (current-to-pbest)\n                mutated_vector = np.clip(self.pop[i] + F * (x_pbest - self.pop[i]) + F * (x1 - x2), func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n\n                # Evaluation\n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                # Selection\n                if f < self.fitness[i]:\n                    # Update population\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n\n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(self.pop[i].copy())\n                    else:\n                        idx_replace = np.random.randint(self.archive_size)\n                        self.archive[idx_replace] = self.pop[i].copy()\n                    \n                    # Update success history for F and CR\n                    self.F_history.append(F)\n                    self.Cr_history.append(Cr)\n                    \n                    # Keep history size bounded\n                    self.F_history = self.F_history[-self.archive_size:]\n                    self.Cr_history = self.Cr_history[-self.archive_size:]\n\n                    # Update optimal solution\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            \n            # Reduce frequency of adaptation (more exploitation) - removed global adaptation\n            #if self.eval_count % (self.pop_size * 10) == 0:  # Update every 10 generations\n                #Consider using an archive here for more robust adaptation\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.638 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["61a4c0d1-6a70-4e85-82de-46716fdae187"], "operator": null, "metadata": {"aucs": [0.17126577839328216, 0.9188155765323439, 0.4482020737483704, 0.44720227419608316, 0.9298994221470104, 0.9473638699108896, 0.5444639491891085, 0.7805814624105798, 0.35698778116059404, 0.9175508295028397, 0.31183198089512343, 0.9998236698035264, 0.3350756247877281, 0.928916076881029, 0.7032870744830682, 0.9399970493963145, 0.39320898386673986, 0.9628883912530317, 0.22231125532422036, 0.49532214856289636]}}
{"id": "336b2f7b-3155-429a-b116-53d00160f1ab", "fitness": 0.0, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with periodic population rejuvenation and adaptive mutation strength.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F=0.5, Cr=0.9, refresh_rate=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.refresh_rate = refresh_rate\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        generation = 0\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                # Adaptive F: adjust based on current best fitness\n                F = self.F * (1 + 0.1 * np.random.randn())\n                F = np.clip(F, 0.1, 0.9)\n\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n\n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n\n                f = func(trial_vector)\n                self.eval_count += 1\n\n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n            \n            generation += 1\n            if generation % self.refresh_rate == 0:\n                # Rejuvenate population: replace worst individuals with random ones\n                worst_indices = np.argsort(self.fitness)[-self.pop_size // 5:]  # Replace top 20% worst\n                for idx in worst_indices:\n                    self.pop[idx] = np.random.uniform(func.bounds.lb, func.bounds.ub)\n                    self.fitness[idx] = func(self.pop[idx])\n                    self.eval_count += 1\n                    if self.fitness[idx] < self.f_opt:\n                        self.f_opt = self.fitness[idx]\n                        self.x_opt = self.pop[idx]\n                \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["61a4c0d1-6a70-4e85-82de-46716fdae187"], "operator": null, "metadata": {"aucs": [0]}}
{"id": "6051318f-85d9-48b1-a1d9-7f7f48e61723", "fitness": 0.4479551627927464, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with reduced parameter adaptation frequency and population diversity maintenance for enhanced convergence and exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, diversity_threshold=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.diversity_threshold = diversity_threshold\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def check_diversity(self):\n        \"\"\"Check population diversity and re-initialize if needed.\"\"\"\n        distances = np.linalg.norm(self.pop - np.mean(self.pop, axis=0), axis=1)\n        if np.std(distances) < self.diversity_threshold:\n            return True\n        else:\n            return False\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F and Cr (simplified - less frequent updates)\n            if self.eval_count % (2 * self.pop_size) == 0: # Update every other generation\n                F = np.clip(np.random.normal(0.5, 0.1), 0.1, 0.9)\n                Cr = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n            \n            # Population diversity check and re-initialization\n            if self.eval_count % (4 * self.pop_size) == 0 and self.check_diversity():\n                self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.pop])\n                self.eval_count += self.pop_size\n                \n                # Update best solution after re-initialization\n                best_index = np.argmin(self.fitness)\n                if self.fitness[best_index] < self.f_opt:\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.pop[best_index]\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.448 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ad6a7452-2d0e-451b-b8b4-fa0f41f8a0f8"], "operator": null, "metadata": {"aucs": [0.2126132531823408, 0.3643581496761753, 0.4143959636780452, 0.47441698019599843, 0.32837970835188035, 0.4041511642999859, 0.4243844736286726, 0.342267446807087, 0.3448019224033947, 0.3287538788800496, 0.510974668106877, 0.9994903121913672, 0.46028403630465686, 0.3435736351756573, 0.817752604012198, 0.5158825323133555, 0.3482762950548852, 0.5284793203172429, 0.27438740519379656, 0.5214795060812643]}}
{"id": "4c5a5979-110d-4d76-88e3-b890b2d64115", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation and probabilistic bound correction for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5  # Fixed mutation factor\n        Cr = 0.9 # Fixed crossover rate\n        \n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                mutated_vector = a + F * (b - c)\n\n                # Probabilistic bound correction\n                for j in range(self.dim):\n                    if mutated_vector[j] < func.bounds.lb:\n                        if np.random.rand() < 0.5:\n                            mutated_vector[j] = func.bounds.lb\n                        else:\n                            mutated_vector[j] = np.random.uniform(func.bounds.lb, self.pop[i][j])\n                    elif mutated_vector[j] > func.bounds.ub:\n                        if np.random.rand() < 0.5:\n                            mutated_vector[j] = func.bounds.ub\n                        else:\n                            mutated_vector[j] = np.random.uniform(self.pop[i][j], func.bounds.ub)\n\n\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "An exception occurred: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all().", "error": "", "parent_ids": ["57b60798-51f8-47e4-a36f-4f3d95e18256"], "operator": null, "metadata": {}}
{"id": "17063ca5-65bf-4b7c-b923-bf71d4bcf73a", "fitness": 0.748596799314293, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation and enhanced exploration through wider bounds and population diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            # Population diversity adaptation for F\n            if self.eval_count % self.pop_size == 0:\n                diversity = np.std(self.fitness)\n                F = np.clip(np.random.normal(0.5, 0.3 * (1 + diversity)), 0.1, 0.9)\n            \n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.749 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fa09ce03-a9bb-4a9b-811c-bc115a92f1a8"], "operator": null, "metadata": {"aucs": [0.391899123016921, 0.7556059492889733, 0.7474286843759144, 0.8556636241120681, 0.7786683597669973, 0.8268842548480828, 0.7304483941982418, 0.7229274504123153, 0.8196793745544674, 0.7308667300146325, 0.8914729782178533, 0.9986388665866789, 0.6179756540840129, 0.7874444015994302, 0.9126522736849279, 0.8429480633008373, 0.7035033083416596, 0.876049223826878, 0.4677226225662091, 0.5134566494887606]}}
{"id": "95d1cd8d-4449-4655-8004-aecb0c529078", "fitness": 0.4488016243113516, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with a fixed crossover rate and simplified mutation strategy using only two individuals and adaptive F, aiming for computational efficiency.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                a, b = self.pop[idxs]\n                mutated_vector = np.clip(self.pop[i] + F * (a - b), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F (simplified - less frequent updates, even more simplified)\n            if self.eval_count % self.pop_size == 0: # Update every generation\n                F = np.clip(np.random.normal(0.5, 0.3), 0.1, 0.9) # Increased std\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.449 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fa09ce03-a9bb-4a9b-811c-bc115a92f1a8"], "operator": null, "metadata": {"aucs": [0.1568011764724765, 0.3284234452849313, 0.4112013241628989, 0.626512800627955, 0.3390119720054422, 0.49070676769921995, 0.3051124095178379, 0.3673600907432024, 0.3258657067042561, 0.2195163510100303, 0.7500133399819956, 0.9992323300457304, 0.4011238080671695, 0.3306017433866507, 0.8220689845553903, 0.4681845405459467, 0.3474833506766313, 0.5875077582344024, 0.20109273941228345, 0.4982118470925797]}}
{"id": "00882891-2d4d-492a-aa64-075c5ea5583f", "fitness": 0.7962406341329128, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with adaptive F and CR based on success rate, enhanced by periodic restarts for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F=0.5, Cr=0.9, restart_interval=5000):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.success_history_F = []\n        self.success_history_CR = []\n        self.restart_interval = restart_interval\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def adapt_parameters(self):\n        if self.success_history_F:\n            self.F = np.clip(np.mean(self.success_history_F), 0.1, 0.9)\n        if self.success_history_CR:\n            self.Cr = np.clip(np.mean(self.success_history_CR), 0.2, 1.0)\n        self.success_history_F = []\n        self.success_history_CR = []\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            if self.eval_count % self.restart_interval == 0:\n                self.initialize_population(func) # Restart population\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                mutated_vector = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.success_history_F.append(self.F)\n                    self.success_history_CR.append(self.Cr)\n\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.796 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9b38f43-8ab9-48fc-8c68-6f0d09078be0"], "operator": null, "metadata": {"aucs": [0.3790870650664223, 0.8060147994439955, 0.7210023467411192, 0.9285895101671454, 0.861548263265377, 0.8951657845863421, 0.8025414860153417, 0.8155666371120225, 0.8719973103844938, 0.8252221628043817, 0.9209550361256246, 0.9952251385135976, 0.8278761336109213, 0.8471514854415875, 0.9004035570389014, 0.8917506457876188, 0.8031370548410188, 0.9091396731405608, 0.3939842353584112, 0.5284543572133725]}}
{"id": "711202c8-f10d-480a-8fbe-a2130ad247ba", "fitness": 0.5879079337914264, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified mutation and crossover using a single random number and aggressive bound enforcement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                # Simplified adaptive F and CR\n                rand = np.random.rand()\n                F = 0.5 + rand * 0.4 # F between 0.5 and 0.9\n                Cr = rand # Cr between 0 and 1\n\n                mutated_vector = a + F * (b - c)\n                mutated_vector = np.clip(mutated_vector, func.bounds.lb, func.bounds.ub)\n\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub) # Explicit bound handling after crossover\n\n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.588 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["57b60798-51f8-47e4-a36f-4f3d95e18256"], "operator": null, "metadata": {"aucs": [0.1848052566623627, 0.3262612498054397, 0.5444359505301537, 0.7821970280504786, 0.6436601479677322, 0.7511253965705578, 0.5129485803786229, 0.5187446948013383, 0.6540263268622508, 0.5903118716842471, 0.7866329823989383, 0.9986642539936893, 0.306266652163116, 0.5667106591064939, 0.8821781227702425, 0.7360797216870933, 0.45585394103438814, 0.801537424859299, 0.21209476809107697, 0.5036236464110051]}}
{"id": "c20007fb-3c99-4884-aadf-498db16ff6d6", "fitness": 0.6251162969673063, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with self-adaptive crossover rate and diversity-based mutation factor, reducing parameter tuning.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            # Calculate population diversity (standard deviation along each dimension)\n            diversity = np.std(self.pop, axis=0)\n            # Adaptive F based on diversity: Higher diversity -> larger F\n            F = self.F * (1 + np.mean(diversity))  # Scale F by average diversity\n            F = np.clip(F, 0.1, 0.9)  # Clip to a reasonable range\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                # Self-adaptive crossover rate\n                Cr = np.random.normal(0.5, 0.1)\n                Cr = np.clip(Cr, 0.1, 0.9)\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.625 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9b38f43-8ab9-48fc-8c68-6f0d09078be0"], "operator": null, "metadata": {"aucs": [0.20632607578342887, 0.22017249247688175, 0.6272557079965836, 0.7712297064186447, 0.7746507914951903, 0.8066425475645984, 0.5991219644460628, 0.6821097295615017, 0.7460978324450245, 0.7060238573600097, 0.7065864923426944, 0.9991253392663259, 0.2502936953335989, 0.6371224618771305, 0.8624106634620392, 0.8192056018768402, 0.5086999274855821, 0.8337209792038016, 0.22731841899208427, 0.5182116539581028]}}
{"id": "f115cae7-6140-45b9-a3d3-4c25cbac44c2", "fitness": 0.7198466738396755, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with current-to-pbest mutation, a fixed CR, and a dynamically adjusted F based on success rate, promoting faster convergence and exploration balance.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, CR=0.7, F=0.5, p=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR  # Crossover rate\n        self.F = F    # Initial mutation factor\n        self.p = p      # percentage of best individuals to consider for pbest\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.success_history = [] # Track successful F values\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Select pbest individuals\n            pbest_size = max(1, int(self.pop_size * self.p))\n            pbest_indices = np.argsort(self.fitness)[:pbest_size]\n            \n            for i in range(self.pop_size):\n                # Mutation - current-to-pbest\n                pbest_index = np.random.choice(pbest_indices)\n                x_pbest = self.population[pbest_index]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                v = self.population[i] + self.F * (x_pbest - self.population[i]) + self.F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    self.success_history.append(self.F)\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F based on success history\n            if self.success_history:\n                self.F = np.mean(self.success_history)\n                self.success_history = [] # Reset history\n            else:\n                self.F = 0.5 #reset F to default value\n                \n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.720 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9c819bb6-b700-44d7-9f82-602802f0e2c3"], "operator": null, "metadata": {"aucs": [0.2738153500777367, 0.7105303659993601, 0.7548979418436681, 0.900009181318589, 0.8090843851892603, 0.8524276128954221, 0.6830308091282764, 0.7735170980443414, 0.8337280116840531, 0.5375842745332364, 0.8873207713197592, 0.9972607483310892, 0.5092399934106173, 0.7748770514783454, 0.9307782745240848, 0.8391392097424062, 0.7105670400927107, 0.8950444504767135, 0.21223997730646005, 0.5118409293973805]}}
{"id": "673e796b-2bd4-4908-8420-40bee8059bf9", "fitness": 0.8063992165501093, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with self-adaptive mutation strength and crossover rate, focusing on computational efficiency.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n        self.F = 0.5  # Initialize F\n        self.Cr = 0.9 # Initialize Cr\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                # Self-adaptive F:  Small random perturbation\n                F = np.clip(self.F + np.random.normal(0, 0.01), 0.1, 0.9)\n\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                # Self-adaptive CR: Small random perturbation\n                Cr = np.clip(self.Cr + np.random.normal(0, 0.01), 0.2, 1.0)\n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.806 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9b38f43-8ab9-48fc-8c68-6f0d09078be0"], "operator": null, "metadata": {"aucs": [0.5925076802146142, 0.8207579599061585, 0.7846092348348583, 0.9098459813576792, 0.8493349705294412, 0.8904259166484934, 0.8222442182897919, 0.8247285928592725, 0.8936535419269743, 0.8191007412921382, 0.8640678844157258, 1.0, 0.8307478865779945, 0.8625905076239576, 0.9377886336870448, 0.8982409708778761, 0.8258122800878103, 0.9146778234377835, 0.2722379909378556, 0.514611515496717]}}
{"id": "e868377c-d8df-460e-884b-571ba4ea9f30", "fitness": 0.6835550013428963, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a self-adaptive mutation factor and current-to-pbest mutation strategy, promoting faster convergence and exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, CR=0.7, p=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR  # Crossover rate\n        self.p = p # percentage of best individuals for pbest\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.F = 0.5  # Initial mutation factor\n\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            #Find top p% indices\n            num_pbest = int(self.pop_size * self.p)\n            pbest_indices = np.argsort(self.fitness)[:num_pbest]\n\n\n            for i in range(self.pop_size):\n                # Mutation - current-to-pbest\n                x_pbest = self.population[np.random.choice(pbest_indices)]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                #Self-adaptive F\n                self.F = np.random.normal(0.5, 0.3)\n                self.F = np.clip(self.F, 0.1, 1.0)\n\n                v = self.population[i] + self.F * (x_pbest - self.population[i]) + self.F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDE scored 0.684 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9c819bb6-b700-44d7-9f82-602802f0e2c3"], "operator": null, "metadata": {"aucs": [0.25903150520264506, 0.6033378537176814, 0.7071424590648081, 0.8744317005500962, 0.7777493485147582, 0.8198944831717192, 0.5756289626711923, 0.6937988399881531, 0.7571669853921043, 0.67476549550725, 0.8744862764028556, 0.9925077360134561, 0.40775144241427075, 0.6941292327119293, 0.9263426695513867, 0.81084012679096, 0.6516178479656107, 0.8570556723539685, 0.20567176247279362, 0.5077496264002875]}}
{"id": "e5da6061-91bb-4c06-9d69-39500395acf1", "fitness": 0.45761658797026217, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with a population-weighted mutation and infrequent CR adaptation, balanced for exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F=0.5, Cr=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            # Population-weighted mutation: Weight based on fitness rank\n            ranked_indices = np.argsort(self.fitness)\n            weights = np.arange(1, self.pop_size + 1) / np.sum(np.arange(1, self.pop_size + 1))\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False, p=weights)  # Select parents based on weights\n                a, b = self.pop[idxs]\n                \n                #Current to best mutation\n                mutated_vector = np.clip(self.pop[i] + self.F * (self.x_opt - self.pop[i]) + self.F * (a - b), func.bounds.lb, func.bounds.ub)\n\n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n\n                f = func(trial_vector)\n                self.eval_count += 1\n\n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Infrequent Cr adaptation\n            if self.eval_count % (self.pop_size * 10) == 0:  # Adapt Cr less frequently\n                self.Cr = np.clip(np.random.normal(0.9, 0.05), 0.2, 1.0)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.458 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9b38f43-8ab9-48fc-8c68-6f0d09078be0"], "operator": null, "metadata": {"aucs": [0.17440095869936145, 0.40405808567595647, 0.3636237642991622, 0.1963633706791399, 0.219430890992258, 0.7497944154315108, 0.353533344143972, 0.406576242486102, 0.31862315112028095, 0.2145329312515052, 0.5806251885576583, 0.9954824197191684, 0.3690736302910955, 0.9357904349514491, 0.7643549204555954, 0.3375949398031357, 0.558669804830757, 0.4613767464432731, 0.25567238980344287, 0.4927541297704182]}}
{"id": "e254e704-7cd7-4356-8747-547b3eb5dea0", "fitness": 0.6447760731570111, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with self-adaptive crossover rate based on success history, enhancing convergence speed and robustness.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=25, F=0.5, Cr=0.9, cr_decay=0.99):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.cr_decay = cr_decay  # Decay factor for Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.successful_cr = []\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.successful_cr = []  # Reset successful CR values\n        self.Cr = 0.9 # Reset CR\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                mutated_vector = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.successful_cr.append(self.Cr)\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Self-adaptive Cr based on success history\n            if self.successful_cr:\n                self.Cr = np.mean(self.successful_cr)\n            \n            self.Cr = self.Cr * self.cr_decay  # Decay Cr\n            self.Cr = np.clip(self.Cr, 0.1, 0.99) # Keep within bounds\n            self.successful_cr = [] # Clear success history for next generation\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.645 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9b38f43-8ab9-48fc-8c68-6f0d09078be0"], "operator": null, "metadata": {"aucs": [0.23458553742585875, 0.4669802073535141, 0.5973853959563948, 0.9324981372905394, 0.7979205389940245, 0.8507984266509399, 0.5482664240779177, 0.5316059538056479, 0.7490047580524712, 0.724302166238904, 0.9060171958342133, 0.9989630759351968, 0.24677645875872678, 0.5783299259602721, 0.7686884652631276, 0.8634476917567804, 0.4881455800725104, 0.8807751303387648, 0.23191289084522881, 0.4991175025291892]}}
{"id": "854bb0d7-24b7-4156-8d7e-0888e0bbf7fb", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with reduced parameter set (only F adaptive), aggressive clipping and a mirrored boundary handling for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                mutated_vector = a + F * (b - c)\n\n                # Mirrored boundary handling\n                for j in range(self.dim):\n                    if mutated_vector[j] < lb:\n                        mutated_vector[j] = lb + (lb - mutated_vector[j])\n                    elif mutated_vector[j] > ub:\n                        mutated_vector[j] = ub - (mutated_vector[j] - ub)\n                \n                mutated_vector = np.clip(mutated_vector, lb, ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n            # Adaptive F (simplified)\n            if self.eval_count % self.pop_size == 0:\n                F = np.clip(np.random.normal(0.5, 0.3), 0.1, 0.9)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "An exception occurred: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all().", "error": "", "parent_ids": ["fa09ce03-a9bb-4a9b-811c-bc115a92f1a8"], "operator": null, "metadata": {}}
{"id": "f83bdca4-4003-4ffd-be22-e2e43348748f", "fitness": 0.3614234731685294, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with self-adaptive mutation strength based on a learning rate, and a fixed crossover rate, focusing on exploration-exploitation balance and computational efficiency.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, CR=0.7, F=0.5, lr=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR  # Crossover rate\n        self.F = F    # Initial mutation factor\n        self.lr = lr   # Learning rate for F adaptation\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - using current individual and two random individuals\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                v = self.population[i] + self.F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    # Update F based on success\n                    self.F = max(0, min(1, self.F * (1 - self.lr) + np.random.normal(0, 0.01) * self.lr))\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                else:\n                    # Dampen F if no improvement\n                     self.F = max(0, min(1, self.F * (1 + self.lr) + np.random.normal(0, 0.01) * self.lr))\n                \n                if self.evals >= self.budget:\n                    break\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.361 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f115cae7-6140-45b9-a3d3-4c25cbac44c2"], "operator": null, "metadata": {"aucs": [0.14615591864749877, 0.2188749174068214, 0.3421324374859387, 0.3403643575184321, 0.2760787671237743, 0.4039108612339618, 0.2845575708053405, 0.30937384869473805, 0.28466611134270103, 0.18490432213007402, 0.36012647742746595, 0.9834610918225081, 0.2819386201743024, 0.29928001473684807, 0.7087962316477907, 0.40102891406849506, 0.2903826248923045, 0.4475939027084612, 0.18384794052584097, 0.480994532977291]}}
{"id": "048d800b-090b-4c20-a2f2-ea9578620dae", "fitness": 0.7308355210265329, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with self-adaptive mutation strength and crossover rate based on current population best, promoting faster convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            best_idx = np.argmin(self.fitness) # Find best individual in population\n            \n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                a, b = self.pop[idxs]\n                \n                # Current-to-best mutation\n                mutated_vector = np.clip(self.pop[i] + F * (self.pop[best_idx] - self.pop[i]) + F * (a - b), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.731 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["17063ca5-65bf-4b7c-b923-bf71d4bcf73a"], "operator": null, "metadata": {"aucs": [0.2208002117256337, 0.8580705210322676, 0.7175391569095189, 0.17262785596788088, 0.8955435905295227, 0.9089584090950248, 0.33794894905142714, 0.861255541672008, 0.9094564981352785, 0.5020301217872023, 0.9435004226395346, 0.9969500150024145, 0.8439546548320589, 0.8873339408675915, 0.8402789957101229, 0.906126710824684, 0.8462007737419468, 0.9358164583734702, 0.5257133961705456, 0.5066041964625281]}}
{"id": "7c1acdb2-7370-4f8a-9202-dda4e813d683", "fitness": 0.6676080519209385, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with dynamic F and CR, optimized for computational efficiency and exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                # Dynamic F and CR adaptation\n                F = 0.5 + 0.3 * np.random.randn()\n                F = np.clip(F, 0.1, 1.0)\n                Cr = np.random.rand() * 0.5 + 0.4 # CR between 0.4 and 0.9\n\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.668 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["17063ca5-65bf-4b7c-b923-bf71d4bcf73a"], "operator": null, "metadata": {"aucs": [0.21456891181537652, 0.4302141317335507, 0.6862350410534679, 0.8479326738271542, 0.7647290109030498, 0.7902823824005192, 0.6512799521657286, 0.6617181393918541, 0.7500854344685226, 0.6912985389459783, 0.8350934773078307, 0.9921727066101699, 0.3906973465602347, 0.6944615994625722, 0.899422244594975, 0.8219407884796859, 0.608460019363948, 0.8373703160481285, 0.26364431297156765, 0.5205540103144564]}}
{"id": "15315201-167f-41e2-b832-403dcd974c9c", "fitness": 0.7171597202693342, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with success-history based F adaptation and clipped mutation vectors for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, CR=0.7, F=0.5, p=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR  # Crossover rate\n        self.F = F    # Initial mutation factor\n        self.p = p      # percentage of best individuals to consider for pbest\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.success_history = []\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Select pbest individuals\n            pbest_size = max(1, int(self.pop_size * self.p))\n            pbest_indices = np.argsort(self.fitness)[:pbest_size]\n            \n            for i in range(self.pop_size):\n                # Mutation - current-to-pbest\n                pbest_index = np.random.choice(pbest_indices)\n                x_pbest = self.population[pbest_index]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_1, x_2 = self.population[idxs]\n                \n                v = self.population[i] + self.F * (x_pbest - self.population[i]) + self.F * (x_1 - x_2)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n                    self.success_history.append(self.F)\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                \n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F based on success history\n            if self.success_history:\n                self.F = np.clip(np.mean(self.success_history), 0.1, 0.9) # Clip F to avoid extreme values\n                self.success_history = [] # Reset history\n            else:\n                self.F = 0.5\n                \n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.717 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f115cae7-6140-45b9-a3d3-4c25cbac44c2"], "operator": null, "metadata": {"aucs": [0.26869384540762553, 0.6809066397791756, 0.7469923337508637, 0.9165892866898664, 0.8174926193669627, 0.8637004902093157, 0.6411323666722438, 0.7684851190918213, 0.832248102972071, 0.48716986724884004, 0.9029358004034964, 0.9953494442079849, 0.4435681619427644, 0.7970663044730724, 0.9362281015986295, 0.8563576612508453, 0.7084543920993611, 0.8950017563377568, 0.2745245292248315, 0.5102975826591551]}}
{"id": "caa5e7f2-781a-4bce-913a-eb8a36219cf0", "fitness": 0.7709013989357179, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with simplified parameter adaptation and a memory-based mutation strategy for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, Cr=0.9, memory_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.Cr = Cr\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.memory_F = np.full(memory_size, F)\n        self.memory_CR = np.full(memory_size, Cr)\n        self.memory_idx = 0\n        self.memory_size = memory_size\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def adapt_parameters(self, success, F, Cr):\n        if success:\n            self.memory_F[self.memory_idx] = F\n            self.memory_CR[self.memory_idx] = Cr\n            self.memory_idx = (self.memory_idx + 1) % self.memory_size\n        \n        self.F = np.clip(np.median(self.memory_F), 0.1, 0.9)\n        self.Cr = np.clip(np.median(self.memory_CR), 0.2, 1.0)\n\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n\n                mutated_vector = np.clip(a + self.F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < self.Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.adapt_parameters(True, self.F, self.Cr)\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n                else:\n                    self.adapt_parameters(False, self.F, self.Cr)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.771 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["00882891-2d4d-492a-aa64-075c5ea5583f"], "operator": null, "metadata": {"aucs": [0.34143688603656497, 0.8485120984144925, 0.43981084483241173, 0.9543894304795255, 0.8969032377778197, 0.9165205321130007, 0.8454448594873516, 0.8676522527584816, 0.8134849839623023, 0.7564913394165179, 0.9367457476023318, 0.995368196756842, 0.43323171270809924, 0.8813560932349433, 0.7924585562681707, 0.9154456750786627, 0.6260298429568134, 0.736316762675278, 0.7729487224389087, 0.6474802037158404]}}
{"id": "0391fcc7-a6f2-4f1e-a4d8-dcb707aff29d", "fitness": 0.38878521264688903, "name": "AdaptiveDifferentialEvolution", "description": "Simplified Adaptive Differential Evolution with dynamic F adaptation based on fitness improvement and enhanced exploration via larger steps.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.eval_count += self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.pop[np.argmin(self.fitness)]\n\n    def __call__(self, func):\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.initialize_population(func)\n\n        F = 0.5\n        Cr = 0.9\n        \n        success_count = 0\n\n        while self.eval_count < self.budget:\n            \n            # Dynamic F adaptation based on success\n            if self.eval_count % self.pop_size == 0:\n                if success_count > self.pop_size * 0.2:\n                    F = max(0.1, F - 0.05) # Reduce F if more successful\n                else:\n                    F = min(0.9, F + 0.05)  # Increase F if less successful\n                success_count = 0\n\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.pop[idxs]\n                \n                #Enhanced Exploration by Larger steps\n                mutated_vector = np.clip(a + F * (b - c), func.bounds.lb, func.bounds.ub)\n                \n                cross_mask = np.random.rand(self.dim) < Cr\n                trial_vector = np.where(cross_mask, mutated_vector, self.pop[i])\n                \n                f = func(trial_vector)\n                self.eval_count += 1\n                \n                if f < self.fitness[i]:\n                    self.pop[i] = trial_vector\n                    self.fitness[i] = f\n                    success_count +=1\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial_vector\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution scored 0.389 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["17063ca5-65bf-4b7c-b923-bf71d4bcf73a"], "operator": null, "metadata": {"aucs": [0.2171670790546435, 0.22771704082629918, 0.3318777411278745, 0.35106231743406524, 0.5088644597287473, 0.4231731352530458, 0.32775362768855687, 0.3084172169662901, 0.32788973343423755, 0.3186560812773187, 0.4712937379428116, 1.0, 0.26950872648243174, 0.29677904696115665, 0.6074354368833037, 0.343613057168228, 0.43709387368959873, 0.2988111993033644, 0.20931281010430935, 0.4992779316114977]}}
{"id": "54c80f8f-c504-48c5-a5db-3863e1560ac4", "fitness": 0.5544109281311331, "name": "AdaptiveDE", "description": "Simplified Adaptive Differential Evolution with a current-to-rand mutation strategy, dynamically adjusted mutation factor, and reduced complexity for faster convergence and better exploration.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, CR=0.7, F=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.CR = CR  # Crossover rate\n        self.F = F    # Initial mutation factor\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.Inf\n        self.x_opt = None\n        self.evals = 0\n        self.success_history = []\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index].copy()\n\n    def ensure_bounds(self, vec, func):\n        vec = np.clip(vec, func.bounds.lb, func.bounds.ub)\n        return vec\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            for i in range(self.pop_size):\n                # Mutation - current-to-rand\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n\n                v = self.population[i] + self.F * (x_r1 - self.population[i]) + self.F * (x_r2 - x_r3)\n                v = self.ensure_bounds(v, func)\n                \n                # Crossover\n                u = np.where(np.random.rand(self.dim) < self.CR, v, self.population[i])\n\n                # Selection\n                f_u = func(u)\n                self.evals += 1\n                \n                if f_u < self.fitness[i]:\n                    self.population[i] = u\n                    self.fitness[i] = f_u\n\n                    if f_u < self.f_opt:\n                        self.f_opt = f_u\n                        self.x_opt = u.copy()\n                        self.success_history.append(self.F)\n\n                if self.evals >= self.budget:\n                    break\n\n            # Adapt F based on success history\n            if self.success_history:\n                self.F = np.mean(self.success_history)\n                self.success_history = [] # Reset history\n            else:\n                self.F = 0.5 #reset F to default value\n                \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDE scored 0.554 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f115cae7-6140-45b9-a3d3-4c25cbac44c2"], "operator": null, "metadata": {"aucs": [0.1909307626871216, 0.3180267588651343, 0.4762958948816388, 0.8265800824214412, 0.5483211261475431, 0.8084290228170342, 0.37879551436050174, 0.6361688188156898, 0.7548103771408395, 0.22992710839745, 0.8569221400704898, 0.9939699988256936, 0.27449415143782885, 0.5607146122809719, 0.8155916294851517, 0.3658898677665192, 0.5158557359036562, 0.8361913351858438, 0.19763400335432812, 0.502669621777787]}}
